{"pages":[{"title":"","date":"2018-07-12T07:06:42.844Z","updated":"2018-07-12T07:03:11.873Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"","date":"2018-07-12T11:38:38.913Z","updated":"2018-07-12T11:38:38.913Z","comments":true,"path":"git常见命令.html","permalink":"http://yoursite.com/git常见命令.html","excerpt":"","text":"git 命令初始化本地仓库12345git initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/rjli/booktobook.gitgit push -u origin master 在github上面创建远程仓库的时候，不要创建readme.md,即可用上述命令创建成功 【问题】 因为本地创建了readme.md，导致提交的时候造成了冲突 gitignore文件 项目初始化的时候添加.gitignore 因为是点开头，没有文件名，没办法直接在windows目录下直接创建，必须通过右键Git Bash，按照linux的方式来新建.gitignore文件。具体步骤如下： 在需要创建 .gitignore 文件的文件夹, 右键选择Git Bash 进入命令行，进入项目所在目录。 输入 touch .gitignore 在文件夹就生成了一个“.gitignore”文件。 然后在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。 在添加.gitignore文件的时候，参照 gitignore 原则 分支把分支推送到远端 https://blog.csdn.net/kakadiablo/article/details/79517985 创建分支删除分支 删除本地分支 1git branch -D &lt;BranchName&gt; 删除远程分支 1git push origin --delete &lt;BranchName&gt; 查看远程分支 使用如下git命令查看所有远程分支： git branch -r 查看远程和本地所有分支： git branch -a 其中远程分支是红色的 查看本地分支 git branch 在输出结果中，前面带* 的是当前分支。 拉取远程分支并创建本地分支方法一使用如下命令： git checkout -b 本地分支名x origin/远程分支名x 使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 方式二使用如下命令： git fetch origin 远程分支名x:本地分支名x 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。 采用此种方法建立的本地分支不会和远程分支建立映射关系。 本地分支和远程分支https://blog.csdn.net/carfge/article/details/79691360 建立映射关系的作用建立映射关系（或者为跟踪关系track）。这样使用git pull或者git push时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。git branch -vv输出： 上面的本地分支和远程分支都有映射关系，如果没有，就需要手动建立：git branch -u origin/分支名，或者git branch --set-upstream-to origin/分支名origin 为git地址的标志，可以建立当前分支与远程分支的映射关系。 撤销本映射关系git branch --unset-upstream之后可以再次用git branch -vv 查看本地分支和远程分支映射关系 本地分支只能跟踪远程的同名分支吗 答案是否定的，本地分支可以与远程不同名的分支建立映射关系 ​ 操作和之前的一样，只是可以指定和本地分支名不同的远程分支名，然后使用git branch -vv 查看映射关系，可以发现建立映射成功。 常见问题远程库‘origin’不存在 【 问题描述】 fatal: ‘origin’ does not appear to be a git repository ​ fatal: Could not read from remote repository. ​ Please make sure you have the correct access rights and the repository exists. 【 解决方案】 首先,检查你的起源是设定的运行 1git remote -v ​ ​ 显示 orgin git@github.com:chaorwin/chaorwin.git (fetch) orgin git@github.com:chaorwin/chaorwin.git (push) “origin” 不存在 ​ 2.重命名它,或改变URL,删除它,然后添加正确的一个。 ​ git remote remove orgin ​ 3. 增加一个 ​ git remot add origin git@github.com:chaorwin/chaorwin.git ​ 4. git push origin master 文件大小超过限制问题描述: github RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 出现此问题有可能是上传大小限制执行如下命令: 12git config http.postBuffer 524288000//524288000算法： 1024*1024*500(500M) 在更改了文件大小之后，可能会出现如下错误： curl 56 OpenSSL SSL_read:SSL_ERROR_sysCALL 1git config http.sslVerify &quot;false&quot; 参考文章 git常见命令思维导图"},{"title":"","date":"2018-07-12T11:46:50.990Z","updated":"2018-07-12T07:03:11.991Z","comments":true,"path":"images/海康摄像头获取rtsp.html","permalink":"http://yoursite.com/images/海康摄像头获取rtsp.html","excerpt":"","text":"海康视屏获取rtsp1、登录企业视屏管理平台，系统登录界面如下所示： 企 业 名 称：虹桥药用访 问 地 址：http://www.hik-online.com/rchongqiao用户名/密码：admin/hbj3022810 2.登录成功之后的在配置中查找都赢的RTSP对应的端口号，此处为外网端口为2554。 3.查看视频编码设置,此处的视频采用H.264编码实现。 4.登录9800平台，查看对应的摄像头的通道信息（可省略） 访问地址：10.1.12.3:8090 用户名/密码： admin /Rchb2016 5.查看设备型号（可省略） 6.查看系统对应的摄像头的通道号：（可省略） 7.得到rtsp地址 URL规定： 1rtsp://username:password@&lt;ipaddress&gt;/&lt;videotype&gt;/ch&lt;number&gt;/&lt;streamtype&gt; 注： 1.VLC可以支持解析URL里的用户名密码，实际发给设备的RTSP请求不支持带用户名密码。 2.videotype:视屏编码格式[h6264/mpeg4] 3.ch 通道号 （ch33:IP通道1，ch34：IP通道2…/ ch1:模拟通道1, ch2:模拟通道2…） 4.streamtype:码流类型[主码流（main/av_stream） 子码流（sub/av_stream）] 我们的rtsp取流地址为： 1rtsp://admin:hbj3022810@171.121.218.169:2554/h264/ch33/main/av_stream 8、测试 使用vlc播放器在添加网络流地址中输入上述地址即可播放。 [相关文章] 最新海康摄像机、NVR、流媒体服务器、回放取流RTSP地址规则说明 海康大华RTSP取流URL格式"},{"title":"","date":"2018-07-12T07:06:42.860Z","updated":"2018-07-12T07:03:11.989Z","comments":true,"path":"images/流媒体.html","permalink":"http://yoursite.com/images/流媒体.html","excerpt":"","text":"流媒体 流媒体（Streaming media）是指将一连串的媒体数据压缩后，经过网络分段发送数据，在网络上即时传输影音以供观赏的一种技术与过程，此技术使得数据包得以像流水一样发送；如果不使用此技术，就必须在使用前下载整个媒体文件。 流媒体协议介绍常见的流媒体协议有很多比如: RTP(Real-time Transport Protocol), 常用语电话会议, 网络电话等场景, 但是缺点是不提供网络保障 RTCP(Real-time Transport Control Protocol), 是实时传输协议（RTP）的一个姐妹协议, 也常用于语电话会议, 网络电话等场景. RTMP(Real Time Streaming Protocol), RTMP是Adobe开发的协议 HLS(HTTP Live Streaming)是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播 RTMPReal Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和HLS一样都可以应用于视频直播，区别是RTMP基于flash无法在ios的浏览器里播放，但是实时性比HLS要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。 RTSP协议（ 实时流协议)是一种基于文本的应用层协议，在语法及一些消息参数等方面，RTSP协议与HTTP协议类似。 RTSP 以客户服务器方式工作，它是一个多媒体播放控制协议，用来使用户在播放从因特网下载的实时数据时能够进行控制，如：暂停/继续、后退、前进等。因此 RTSP 又称为“因特网录像机遥控协议”。 要实现 RTSP 的控制功能，不仅要有协议，而且要有专门的媒体播放器(media player)和媒体服务器(media server)。媒体服务器与媒体播放器的关系是服务器与客户的关系。 HLS备注用于视频录制和直播: OBS [http://www.obsapp.net/#] ffmpeg vlc 【相关文章】 1.H5在线直播"},{"title":"","date":"2018-07-12T07:06:42.867Z","updated":"2018-07-12T07:03:11.993Z","comments":true,"path":"images/海康视屏的rtsp实时播放.html","permalink":"http://yoursite.com/images/海康视屏的rtsp实时播放.html","excerpt":"","text":"实时视屏播放的简单实现 通过使用nginx搭建一个简单的服务器，使用ffmpeg推送rtmp实时流，利用video标签实现可以在web端和手机端的浏览器中进行直播。 Windows下面搭建基于rtmp的服务器硬件环境操作系统：windows7旗舰版 处 理 器：Intel(R) Core(TM)i5-5200 CPU @2.20GHz 2.20 GHz 系统内存： 8GB 系统类型：64位操作系统 软件环境及配置 下载 nginx 1.7.11.3 Gryphon，然后解压到对应的目录；下载链接-Gryphon.zip 将解压后的目录名:nginx 1.7.11.3 Gryphon改成:nginx-1.7.11.3-Gryphon ​ 下载服务器状态检查程序 stat.xsl 下载地址 将nginx-rtmp-module-master.zip解压后复制到目录:nginx-1.7.11.3-Gryphon中。 保证stat.xls的目录为:nginx-1.7.11.3-Gryphon\\nginx-rtmp-module\\stat.xsl 修改conf\\nginx-win.conf 配置文件。 添加rtmp服务。 123456789101112rtmp &#123; server &#123; listen 1935; chunk_size 4000; application hls&#123; live on ; hls on ; hls_path html/hls; hls_fragment 5s; &#125; &#125;&#125; 配置http server 12345678910server &#123; listen 80; location /hls &#123; types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root html; expires -1; &#125; 启动服务器 在nginx.exe所在的文件夹，按住shift+右键，选中在此处打开命令窗口，进入windows的cmd。输入以下命令启动nginx服务： 1nginx.exe -c conf\\nginx-win.conf 启动结果 直接在浏览器里输入127.0.0.1就可以进入浏览器的欢迎界面 提供rtmp直播源在搭建好基于rtmp的服务器之后，需要提供rtmp直播源。这里我们使用的海康视屏的rtsp直播源。根据nginx.conf中的hls_path配置，下面这个命令会向本地的html\\hls下面写入ts片段和m3u8文件。 1ffmpeg -f rtsp -re -analyzeduration 8000 -probesize 200000 -i &quot;rtsp://admin:hbj3022810@171.121.218.169:2554/h264/ch33/main/av_stream&quot; -strict -2 -c copy -flvflags aac_seq_header_detect -f flv rtmp://localhost/hls/mystream 注意 1、这里提供rtmp源的机器不一定和nginx在同一台物理主机上，可以是网络上的另一台机器，只要保证它能与nginx所在的主机建立tcp链接即可。（也就是nginx主机需要开启rtmp服务的监听端口，这里是1935，当然你也可以修改为其他的端口。） 在网页中展示视屏在nginx-1.7.11.3-Gryphon/html目录下面创建一个live.html。 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://vjs.zencdn.net/5.10/video-js.css&quot;&gt;&lt;/head&gt; &lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls autoplay=true&gt; &lt;source src=&quot;hls/mystream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt; &lt;script src=&quot;http://vjs.zencdn.net/5.10/video.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://npmcdn.com/videojs-contrib-hls@^3.0.0/dist/videojs-contrib-hls.js&quot;&gt;&lt;/script&gt; &lt;/script&gt; &lt;script&gt; var player = videojs(&apos;example-video&apos;); player.play(); &lt;/script&gt;&lt;/html&gt; 如果只是用video标签是无法播放.m3u8的视屏文件的，需要引入videojs-contrib-hls.js。videojs-contrib-hls支持一堆HLS功能 web端运行效果 手机端运行效果 手机端如果与web可以在同一个网络环境中，那么输入对应本机ip地址也是可以查看的，并且支持横屏、竖屏的切换。"},{"title":"","date":"2018-07-12T11:11:56.720Z","updated":"2018-07-12T11:11:56.720Z","comments":true,"path":"rtsp-hls-online-live/新建文本文档.html","permalink":"http://yoursite.com/rtsp-hls-online-live/新建文本文档.html","excerpt":"","text":"FFMPEG功能说明Fmpeg是用于录制、转换和流化音频和视频的完整解决方案， 包括 libavcodec ，一套领先的音/视频编解码类库。FFmpeg 在Linux上开发，当可以在大多数操作系统下编译，包括Windows。 Note FFmpeg对GCC的依赖很强，所以就算是在Windows上， 用VC编译FFmpeg也不是一件轻松的事情。请尽量使用 GCC来编译FFmpeg，比较事半功倍。 包组成结构FFmpeg主要由一下几个部分组成： libavcodec：一个包含了所有FFmpeg音视频编解码器的库。为了保证最优性能和高可复用性,大多数编解码器从头开发的。 libavformat： 一个包含了所有的普通音视格式的解析器和 产生器的库。 三个实例程序，这三个实例较为复杂，基本可以作为API使用手册： ffmpeg：命令行的视频格式转换程序。ffplay：视频播放程序。（需要SDL支持）ffserver：多媒体服务器 下载使用下载地址官网地址：http://ffmpeg.org/ git地址： https://github.com/FFmpeg/FFmpeg ffmpeg命令参数介绍 基本格式 -formats 输出所有可用格式 -f fmt 指定格式(音频或视频格式) -i filename 指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头 -y 覆盖已有文件 -t duration 记录时长为t -fs limit_size 设置文件大小上限 -ss time_off 从指定的时间(s)开始， [-]hh:mm:ss[.xxx]的格式也支持 -itsoffset time_off 设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss[.xxx]的格式也支持 -title string 标题 -timestamp time 时间戳 -author string 作者 -copyright string 版权信息 -comment string 评论 -album string album名 -v verbose 与log相关的 -target type 设置目标文件类型(“vcd”, “svcd”, “dvd”, “dv”, “dv50”, “pal-vcd”, “ntsc-svcd”, …) -dframes number 设置要记录的帧数 视屏选项 常用命令音频转换 ffmpeg -i my_audio.wav my_audio.mp3 视频转换 ffmpeg -i my_video.mpeg -s 500×500 my_video.flv 从视频中截取图片 分离视频音频流 ffmpeg -i input_file -vcodec copy -an output_file_video //分离视频流 ffmpeg -i input_file -acodec copy -vn output_file_audio //分离音频流 视频解复用 ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264``ffmpeg –i test.avi –vcodec copy –an –f m4v test.264 视频转码 ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264 //转码为码流原始文件ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264 //转码为码流原始文件 ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi //转码为封装文件//-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制 视频封装 ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file 视频剪切 ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg //提取图片 ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi //剪切视频//-r 提取图像的频率，-ss 开始时间，-t 持续时间 视频录制 ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi 常见错误相关文章1.ffmpeg常用参数一览表"},{"title":"","date":"2018-07-12T11:12:30.160Z","updated":"2018-07-12T07:03:12.049Z","comments":true,"path":"springboot/spring-boot-jdbcTemplate.html","permalink":"http://yoursite.com/springboot/spring-boot-jdbcTemplate.html","excerpt":"","text":"JDBC Template 的使用数据源配置在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。 首先，为了连接数据库需要引入jdbc支持，在pom.xml中引入如下配置： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 嵌入式数据库支持嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。 比如，我们可以在pom.xml中引入如下配置使用HSQL 12345&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 连接生产数据源以MySQL数据库为例，先引入MySQL连接的依赖包，在pom.xml中加入： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 在src/main/resources/application.properties中配置数据源信息 1234spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=dbuserspring.datasource.password=dbpassspring.datasource.driver-class-name=com.mysql.jdbc.Driver 连接JNDI数据源当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。 1spring.datasource.jndi-name=java:jboss/datasources/customers 使用JDBCTemplate在数据库中创建一张User表（id，name,age）,其中id设置为自增长类型的。 创建一个UserService接口类，实现基本的增，删，改，查方法： 123456789101112131415161718192021222324public interface UserService&#123; /** * 新增一个用户 * @param name * @param age */ void create(String name, Integer age); /** * 根据name删除一个用户高 * @param name */ void deleteByName(String name); /** * 获取用户总量 */ Integer getAllUsers(); /** * 删除所有用户 */ void deleteAllUsers();&#125; 通过JdbcTemplate实现UserService中定义的数据访问操作创建对应的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 创建用户 * @param name * @param age */ @Override public void create(String name, Integer age) &#123; jdbcTemplate.update(&quot;insert into user(name,age) values(?,?)&quot;,name,age); &#125; /** * 根据名字删除用户 * @param name */ @Override public void deleteByName(String name) &#123; jdbcTemplate.update(&quot;delete from user where name = ? &quot;,name); &#125; /** * 获取所有用户 * @return */ @Override public Integer getAllUsers() &#123; return jdbcTemplate.queryForObject(&quot;select count(1) from user&quot;,Integer.class); &#125; /** * 删除用户 */ @Override public void deleteAllUsers() &#123; jdbcTemplate.update(&quot;delete from user&quot;); &#125;&#125; 创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。 12345678910111213141516171819202122232425262728@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserServiceTest &#123; @Autowired private UserService userService; @Before public void setUp() &#123; // 准备，清空user表 userService.deleteAllUsers(); &#125; @Test public void test()&#123; userService.create(&quot;张三&quot;,20); userService.create(&quot;李四&quot;,10); userService.create(&quot;王五&quot;,30); userService.create(&quot;赵六&quot;,42); userService.create(&quot;孙二&quot;,66); // 查数据库，应该有5个用户 Assert.assertEquals(5, userService.getAllUsers().intValue()); userService.deleteByName(&quot;张三&quot;); // 查数据库，应该有5个用户 Assert.assertEquals(4, userService.getAllUsers().intValue()); &#125;&#125; 其余详细的操作见jdbcTemplateApi"},{"title":"","date":"2018-07-12T07:06:42.971Z","updated":"2018-07-12T07:03:12.050Z","comments":true,"path":"springboot/spring-boot-restful.html","permalink":"http://yoursite.com/springboot/spring-boot-restful.html","excerpt":"","text":"# spring-boot restful与集成测试 @Controller：修饰class，用来创建处理http请求的对象 @RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 @RequestMapping：配置url映射 下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。 RESTful API具体设计如下： 使用Swagger生成api"},{"title":"","date":"2018-07-12T11:12:05.153Z","updated":"2018-07-12T07:03:12.052Z","comments":true,"path":"springboot/spring-data-jpa.html","permalink":"http://yoursite.com/springboot/spring-data-jpa.html","excerpt":"","text":"spring-data-jpa[TOC] 自定义ID的生成策略如何指定id策略在JPA中，我们是通过@id和@GeneratedValue来指定id主键和id策略的，比如： 1234@Id@GeneratedValue(strategy = GenerationType.AUTO)@Column(name = &quot;id&quot;)private String id; 这样也就指定了id和生成id所使用的策略，那么JPA提供了那些策略呢？ JPA提供的4种策略从@GeneratedValue源码里可以看到，strategy属性是由GenerationType指定的，而在GenerationType中定义了四种策略： TABLE：使用一个特定的数据库表格来保存主键。 SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。 IDENTITY：主键由数据库自动生成（主要是自动增长型） AUTO：主键由程序控制(也是默认的,在指定主键时，如果不指定主键生成策略，默认为AUTO) 这些策略也不是所有数据库都支持的，具体情况如下： 策略\\数据库 mysql oracle postgreSQL kingbase TABLE 支持 支持 支持 支持 SEQUENCE 不支持 支持 支持 支持 IDENTITY 支持 不支持 支持 支持 AUTO 支持 支持 支持 支持 在@GeneratedValue 中还有一个generator属性 Hibernate拓展id策略当然，很多时候，这么几种策略并不够用，这里hibernate也拓展了JPA的id策略，我们可以在org.hibernate.id.IdentifierGeneratorFactory中看到，主要提供了这么些策略： native: 对于oracle采用Sequence方式，对于MySQL和SQL Server采用identity(自增主键生成机制)，native就是将主键的生成工作交由数据库完成，hibernate不管(很常用)。 uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大(字符串类型)。 hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key,默认字段为Integer类型，名称是next_hi(比较少用)。 assigned: 在插入数据的时候主键由程序处理(很常用)，这是generator元素没有指定时的默认生成策略。等同于JPA中的AUTO。 identity: 使用SQL Server和MySQL的自增字段，这个方法不能放到Oracle中，Oracle不支持自增字段，要设定sequence(MySQL和SQL Server中很常用)。等同于JPA中的IDENTITY。 select: 使用触发器生成主键(主要用于早期的数据库主键生成机制，少用)。 sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持Sequence的数据库，如Oracle(比较少用)。 increment: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 foreign: 使用另外一个相关联的对象的主键。通常和联合起来使用。 guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 uuid.hex: 看uuid，建议用uuid替换。 sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 。 具体使用就是多了一个@GenericGenerator注解，指定自定义名称以及策略，然后在@GeneratedValue中使用该策略，比如： 1234@Id@GeneratedValue(generator = &quot;comnIdStrategy&quot;)@GenericGenerator(name = &quot;comnIdStrategy&quot;, strategy = &quot;uuid&quot;)private String id; 使用自定义的id策略hibernate 提供一种实现自定义id策略的接口IdentifierGenerator（位于org.hibernate.id中）。因此在生成自定义策略时，我们只需实现一下IdentifierGenerator接口，以及对应的generate方法即可： 12345678public class ExpId implements IdentifierGenerator&#123; ... @Override public Serializable generate(SessionImplementor sessionImplementor, Object o) throws HibernateException &#123; String date = String.valueOf(new Date().getTime()); return &quot;exp&quot; + date+&quot;_&quot;+generateRandom(); &#125;&#125; 然后对对应的实体类的某个字段上面使用该策略即可，@GenericGenerator注解的strategy属性上说了，使用非默认策略的时候，需要使用全类名，即： 12345@Id@GeneratedValue(generator = &quot;expIdStrategy&quot;)@GenericGenerator(name = &quot;expIdStrategy&quot;, strategy = &quot;com.cheryl.learn.idworker.ExpId&quot;)@Column(name = &quot;id&quot;)private String id; 使用测试方法测试，可以看到在数据库中添加的数据的id是使用我们定义策略生成的。| id|address |balance |gender |name |password || ———– | —— | —— | ———- | ——– |———||exp1524189929776_13653 |山西太原| 5000.5| 男 |张三丰 |123456||exp1524189929853_22297 |山西晋中| 2000.1| 男 |李四 |123456|"},{"title":"","date":"2018-07-12T11:12:18.531Z","updated":"2018-07-12T07:03:12.054Z","comments":true,"path":"springboot/springboot-conf.html","permalink":"http://yoursite.com/springboot/springboot-conf.html","excerpt":"","text":"SpringBoot ——属性配置文件 在SpringBoot中，在pom.xml中引入模块化的Starter POMs。其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。 application.porterties文件自定义属性基本使用在Springboot中，我们可能也需要定义一些自己的使用属性。可以在application.properties中使用如下方式 12com.cheryl.name = Cherylcom.cheryl.password = 123456 然后再实体类中，使用@ConfigurationProperties(prefix = “com.cheryl”)把当前前前缀下面的注解引入进来。 1234567@Component@ConfigurationProperties(prefix = &quot;com.cheryl&quot;)public class BlogProperties &#123; private String name; private String password; //此处省略get,set方法 &#125; 然后再控制器中使用 @Autowired把实体类注入到容器中，然后启动程序在浏览器中访问对应的路径即可。 123456789101112@RestController@RequestMapping(&quot;/blogPropertiesController&quot;)public class BlogPropertiesController &#123; @Autowired private BlogProperties blogProperties; @GetMapping(&quot;/info&quot;) public String blogInfo()&#123; return blogProperties.toString(); &#125;&#125; 参数间的引用在application.properties中的各个参数之间也可以直接引用来使用。使用‘${xxx}’的方式来引用定义过自定义属性，如下所示： 12com.cheryl.title = &quot;springboot技术实战&quot;com.cheryl.desc = $&#123;com.cheryl.name&#125;正在学习《$&#123;com.cheryl.title&#125;》 最后该值为Cheryl正在学习《springboot技术实战》 生成随机数在有一些情况中，我们希望一些属性使用随机值而不是一个固定的值，比如密钥等。Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 12345678910# 随机字符串（32位的随机字符串）com.cheryl.value=$&#123;random.value&#125;# 随机intcom.cheryl.number=$&#123;random.int&#125;# 随机longcom.cheryl.bignumber=$&#123;random.long&#125;# 10以内的随机数com.cheryl.test1=$&#123;random.int(10)&#125;# 10-20的随机数com.cheryl.test2=$&#123;random.int[10,20]&#125; 多环境配置我们在开发Spring Boot应用时，通常会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要修改配置文件的话，比较繁琐，而且容易出错。 一般来说多环境的配置使用各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外。 在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-test.properties：测试环境 application-prod.properties：生产环境 至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。 如：spring.profiles.active=test就会加载application-test.properties配置文件内容 下面，以不同环境配置不同的服务端口为例，进行样例实验。 针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties 在这三个文件均都设置不同的server.port属性，如：dev环境设置为82，test环境设置为83，prod环境设置为80 application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置 测试不同配置的加载 执行java -jar xxx.jar，可以观察到服务端口被设置为1111，也就是默认的开发环境（dev） 执行java -jar xxx.jar --spring.profiles.active=test，可以观察到服务端口被设置为2222，也就是测试环境的配置（test） 执行java -jar xxx.jar --spring.profiles.active=prod，可以观察到服务端口被设置为3333，也就是生产环境的配置（prod） 按照上面的实验，可以如下总结多环境的配置思路： application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置 application-{profile}.properties中配置各个环境不同的内容 通过命令行方式去激活不同环境的配置"},{"title":"","date":"2018-07-12T07:06:42.981Z","updated":"2018-07-12T07:03:12.056Z","comments":true,"path":"springboot/springboot-web.html","permalink":"http://yoursite.com/springboot/springboot-web.html","excerpt":"","text":"Spring Boot学习单元测试模拟http请求MockServletContext web参数校验123456789101112131415@GetMapping(&quot;/savePerson&quot;) public String savePerson(@Valid Person person, BindingResult result)&#123; String message = &quot;&quot;; if(result.hasErrors())&#123; //list中需要指定具体的泛型，否则会编译保存，期望为Object类型但实际为ObjectError List&lt;ObjectError&gt; allErrors = result.getAllErrors(); for(ObjectError error : allErrors)&#123; message += error.getDefaultMessage()+&quot;\\n&quot;; &#125; &#125; if(message==&quot;&quot;)&#123; message = &quot;保存成功&quot;; &#125; return message; &#125; 1、xss威胁 过滤器12345678910111213@Componentpublic class MyFilterConfiguration &#123; public FilterRegistrationBean myFilterREgisteration()&#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter());//添加过滤器 ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;(); strings.add(&quot;/*&quot;); //这里必须为string类型的集合 registration.setUrlPatterns(strings);//设置过滤的路劲，/*为所有 return registration; &#125;&#125; 遇到的错误Data truncated for column修改了表的数据类型或者是长度，与表中原有的数据产生冲突，从而引发了错误。 【解决】删除表即可。 统一异常处理们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 当访问一个不存在的URL，或是修改处理内容，直接抛出异常，如： 1234@RequestMapping(&quot;/hello&quot;)public String hello() throws Exception &#123; throw new Exception(&quot;发生错误&quot;);&#125; 此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。 alt=默认的错误页面 统一异常处理虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。 下面我们以之前的Web应用例子为基础（Chapter3-1-2），进行统一异常处理的改造。 创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中 123456789101112131415@ControllerAdviceclass GlobalExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;; @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;, e); mav.addObject(&quot;url&quot;, req.getRequestURL()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; &#125;&#125; 实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;统一异常处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Error Handler&lt;/h1&gt; &lt;div th:text=&quot;$&#123;url&#125;&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;$&#123;exception.message&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动该应用，访问：http://localhost:8080/hello，可以看到如下错误提示页面。 alt=自定义的错误页面 通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。 返回JSON格式在上述例子中，通过@ControllerAdvice统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。 本质上，只需在@ExceptionHandler之后加入@ResponseBody，就能让处理函数return的内容转换为JSON格式。 下面以一个具体示例来实现返回JSON格式的异常处理。 创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据 12345678910111213public class ErrorInfo&lt;T&gt; &#123; public static final Integer OK = 0; public static final Integer ERROR = 100; private Integer code; private String message; private String url; private T data; // 省略getter和setter&#125; 创建一个自定义异常，用来实验捕获该异常，并返回json 1234567public class MyException extends Exception &#123; public MyException(String message) &#123; super(message); &#125; &#125; Controller中增加json映射，抛出MyException异常 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/json&quot;) public String json() throws MyException &#123; throw new MyException(&quot;发生错误2&quot;); &#125;&#125; 为MyException异常创建对应的处理 123456789101112131415@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = MyException.class) @ResponseBody public ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception &#123; ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;(); r.setMessage(e.getMessage()); r.setCode(ErrorInfo.ERROR); r.setData(&quot;Some Data&quot;); r.setUrl(req.getRequestURL().toString()); return r; &#125;&#125; 启动应用，访问：http://localhost:8080/json，可以得到如下返回内容： 123456&#123; code: 100， data: &quot;Some Data&quot;， message: &quot;发生错误2&quot;， url: &quot;http://localhost:8080/json&quot;&#125; 至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考Spring MVC的文档。 常见错误模板配置错误1org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field &apos;timestamp&apos; cannot be found on object of type &apos;java.util.HashMap&apos; - maybe not public? 原因是返回的模板页面 没有找到，所以会使用默认的默认页面，而在这个模板页面中是需要返回一个timestamp的。"},{"title":"","date":"2018-07-12T07:06:42.954Z","updated":"2018-07-12T07:03:11.980Z","comments":true,"path":"images/rtsp/videojs.html","permalink":"http://yoursite.com/images/rtsp/videojs.html","excerpt":"","text":"video标签插件库[TOC] videojs-contrib-hls官网地址 github地址 插件介绍插件说明：https://www.cnblogs.com/tinywan/p/6692098.html 常见错误 1、在播放.m3u8的文件时，浏览器出现了如下的错误，原因是对应的查看的js版本太低了，更换之后就不会出现下面的问题了。"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"java web应用的http请求改成https","text":"java web应用的http请求改成https 本文通过将简单介绍两种将http请求修改为https的方式。 1、通过使用sun公司提供的keytool工具结合tomcat实现 2、使用阿里云的免费证书结合nginx实现。 使用SUN公司的提供的工具配置证书 SUN公司提供了制作证书的工具keytool。 在JDK 1.4以后的版本中都包含了这一工具，它的位置为&lt;JAVA_HOME&gt;\\bin\\keytool.exe。 生成证书 这里只介绍简单的keytool生成证书的方法，如果想要了解更多关于keytool的知识，请参考 keytool用法总结 1.创建证书,在命令行中输入 1keytool -genkeypair -alias &quot;test1&quot; -keyalg &quot;RSA&quot; -keystore &quot;test.keystore&quot; 功能： 创建一个别名为test1的证书条目，该条目存放在名为test.keystore的密钥库中，若test.keystore密钥库不存在则创建。 参数说明： -genkeypair：生成一对非对称密钥; -alias：指定密钥对的别名，该别名是公开的; -keyalg：指定加密算法，本例中的采用通用的RAS加密算法; -keystore:密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个”.keystore”的文件 注意： 1.“名字与姓氏”应该是域名，若输成了姓名，和真正运行的时候域名不符，会出问题; 2.再次输入密码，第一次输入的是密钥库(keystore)的密码，第二次输入的是证书条目的密码 3.这里所说的证书库和密钥库是等同的(个人观点) 2.查看证书库 1keytool -list -keystore test.keystore 功能： 查看名为test.keystore的证书库中的证书条目 3.导出到证书文件 1keytool -export -alias test1 -file test.crt -keystore test.keystore 功能： 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt中 4.导入证书的信息 1keytool -import -keystore test_cacerts -file test.crt 功能： 将证书文件test.crt导入到名为test_cacerts的证书库中， 5.查看证书信息 1keytool -printcert -file &quot;test.crt&quot; 功能：查看证书文件test.crt的信息 执行完上述过程之后，我们会在&lt;JAVA_HOME&gt;\\bin目录下面发现生成了3个文件 修改web程序的web.xml123456789&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; &lt;/security-constraint&gt; url-pattern:可以对系统中访问的路径进行过滤 修改tomcat的conf文件1234567&lt;Connector port=&quot;72&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; keystoreFile=&quot;C:/tomcat/conf/test.keystore&quot; keystorePass=&quot;123456&quot; sslProtocol=&quot;TLS&quot; URIEncoding=&quot;UTF-8&quot;/&gt; keystoreFile：证书文件的位置 keystorePass: 是keystore的密码（你在生成证书的时候，会有的keystore密码和tomcat主密码） 使用阿里云服务器生成免费证书生成证书基于阿里云服务器生成密钥证书，请参考用阿里云的免费 SSL 证书让网站从 HTTP 换成 HTTPS 。一般如果证书申请时填写的信息正确，审核不超过10min，在审核通过之后我们选择对应的web服务器，不同的服务器的配置都不相同，这里我们使用ngnix服务器。（其他的web服务器可以在官文中查看，每种服务器都给出了基本的配置方法。） 阿里云免费证书只能对一个域名生效，如果涉及到二级域名或是其他域名，则需要申请不同的证书。 配置web服务器1、 在Nginx的安装目录的conf下创建cert目录，并且将下载的全部文件拷贝到cert目录中。生成证书时，如果是系统自动生成会自己带有私钥文件，如果是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并对其重命名建议和.pem证书文件的名称保持一致； 2、 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件进行修改(以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整)： 123456789101112131415161718192021222324server &#123; listen 443; server_name abc.test.com; ssl on; root html; index index.html index.htm; ssl_certificate cert/xxx.pem; ssl_certificate_key cert/xxx.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125; location /test&#123; tcp_nodelay on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://www.baidu.com; &#125;&#125; 1、 server_name 为系统监听的访问的服务域名。和阿里云中申请的证书的域名保持一致。 2、ssl_certificate 为证书文件的路径。 3、ssl_certificate_key 为私钥文件的路径。 4、在location中路径结合实际情况进行设置。其中/test则是对https的请求进行了转发操作。如何涉及到二级域名的转发操作，则可以在server下面在增加一个server配置项进行相关的配置。 3、启动 nginx，如果在启动时修改了配置文件则重启nginx即可。 4、通过 https 方式访问您的站点，测试站点证书的安装配置。 使用nginx服务器我们不需要对系统的后台服务器进行其他操作。 其他相关文章1、SSL证书与Https应用部署小结 2、https知识了解","content":"<h1 id=\"java-web应用的http请求改成https\"><a href=\"#java-web应用的http请求改成https\" class=\"headerlink\" title=\"java web应用的http请求改成https\"></a>java web应用的http请求改成https</h1><blockquote>\n<p>本文通过将简单介绍两种将http请求修改为https的方式。</p>\n<p>1、通过使用sun公司提供的keytool工具结合tomcat实现</p>\n<p>2、使用阿里云的免费证书结合nginx实现。</p>\n</blockquote>\n<h2 id=\"使用SUN公司的提供的工具配置证书\"><a href=\"#使用SUN公司的提供的工具配置证书\" class=\"headerlink\" title=\"使用SUN公司的提供的工具配置证书\"></a>使用SUN公司的提供的工具配置证书</h2><blockquote>\n<p>SUN公司提供了制作证书的工具keytool。 在JDK 1.4以后的版本中都包含了这一工具，它的位置为&lt;JAVA_HOME&gt;\\bin\\keytool.exe。</p>\n</blockquote>\n<h3 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h3><blockquote>\n<p>这里只介绍简单的keytool生成证书的方法，如果想要了解更多关于keytool的知识，请参考 <a href=\"http://ln-ydc.iteye.com/blog/1335213\" target=\"_blank\" rel=\"noopener\"> keytool用法总结</a></p>\n</blockquote>\n<p> 1.创建证书,在命令行中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -genkeypair -alias &quot;test1&quot; -keyalg &quot;RSA&quot; -keystore &quot;test.keystore&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/https/1.jpg\" alt=\"avatar\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p> 创建一个别名为test1的证书条目，该条目存放在名为test.keystore的密钥库中，若test.keystore密钥库不存在则创建。</p>\n</blockquote>\n<ul>\n<li>参数说明：</li>\n</ul>\n<blockquote>\n<p>-genkeypair：生成一对非对称密钥;</p>\n<p>-alias：指定密钥对的别名，该别名是公开的;</p>\n<p>-keyalg：指定加密算法，本例中的采用通用的RAS加密算法;</p>\n<p>-keystore:密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个”.keystore”的文件</p>\n</blockquote>\n<ul>\n<li>注意：</li>\n</ul>\n<blockquote>\n<p>1.“名字与姓氏”应该是域名，若输成了姓名，和真正运行的时候域名不符，会出问题;</p>\n<p>2.再次输入密码，第一次输入的是密钥库(keystore)的密码，第二次输入的是证书条目的密码</p>\n<p>3.这里所说的证书库和密钥库是等同的(个人观点)</p>\n</blockquote>\n<p> 2.查看证书库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -keystore test.keystore</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/https/2.jpg\" alt=\"avatar\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p>查看名为test.keystore的证书库中的证书条目</p>\n</blockquote>\n<p> 3.导出到证书文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -export -alias test1 -file test.crt -keystore test.keystore</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/https/3.jpg\" alt=\"avatar\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p> 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt中</p>\n</blockquote>\n<p> 4.导入证书的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -import -keystore test_cacerts -file test.crt</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/images/https/4.jpg\" alt=\"img\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p>将证书文件test.crt导入到名为test_cacerts的证书库中，</p>\n</blockquote>\n<p>5.查看证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file &quot;test.crt&quot;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/images/https/5.jpg\" alt=\"img\"></p>\n<ul>\n<li>功能：查看证书文件test.crt的信息</li>\n</ul>\n<p>执行完上述过程之后，我们会在&lt;JAVA_HOME&gt;\\bin目录下面发现生成了3个文件</p>\n<h3 id=\"修改web程序的web-xml\"><a href=\"#修改web程序的web-xml\" class=\"headerlink\" title=\"修改web程序的web.xml\"></a>修改web程序的web.xml</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;security-constraint&gt; </span><br><span class=\"line\">\t\t   &lt;web-resource-collection&gt; </span><br><span class=\"line\">\t\t\t\t  &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt; </span><br><span class=\"line\">\t\t\t\t  &lt;url-pattern&gt;/*&lt;/url-pattern&gt; </span><br><span class=\"line\">\t\t   &lt;/web-resource-collection&gt;                           </span><br><span class=\"line\">\t\t   &lt;user-data-constraint&gt; </span><br><span class=\"line\">\t\t\t\t  &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; </span><br><span class=\"line\">\t\t   &lt;/user-data-constraint&gt; </span><br><span class=\"line\">\t&lt;/security-constraint&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>url-pattern:可以对系统中访问的路径进行过滤</li>\n</ul>\n<h3 id=\"修改tomcat的conf文件\"><a href=\"#修改tomcat的conf文件\" class=\"headerlink\" title=\"修改tomcat的conf文件\"></a>修改tomcat的conf文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;72&quot; protocol=&quot;HTTP/1.1&quot;    connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">                redirectPort=&quot;8443&quot; </span><br><span class=\"line\">\t\t\t   SSLEnabled=&quot;true&quot;   maxThreads=&quot;150&quot; </span><br><span class=\"line\">\t\t\t   scheme=&quot;https&quot; secure=&quot;true&quot;   clientAuth=&quot;false&quot;</span><br><span class=\"line\">\t\t\t   keystoreFile=&quot;C:/tomcat/conf/test.keystore&quot;   </span><br><span class=\"line\">\t\t\t   keystorePass=&quot;123456&quot; sslProtocol=&quot;TLS&quot;</span><br><span class=\"line\">\t\t\t   URIEncoding=&quot;UTF-8&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>keystoreFile：证书文件的位置</p>\n</li>\n<li><p>keystorePass: 是keystore的密码（你在生成证书的时候，会有的keystore密码和tomcat主密码）</p>\n</li>\n</ul>\n<h2 id=\"使用阿里云服务器生成免费证书\"><a href=\"#使用阿里云服务器生成免费证书\" class=\"headerlink\" title=\"使用阿里云服务器生成免费证书\"></a>使用阿里云服务器生成免费证书</h2><h3 id=\"生成证书-1\"><a href=\"#生成证书-1\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h3><p>基于阿里云服务器生成密钥证书，请参考<a href=\"https://ninghao.net/blog/4449\" target=\"_blank\" rel=\"noopener\">用阿里云的免费 SSL 证书让网站从 HTTP 换成 HTTPS</a> 。一般如果证书申请时填写的信息正确，审核不超过10min，在审核通过之后我们选择对应的web服务器，不同的服务器的配置都不相同，这里我们使用ngnix服务器。（其他的web服务器可以在官文中查看，每种服务器都给出了基本的配置方法。）</p>\n<blockquote>\n<p>阿里云免费证书只能对一个域名生效，如果涉及到二级域名或是其他域名，则需要申请不同的证书。</p>\n</blockquote>\n<h3 id=\"配置web服务器\"><a href=\"#配置web服务器\" class=\"headerlink\" title=\"配置web服务器\"></a>配置web服务器</h3><p>1、 在Nginx的安装目录的conf下创建cert目录，并且将下载的全部文件拷贝到cert目录中。生成证书时，如果是系统自动生成会自己带有私钥文件，如果是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并对其重命名建议和.pem证书文件的名称保持一致；</p>\n<p>2、 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件进行修改(以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name abc.test.com;</span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    root html;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    ssl_certificate   cert/xxx.pem;</span><br><span class=\"line\">    ssl_certificate_key  cert/xxx.key;</span><br><span class=\"line\">    ssl_session_timeout 5m;</span><br><span class=\"line\">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root html;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location /test&#123;</span><br><span class=\"line\">        tcp_nodelay     on;  </span><br><span class=\"line\">        proxy_set_header Host            $host;  </span><br><span class=\"line\">        proxy_set_header X-Real-IP       $remote_addr;  </span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class=\"line\">        proxy_pass http://www.baidu.com;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>1、 server_name 为系统监听的访问的服务域名。和阿里云中申请的证书的域名保持一致。</li>\n<li>2、ssl_certificate 为证书文件的路径。</li>\n<li>3、ssl_certificate_key 为私钥文件的路径。</li>\n<li>4、在location中路径结合实际情况进行设置。其中/test则是对https的请求进行了转发操作。如何涉及到二级域名的转发操作，则可以在server下面在增加一个server配置项进行相关的配置。</li>\n</ul>\n</blockquote>\n<p> 3、启动 nginx，如果在启动时修改了配置文件则重启nginx即可。</p>\n<p> 4、通过 https 方式访问您的站点，测试站点证书的安装配置。</p>\n<blockquote>\n<p> 使用nginx服务器我们不需要对系统的后台服务器进行其他操作。</p>\n</blockquote>\n<h2 id=\"其他相关文章\"><a href=\"#其他相关文章\" class=\"headerlink\" title=\"其他相关文章\"></a>其他相关文章</h2><p>1、<a href=\"https://blog.csdn.net/andy1219111/article/details/22716315\" target=\"_blank\" rel=\"noopener\">SSL证书与Https应用部署小结</a></p>\n<p>2、<a href=\"https://blog.csdn.net/andy1219111/article/details/22716315\" target=\"_blank\" rel=\"noopener\">https知识了解</a></p>\n"},{"title":"实时视屏播放的简单实现","text":"实时视屏播放的简单实现 通过使用nginx搭建一个简单的服务器，使用ffmpeg推送rtmp实时流，利用video标签实现可以在web端和手机端的浏览器中进行直播。 Windows下面搭建基于rtmp的服务器硬件环境操作系统：windows7旗舰版 处 理 器：Intel(R) Core(TM)i5-5200 CPU @2.20GHz 2.20 GHz 系统内存： 8GB 系统类型：64位操作系统 软件环境及配置 下载 nginx 1.7.11.3 Gryphon，然后解压到对应的目录，此处为D:\\Program Files；下载链接-Gryphon.zip 将解压后的目录名:nginx 1.7.11.3 Gryphon改成:nginx-1.7.11.3-Gryphon ​ 下载服务器状态检查程序 stat.xsl 下载地址 将nginx-rtmp-module-master.zip解压后复制到目录:nginx-1.7.11.3-Gryphon中。 保证stat.xls的目录为:nginx-1.7.11.3-Gryphon\\nginx-rtmp-module\\stat.xsl 修改conf\\nginx-win.conf 配置文件。 Nginx可以支持多虚机配置，如果是一个ip或域名多虚机的情况，就是要不同的虚机对应不同的端口服务，而如果是多ip或域名一个虚机的情况，则又不一样。这里的实际情况就是，80分别对应一个http协议的虚机，1935对应一个rtmp协议的虚机。 添加rtmp服务。 1234567891011121314151617181920rtmp &#123; server &#123; listen 1935; chunk_size 4000; application hls&#123; live on ; #启用rtmp直播 #地址为rtmp://[server]:[rtmp_port]/[app]/[stream] hls on ; #启用hls直播 #地址为地址为http://[server]:[http_port]/[app]/[stream].m3u8 hls_path html/hls; #此处hls需手动在html文件夹下面创建，否则程序会报错 hls_fragment 5s; recorder rec &#123; #启用录制 record all manual; #手动控制录制启停 record_suffix _rec.flv; record_path nginx-rtmp-module/tmp/rec/; #录制保存地址 record_unique on; &#125; &#125; &#125;&#125; 配置http server 12345678910111213141516171819202122server &#123; listen 80; # server_name localhost; location /stat &#123; # rtmp_stat all; # rtmp_stat_stylesheet stat.xls; #&#125; #location /stat.xls &#123; # root nginx-rtmp-module/; #&#125; #location /control &#123; # rtmp_control all; #&#125; location /hls &#123; # Serve HLS fragments types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root html; expires -1; &#125; 启动服务器 在nginx.exe所在的文件夹，按住shift+右键，选中在此处打开命令窗口，进入windows的cmd。输入以下命令启动nginx服务： 1nginx.exe -c conf\\nginx-win-.conf . 启动结果 直接在浏览器里输入127.0.0.1就可以进入浏览器的欢迎界面 ubuntu搭建推流服务器Nginx+rtmp 提供rtmp直播源在搭建好基于rtmp的服务器之后，需要提供rtmp直播源。这里我们使用的香港卫视的rtmp直播源。根据nginx.conf中的hls_path配置，下面这个命令会向本地的D:\\Program Files\\nginx-1.7.11.3-Gryphon\\html\\hls下面写入ts片段和m3u8文件。 1ffmpeg -re -analyzeduration 8000 -probesize 200000 -i &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot; -strict -2 -bsf:a aac_adtstoasc -c copy -flvflags aac_seq_header_detect -f flv rtmp://localhost/hls/mystream 注意 1、这里提供rtmp源的机器不一定和nginx在同一台物理主机上，可以是网络上的另一台机器，只要保证它能与nginx所在的主机建立tcp链接即可。（也就是nginx主机需要开启rtmp服务的监听端口，这里是1935，当然你也可以修改为其他的端口。） 2、ffmpeg下载地址 在网页中展示视屏在nginx-1.7.11.3-Gryphon/html目录下面创建一个live.html。 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://vjs.zencdn.net/5.10/video-js.css&quot;&gt;&lt;/head&gt; &lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls autoplay=true&gt; &lt;source src=&quot;hls/mystream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt; &lt;script src=&quot;http://vjs.zencdn.net/5.10/video.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/videojs-contrib-hls/5.14.1/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt; &lt;/script&gt; &lt;script&gt; var player = videojs(&apos;example-video&apos;); player.play(); &lt;/script&gt;&lt;/html&gt; 如果只是用video标签是无法播放.m3u8的视屏文件的，需要引入videojs-contrib-hls.js。videojs-contrib-hls支持一堆HLS功能，详情参考[https://www.cnblogs.com/tinywan/p/6692098.html] web端运行效果 手机端运行效果 手机端如果与web可以在同一个网络环境中，那么输入对应本机ip地址也是可以查看的，并且支持横屏、竖屏的切换。 其他 防火墙打开了1935 tcp端口，rtmp视屏还是不能播放， 可以用下面的命令暂停，systemctl stop firewalld.service [参考博文] 1、使用Nginx-rtmp-module搭建hls直播 2、 海康NVR设备RTSP协议转RTMP协议","content":"<h1 id=\"实时视屏播放的简单实现\"><a href=\"#实时视屏播放的简单实现\" class=\"headerlink\" title=\"实时视屏播放的简单实现\"></a>实时视屏播放的简单实现</h1><blockquote>\n<p>通过使用nginx搭建一个简单的服务器，使用ffmpeg推送rtmp实时流，利用video标签实现可以在web端和手机端的浏览器中进行直播。</p>\n</blockquote>\n<h2 id=\"Windows下面搭建基于rtmp的服务器\"><a href=\"#Windows下面搭建基于rtmp的服务器\" class=\"headerlink\" title=\"Windows下面搭建基于rtmp的服务器\"></a>Windows下面搭建基于rtmp的服务器</h2><h3 id=\"硬件环境\"><a href=\"#硬件环境\" class=\"headerlink\" title=\"硬件环境\"></a>硬件环境</h3><p>操作系统：windows7旗舰版 </p>\n<p>处  理  器：Intel(R) Core(TM)i5-5200 CPU @2.20GHz 2.20 GHz</p>\n<p>系统内存： 8GB</p>\n<p>系统类型：64位操作系统</p>\n<h3 id=\"软件环境及配置\"><a href=\"#软件环境及配置\" class=\"headerlink\" title=\"软件环境及配置\"></a>软件环境及配置</h3><ol>\n<li><p>下载 nginx 1.7.11.3 Gryphon，然后解压到对应的目录，此处为D:\\Program Files；<br><a href=\"http://nginx-win.ecsds.eu/download/nginx%201.7.11.3%20Gryphon.zip\" target=\"_blank\" rel=\"noopener\">下载链接-Gryphon.zip</a></p>\n<blockquote>\n<p>将解压后的目录名:nginx 1.7.11.3 Gryphon改成:nginx-1.7.11.3-Gryphon</p>\n</blockquote>\n<p>​</p>\n</li>\n<li><p>下载服务器状态检查程序 stat.xsl</p>\n<p><a href=\"https://github.com/arut/nginx-rtmp-module/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</li>\n<li><p>将nginx-rtmp-module-master.zip解压后复制到目录:nginx-1.7.11.3-Gryphon中。</p>\n<blockquote>\n<p> 保证stat.xls的目录为:nginx-1.7.11.3-Gryphon\\nginx-rtmp-module\\stat.xsl</p>\n</blockquote>\n</li>\n<li><p>修改conf\\nginx-win.conf 配置文件。</p>\n<p>Nginx可以支持多虚机配置，如果是一个ip或域名多虚机的情况，就是要不同的虚机对应不同的端口服务，而如果是多ip或域名一个虚机的情况，则又不一样。这里的实际情况就是，80分别对应一个http协议的虚机，1935对应一个rtmp协议的虚机。</p>\n<ul>\n<li>添加rtmp服务。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\"> server &#123;</span><br><span class=\"line\">     listen 1935;</span><br><span class=\"line\">     chunk_size 4000;</span><br><span class=\"line\">     application hls&#123;</span><br><span class=\"line\">         live on ; #启用rtmp直播</span><br><span class=\"line\">                   #地址为rtmp://[server]:[rtmp_port]/[app]/[stream]</span><br><span class=\"line\">         hls on ;  #启用hls直播</span><br><span class=\"line\">                   #地址为地址为http://[server]:[http_port]/[app]/[stream].m3u8</span><br><span class=\"line\">         hls_path html/hls; #此处hls需手动在html文件夹下面创建，否则程序会报错</span><br><span class=\"line\">         hls_fragment 5s;</span><br><span class=\"line\">         recorder rec &#123; #启用录制</span><br><span class=\"line\">         \trecord all manual; #手动控制录制启停</span><br><span class=\"line\">         \trecord_suffix _rec.flv;</span><br><span class=\"line\">         \trecord_path nginx-rtmp-module/tmp/rec/; #录制保存地址</span><br><span class=\"line\">         \trecord_unique on;</span><br><span class=\"line\">         &#125; \t\t\t</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置http server</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    # server_name  localhost;</span><br><span class=\"line\">    location /stat &#123;</span><br><span class=\"line\">    #\trtmp_stat all;</span><br><span class=\"line\">    #\trtmp_stat_stylesheet stat.xls;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">    #location /stat.xls &#123;</span><br><span class=\"line\">    #\troot nginx-rtmp-module/;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">    #location /control &#123;</span><br><span class=\"line\">    #\trtmp_control all;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">    location /hls &#123;  </span><br><span class=\"line\">        # Serve HLS fragments  </span><br><span class=\"line\">        types &#123;  </span><br><span class=\"line\">            application/vnd.apple.mpegurl m3u8;  </span><br><span class=\"line\">            video/mp2t ts;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        root html;  </span><br><span class=\"line\">        expires -1;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>启动服务器</li>\n</ol>\n<p>在nginx.exe所在的文件夹，按住shift+右键，选中在此处打开命令窗口，进入windows的cmd。输入以下命令启动nginx服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx.exe -c conf\\nginx-win-.conf</span><br></pre></td></tr></table></figure>\n<p>. 启动结果    </p>\n<p> <img src=\"/images/rtsp/cmd-result.png\" alt=\"avatar\"></p>\n<ol start=\"7\">\n<li>直接在浏览器里输入127.0.0.1就可以进入浏览器的欢迎界面<br><img src=\"/images/rtsp/result.png\" alt=\"avatar\"></li>\n</ol>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/f0bf83ca3ea3\" target=\"_blank\" rel=\"noopener\">ubuntu搭建推流服务器Nginx+rtmp</a></p>\n</blockquote>\n<h2 id=\"提供rtmp直播源\"><a href=\"#提供rtmp直播源\" class=\"headerlink\" title=\"提供rtmp直播源\"></a>提供rtmp直播源</h2><p>在搭建好基于rtmp的服务器之后，需要提供rtmp直播源。这里我们使用的香港卫视的rtmp直播源。根据nginx.conf中的hls_path配置，下面这个命令会向本地的D:\\Program Files\\nginx-1.7.11.3-Gryphon\\html\\hls下面写入ts片段和m3u8文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -analyzeduration 8000 -probesize 200000 -i &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot; -strict -2 -bsf:a aac_adtstoasc -c copy -flvflags aac_seq_header_detect -f flv rtmp://localhost/hls/mystream</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>1、这里提供rtmp源的机器不一定和nginx在同一台物理主机上，可以是网络上的另一台机器，只要保证它能与nginx所在的主机建立tcp链接即可。（也就是nginx主机需要开启rtmp服务的监听端口，这里是1935，当然你也可以修改为其他的端口。）  </p>\n<p>2、<a href=\"https://www.ffmpeg.org/\" target=\"_blank\" rel=\"noopener\">ffmpeg下载地址</a></p>\n</blockquote>\n<h2 id=\"在网页中展示视屏\"><a href=\"#在网页中展示视屏\" class=\"headerlink\" title=\"在网页中展示视屏\"></a>在网页中展示视屏</h2><p>在nginx-1.7.11.3-Gryphon/html目录下面创建一个live.html。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://vjs.zencdn.net/5.10/video-js.css&quot;&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">    &lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls autoplay=true&gt;</span><br><span class=\"line\">        &lt;source src=&quot;hls/mystream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;</span><br><span class=\"line\">    &lt;/video&gt;</span><br><span class=\"line\">    &lt;script src=&quot;http://vjs.zencdn.net/5.10/video.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">   \t&lt;script src=&quot;https://cdn.bootcss.com/videojs-contrib-hls/5.14.1/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">   &lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var player = videojs(&apos;example-video&apos;);</span><br><span class=\"line\">        player.play();</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果只是用video标签是无法播放.m3u8的视屏文件的，需要引入videojs-contrib-hls.js。videojs-contrib-hls支持一堆HLS功能，详情参考[<a href=\"https://www.cnblogs.com/tinywan/p/6692098.html]\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/tinywan/p/6692098.html]</a></p>\n</blockquote>\n<ul>\n<li><p>web端运行效果</p>\n<p><img src=\"/images/rtsp/web.png\" alt=\"avatar\"></p>\n</li>\n<li><p>手机端运行效果</p>\n</li>\n</ul>\n<p>  手机端如果与web可以在同一个网络环境中，那么输入对应本机ip地址也是可以查看的，并且支持横屏、竖屏的切换。</p>\n<p>  <img src=\"/images/rtsp/app1.png\" alt=\"avatar\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>防火墙打开了1935 tcp端口，rtmp视屏还是不能播放，</p>\n<p>可以用下面的命令暂停，<br>systemctl stop firewalld.service</p>\n</li>\n</ul>\n<p>[参考博文]</p>\n<p>1、<a href=\"https://blog.csdn.net/tao_627/article/details/22271559\" target=\"_blank\" rel=\"noopener\"><a href=\"https://blog.csdn.net/tao_627/article/details/22271559\" target=\"_blank\" rel=\"noopener\">使用Nginx-rtmp-module搭建hls直播</a></a></p>\n<p>2、 <a href=\"https://blog.csdn.net/lee353086/article/details/78269590\" target=\"_blank\" rel=\"noopener\">海康NVR设备RTSP协议转RTMP协议</a></p>\n"},{"title":"Tomcat配置定时启动","text":"Tomcat配置定时启动一、设置tomcat定时启动1、首先将tomcat注册为服务 先打开tomcat的bin目录下service.bat文件，修改下面的值，这是sevvice的注册名称和显示名称，一般可使用默认值。 1set SERVICE_NAME=Tomcat-DPlatform-Server``set DISPLAYNAME=Apache Tomcat 8.5 %SERVICE_NAME% ​ 然后修改jvm大小， 搜索到–JvmMs 128 –JvmMx 256 进行修改，因为做成服务启动，启动的时候就不会用到 catalina.bat，也就不会读取里面的jvm设置了。】（可选，可以不设置） 然后运行cmd命令窗口，cd 到tomcat的bin目录下，运行下面的命令 1service.bat install ​ 运行成功过后，会提示服务已经安装成功。如下图所示： 2、制作重启脚本restart.bat，文件内容如下： 123456789101112131415161718192021@echo off echo ***********************************************echo start time %DATE% %TIME% echo ***********************************************echo Start closing the service net stop Tomcat-DPlatform-Serverecho service has been closedecho *** echo start clean up catchingrd /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\work\\Catalina&quot;echo clean up end echo start clean up temp for /f &quot;delims=&quot; %%a in (&apos;dir /ad/b/s D:\\tomcat\\ydkq-tomcat-server\\temp&apos;) do (rd /q /s &quot;%%a&quot;)&gt;nulrem del /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\temp\\*.*&quot; echo clean up end echo Start the start of the service net start Tomcat-DPlatform-Server echo service has been startedecho ***********************************************echo end time %DATE% %TIME% echo *********************************************** 3、配置定时任务 （win7）开始–&gt;附件——&gt;系统工具——&gt;任务计划与程序，然后设置对应的脚本运行时间计划 【注意】 使用net stop / net start 命令的时候需要使用管理员权限也就是任务中的最高权限，否则会提示发生系统错误，拒绝访问。 4、删除服务 如果想要删除服务，也很简单，先把服务停掉，然后在cmd窗口运行下面的命令即可，后面那个Tomcat7是服务名。 sc delete Tomcat7 需要注意的是，需要先把服务停掉，才能一次删除成功，或者删除之后再停止服务，就会发现服务已经删除成功了。 【参考】 http://blog.csdn.net/lovelong8808/article/details/52052423","content":"<h1 id=\"Tomcat配置定时启动\"><a href=\"#Tomcat配置定时启动\" class=\"headerlink\" title=\"Tomcat配置定时启动\"></a>Tomcat配置定时启动</h1><h2 id=\"一、设置tomcat定时启动\"><a href=\"#一、设置tomcat定时启动\" class=\"headerlink\" title=\"一、设置tomcat定时启动\"></a>一、设置tomcat定时启动</h2><p>1、首先将tomcat注册为服务      先打开tomcat的bin目录下service.bat文件，修改下面的值，这是sevvice的注册名称和显示名称，一般可使用默认值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set SERVICE_NAME=Tomcat-DPlatform-Server``set DISPLAYNAME=Apache Tomcat 8.5 %SERVICE_NAME%</span><br></pre></td></tr></table></figure>\n<p>​     然后修改jvm大小， 搜索到–JvmMs 128 –JvmMx 256 进行修改，因为做成服务启动，启动的时候就不会用到 catalina.bat，也就不会读取里面的jvm设置了。】（可选，可以不设置）<br>     然后运行cmd命令窗口，cd 到tomcat的bin目录下，运行下面的命令 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service.bat install</span><br></pre></td></tr></table></figure>\n<p>​       运行成功过后，会提示服务已经安装成功。如下图所示：<br> <img src=\"file:///C:/Users/cheryl/Documents/My Knowledge/temp/3876c524-2e1d-4692-b26e-4642dd15485c/128/index_files/92bc70f4-85a4-4bc5-87db-9fb697dc3d20.png\" alt=\"img\"><br>2、制作重启脚本restart.bat，文件内容如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off </span><br><span class=\"line\">echo ***********************************************</span><br><span class=\"line\">echo start time %DATE% %TIME% </span><br><span class=\"line\">echo ***********************************************</span><br><span class=\"line\">echo Start closing the service </span><br><span class=\"line\">net stop Tomcat-DPlatform-Server</span><br><span class=\"line\">echo service has been closed</span><br><span class=\"line\">echo  *** </span><br><span class=\"line\">echo start clean up catching</span><br><span class=\"line\">rd /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\work\\Catalina&quot;</span><br><span class=\"line\">echo clean up end </span><br><span class=\"line\">echo start clean up temp </span><br><span class=\"line\">for /f &quot;delims=&quot; %%a in (&apos;dir /ad/b/s D:\\tomcat\\ydkq-tomcat-server\\temp&apos;) do (rd /q /s &quot;%%a&quot;)&gt;nul</span><br><span class=\"line\">rem del /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\temp\\*.*&quot;   </span><br><span class=\"line\">echo clean up end </span><br><span class=\"line\">echo Start the start of the service </span><br><span class=\"line\">net start Tomcat-DPlatform-Server </span><br><span class=\"line\">echo service has been started</span><br><span class=\"line\">echo ***********************************************</span><br><span class=\"line\">echo end time %DATE% %TIME% </span><br><span class=\"line\">echo ***********************************************</span><br></pre></td></tr></table></figure>\n<p>3、配置定时任务<br>    （win7）开始–&gt;附件——&gt;系统工具——&gt;任务计划与程序，然后设置对应的脚本运行时间计划   【注意】 使用net stop / net start 命令的时候需要使用管理员权限也就是任务中的最高权限，否则会提示发生系统错误，拒绝访问。</p>\n<p>4、删除服务</p>\n<p> 如果想要删除服务，也很简单，先把服务停掉，然后在cmd窗口运行下面的命令即可，后面那个Tomcat7是服务名。 sc delete Tomcat7</p>\n<p>需要注意的是，需要先把服务停掉，才能一次删除成功，或者删除之后再停止服务，就会发现服务已经删除成功了。</p>\n<p>【参考】 <a href=\"http://blog.csdn.net/lovelong8808/article/details/52052423\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/lovelong8808/article/details/52052423</a></p>\n"},{"title":"使用GitHub+Hexo搭建免费博客","text":"使用GitHub + Hexo 搭建免费博客搭建博客扩展功能评论## 多个分支提交博客 参考链接 Hexo 个性化配置(三) https://blog.csdn.net/tianbo_zhang/article/details/79137355","content":"<h1 id=\"使用GitHub-Hexo-搭建免费博客\"><a href=\"#使用GitHub-Hexo-搭建免费博客\" class=\"headerlink\" title=\"使用GitHub + Hexo 搭建免费博客\"></a>使用GitHub + Hexo 搭建免费博客</h1><h2 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h2><h2 id=\"扩展功能\"><a href=\"#扩展功能\" class=\"headerlink\" title=\"扩展功能\"></a>扩展功能</h2><h3 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h3><p>## </p>\n<h2 id=\"多个分支提交博客\"><a href=\"#多个分支提交博客\" class=\"headerlink\" title=\"多个分支提交博客\"></a>多个分支提交博客</h2><p><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\"></a></p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"https://blog.csdn.net/kunkun5love/article/details/79403176\" target=\"_blank\" rel=\"noopener\">Hexo 个性化配置(三)</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/tianbo_zhang/article/details/79137355\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tianbo_zhang/article/details/79137355</a></p>\n"},{"title":"Stream API","text":"Stream API Java8中有两大最为重要的改变。第一个是 Lambda 表达式 ;另外一 个则是 Stream API(java.util.stream.*) 。Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对 集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。也可以使用 Stream API 来并行执行操作。简而言之， Stream API 供了一种高效且易于使用的处理数据的方式。 一、什么是 Stream流(Stream) 到底是什么呢? 是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。集合讲的是数据，流讲的是计算!注意: Stream自己不会存储元素。 Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。 Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。 二、Stream操作的三个步骤2.1 创建stream 一个数据源（如：集合或数组），获取一个流 2.2 中间操作 一个中间操作链，对数据源的数据进行处理。 2.3 终止操作 一个终止操作，执行中间操作链，并产生结果。 三、创建Stream的四种方式3.1 由Collection创建流Java8 中的 Collection 接口被扩展， 供了两个获取流的方法: default Stream&lt; E&gt; stream() : 返回一个顺序流 default Stream&lt; E&gt; parallelStream() : 返回一个并行流 案例： 123List&lt;Employee&gt; list = new ArrayList&lt;&gt;();Stream&lt;Employee&gt; stream = list.stream();Stream&lt;Employee&gt; parallelStream = list.parallelStream(); 3.2 由数组创建流通过 Arrays中的静态方法 stream() 创建数据源 。static &lt; T&gt; Stream&lt; T&gt; stream(T[] array): 返回一个流 重载形式，能够处理对应基本类型的数组: public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 案例： 12Integer[] num = new Integer[23];Stream&lt;Integer&gt; stream1 = Arrays.stream(num);12 3.3 由值创建流可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流 案例： 1Stream&lt;Integer&gt; stream2 = Stream.of(1, 5, 7); 3.4 由函数创建流可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 迭代：public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f) 生成：public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s) 案例： 123456789// 迭代Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(2);stream3.forEach(System.out::println);System.out.println(&quot;-------------&quot;);// 生成Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(4);stream4.forEach(System.out::println);123456789 执行结果： 123456702-------------0.80093413282642290.33937273167260450.164029418307976570.189839641538307121234567 四、Stream的中间操作多个 中间操作 可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理! 而在终止操作时一次性全部处理，称为“惰性求值”。 4.1 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素。 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去 除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补 案例： 定义一个集合： Employee 重写 hashcode ， equals — 去重时使用 12345678List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, &quot;林青霞&quot;, 28, 9889.99), new Employee(102, &quot;东方不败&quot;, 29, 4329.85), new Employee(103, &quot;周星驰&quot;, 40, 1233.88), new Employee(104, &quot;大圣&quot;, 500, 5000.44), new Employee(105, &quot;张无忌&quot;, 15, 3000.09), new Employee(102, &quot;东方不败&quot;, 29, 4329.85) );12345678 执行操作： 1.内部迭代 - 迭代操作由Stream API 完成操作 12345678910111213@Testpublic void test2() &#123; // 中间操作不会做任何处理 Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;惰性求值&quot;); return e.getAge() &lt; 30; &#125;); System.out.println(&quot;--------------------&quot;); // 终止操作，一次性执行全部功能， 称为 &quot;惰性求值&quot; stream.forEach(System.out::println);&#125;12345678910111213 执行结果： 1234567891011--------------------惰性求值Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;惰性求值Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;惰性求值惰性求值惰性求值Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;惰性求值Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;1234567891011 2.外部迭代 12345678@Testpublic void test3() &#123; Iterator&lt;Employee&gt; iterator = emps.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;12345678 执行结果： 123456Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;123456 3.中间操作 - 截断流 1234567@Testpublic void test4() &#123; emps.stream() .filter(employee -&gt; employee.getAge() &lt; 30) // 过滤年龄小于30的人 .limit(1) // 截取一个 .forEach(System.out::println); &#125;1234567 执行结果： 12Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;12 4.中间操作 - 跳过 12345678@Testpublic void test5() &#123; emps.stream() .filter(employee -&gt; employee.getAge() &lt; 30) .skip(2) .forEach(System.out::println); &#125;12345678 执行结果： 123Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;123 5.中间操作 - 筛选去重 123456@Testpublic void test6() &#123; emps.stream() .distinct() .forEach(System.out::println); &#125;123456 执行结果： 12345Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;12345 4.2 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 案例：1.map操作 1234567891011121314@Testpublic void test7() &#123; List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;java&quot;, &quot;ccc&quot;, &quot;java8&quot;, &quot;hello world&quot;); list.stream() .map((x) -&gt; x.toUpperCase()) .forEach(System.out::println); System.out.println(&quot;-------------&quot;); emps.stream() .map(Employee::getAge) .forEach(System.out::println);&#125;1234567891011121314 执行结果： 123456789101112AAAJAVACCCJAVA8HELLO WORLD-------------2829405001529123456789101112 2.flatMap操作 先定义一个 filterCharacter(String str) 方法： 12345678private static Stream&lt;Character&gt; filterCharacter(String str) &#123; List&lt;Character&gt; characters = new ArrayList&lt;&gt;(); for (Character character : str.toCharArray()) &#123; characters.add(character); &#125; return characters.stream(); &#125;12345678 执行测试代码： 1234567891011121314151617181920@Testpublic void test8() &#123; List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;hello world&quot;); Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream() .map(LambdaStramAPI::filterCharacter); streamStream.forEach((s) -&gt; &#123; s.forEach((c) -&gt; System.out.println(c + &quot;&quot;)); System.out.println(); &#125;); System.out.println(&quot;----------------------&quot;); list.stream() .flatMap(LambdaStramAPI::filterCharacter) .forEach(System.out::println);&#125;1234567891011121314151617181920 执行结果： 12345678910111213141516171819202122232425262728293031aaahelloworld----------------------aaahelloworld12345678910111213141516171819202122232425262728293031 4.3 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 案例： 1234567891011121314@Testpublic void test9() &#123; emps.stream() .map(Employee::getSalary) .sorted() .forEach(System.out::println); System.out.println(&quot;-----------------&quot;); emps.stream() .map(Employee::getAge) .sorted(Integer::compare) .forEach(System.out::println);&#125;1234567891011121314 执行结果： 123456789101112131233.883000.094329.854329.855000.449889.99-----------------152829294050012345678910111213 五、 Stream的终止操作终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如:List、Integer，甚至是 void 。 5.1 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭 代，称为外部迭代。相反，Stream API 使用内部 迭代——它帮你把迭代做了) 案例：1.匹配 123456789101112131415161718@Testpublic void test10() &#123; boolean allMatch = emps.stream() .allMatch((employee -&gt; employee.getName().equals(&quot;林青霞&quot;))); System.out.println(allMatch); System.out.println(&quot;-----------------&quot;); boolean anyMatch = emps.stream() .anyMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;)); System.out.println(anyMatch); System.out.println(&quot;-----------------&quot;); boolean noneMatch = emps.stream() .noneMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;)); System.out.println(noneMatch);&#125;123456789101112131415161718 执行结果： 12345false-----------------true-----------------false12345 2.第一个元素 、 任意一个元素 123456789101112131415 @Testpublic void test12() &#123; Optional&lt;String&gt; first = emps.stream() .map(Employee::getName) .sorted() .findFirst(); // 获取第一个元素 System.out.println(first.get()); System.out.println(&quot;-----------------&quot;); Optional&lt;Employee&gt; findAny = emps.parallelStream() .filter(employee -&gt; employee.getName().equals(&quot;林青霞&quot;)) .findAny(); //任意一个元素 System.out.println(findAny.get());&#125;123456789101112131415 执行结果： 123东方不败-----------------Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;123 3.统计总个数、 最大、 最小值 1234567891011121314151617181920// 注意： 流一旦执行终止操作后， 就不能在重复使用@Testpublic void test13() &#123; Stream&lt;Employee&gt; stream = emps.stream(); long count = stream.count(); System.out.println(count); System.out.println(&quot;-----------------&quot;); Optional&lt;Double&gt; doubleOptional = emps.stream() .map(Employee::getSalary) .max(Double::compare); //最大值 System.out.println(doubleOptional.get()); System.out.println(&quot;-----------------&quot;); Optional&lt;Employee&gt; employeeOptional = emps.stream() .min((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary())); // 最小值 System.out.println(employeeOptional.get());&#125;1234567891011121314151617181920 执行结果： 123456-----------------9889.99-----------------Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;12345 5.2 归约备注:map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。 返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。 返回 Optional&lt; T&gt; 案例：1.求和 12345678@Testpublic void test14() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); &#125;12345678 执行结果： 1551 2.计算次数 12345678910111213141516171819@Testpublic void test15() &#123; Optional&lt;Double&gt; doubleOptional = emps.stream() .map(Employee::getSalary) .reduce(Double::max); System.out.println(doubleOptional); System.out.println(&quot;-----------------&quot;); //查看 东方不败 出现的次数 -- 【此处还有点毛病】 Optional&lt;Integer&gt; sumOptional = emps.stream() .map(Employee::getName) .flatMap(LambdaStramAPI::filterCharacter) .map((c) -&gt; &#123; if (c.equals(&quot;东&quot;)) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sumOptional.get());&#125;12345678910111213141516171819 执行结果： 123Optional[9889.99]-----------------0123 5.3 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的 实现，用于给Stream中元素做汇总的方法 案例：1.收集 123456789101112131415161718192021@Testpublic void test16()&#123; List&lt;String&gt; collect = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); collect.forEach(System.out::println); System.out.println(&quot;-------------------&quot;); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(&quot;-------------------&quot;); HashSet&lt;String&gt; hashSet = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hashSet.forEach(System.out::println);&#125;123456789101112131415161718192021 执行结果： 123456789101112131415161718林青霞东方不败周星驰大圣张无忌东方不败-------------------周星驰林青霞大圣东方不败张无忌-------------------周星驰林青霞大圣东方不败张无忌123456789101112131415161718 2.收集统计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 收集统计 @Test public void test17()&#123; // 统计总个数 Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(&quot;-------------------&quot;); // 求平均值 Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); System.out.println(&quot;-------------------&quot;); // 求和 Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); System.out.println(&quot;-------------------&quot;); //求最大值 Optional&lt;Employee&gt; max = emps.stream() .collect(Collectors.maxBy((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary()))); System.out.println(max.get()); System.out.println(&quot;-------------------&quot;); //求最小值 Optional&lt;Double&gt; min = emps.stream() .map(Employee::getSalary) .collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); System.out.println(&quot;-------------------&quot;); //统计分析 DoubleSummaryStatistics doubleSummaryStatistics = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(doubleSummaryStatistics.getAverage()); System.out.println(&quot;-------------------&quot;); //拼接 String join = emps.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;,&quot;, &quot;--&quot;, &quot;--&quot;)); System.out.println(join); &#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 执行结果： 123456789101112136-------------------4630.683333333333-------------------27784.1-------------------Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;-------------------1233.88-------------------4630.683333333333---------------------林青霞,东方不败,周星驰,大圣,张无忌,东方不败--12345678910111213 3.收集-分组 1234567// 分组@Testpublic void test18()&#123; Map&lt;String, List&lt;Employee&gt;&gt; group = emps.stream() .collect(Collectors.groupingBy(Employee::getName)); System.out.println(group);&#125;1234567 执行结果： 123456789&#123;周星驰=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;], 林青霞=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;], 大圣=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;], 东方不败=[Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;], 张无忌=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;123456789 4.收集-多级分组 1234567891011// 多级分组@Testpublic void test19()&#123; Map&lt;String, Map&lt;String, List&lt;Employee&gt;&gt;&gt; group = emps.stream() .collect(Collectors.groupingBy(Employee::getName, Collectors.groupingBy((e) -&gt; &#123; if (e.getAge() &lt; 30) return &quot;青年&quot;; else if (e.getAge() &lt; 50) return &quot;中年&quot;; else return &quot;老年&quot;; &#125;))); System.out.println(group);&#125;1234567891011 执行结果： 123456789&#123;周星驰=&#123;中年=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;]&#125;, 林青霞=&#123;青年=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;]&#125;, 大圣=&#123;老年=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;]&#125;, 东方不败=&#123;青年=[Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;]&#125;, 张无忌=&#123;青年=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;&#125;123456789 Collector 接口中方法的实现决定了如何对流执行收集操作(如收 集到 List、Set、Map)。但是 Collectors 实用类 供了很多静态 方法，可以方便地创建常见收集器实例，具体方法与实例如下表: 方法 返回类型 作用 toList List 把流中元素收集到List List emps= list.stream().collect(Collectors.toList()); toSet Set 把流中元素收集到Set Set emps= list.stream().collect(Collectors.toSet()); toCollection Collection 把流中元素收集到创建的集合 Collectionemps=list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 long count = list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均 值 doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。 如:平均值 IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 String str= list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional 根据比较器选择最大值 Optionalmax= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional 根据比较器选择最小值 Optional min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型 从一个作为累加器的初始值 开始，利用BinaryOperator与 流中元素逐个结合，从而归 约成单个值 inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结 果转换函数 inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); groupingBy Map&lt;K, List&gt; 根据某属性值对流分组，属 性为K，结果为V Map&lt;Emp.Status, List&gt; map= list.stream() .collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map&lt;Boolean, List&gt; 根据true或false进行分区 Map&lt;Boolean,List&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 相关源码地址：https://github.com/liudongdong0909/java8/tree/master/java8-Lambda/src/com/donggua 以上就是全文的内容，由于水平有限，文章中难免会有错误，希望大家指正。谢谢~ 参考文章JAVA8新特性——StreamAPI","content":"<h1 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h1><blockquote>\n<p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式 ;另外一 个则是 Stream API(java.util.stream.*) 。<br>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对 集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。<br>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。也可以使用 Stream API 来并行执行操作。简而言之， Stream API 供了一种高效且易于使用的处理数据的方式。</p>\n</blockquote>\n<h2 id=\"一、什么是-Stream\"><a href=\"#一、什么是-Stream\" class=\"headerlink\" title=\"一、什么是 Stream\"></a>一、什么是 Stream</h2><p>流(Stream) 到底是什么呢? 是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。集合讲的是数据，流讲的是计算!<br><strong>注意:</strong> </p>\n<ol>\n<li>Stream自己不会存储元素。 </li>\n<li>Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。 </li>\n<li>Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。</li>\n</ol>\n<h2 id=\"二、Stream操作的三个步骤\"><a href=\"#二、Stream操作的三个步骤\" class=\"headerlink\" title=\"二、Stream操作的三个步骤\"></a>二、Stream操作的三个步骤</h2><h3 id=\"2-1-创建stream\"><a href=\"#2-1-创建stream\" class=\"headerlink\" title=\"2.1 创建stream\"></a>2.1 创建stream</h3><blockquote>\n<p>一个数据源（如：集合或数组），获取一个流</p>\n</blockquote>\n<h3 id=\"2-2-中间操作\"><a href=\"#2-2-中间操作\" class=\"headerlink\" title=\"2.2 中间操作\"></a>2.2 中间操作</h3><blockquote>\n<p>一个中间操作链，对数据源的数据进行处理。</p>\n</blockquote>\n<h3 id=\"2-3-终止操作\"><a href=\"#2-3-终止操作\" class=\"headerlink\" title=\"2.3 终止操作\"></a>2.3 终止操作</h3><blockquote>\n<p>一个终止操作，执行中间操作链，并产生结果。</p>\n</blockquote>\n<h2 id=\"三、创建Stream的四种方式\"><a href=\"#三、创建Stream的四种方式\" class=\"headerlink\" title=\"三、创建Stream的四种方式\"></a>三、创建Stream的四种方式</h2><h3 id=\"3-1-由Collection创建流\"><a href=\"#3-1-由Collection创建流\" class=\"headerlink\" title=\"3.1 由Collection创建流\"></a>3.1 由Collection创建流</h3><p>Java8 中的 Collection 接口被扩展， 供了两个获取流的方法: </p>\n<ul>\n<li>default Stream&lt; E&gt; stream() : 返回一个顺序流 </li>\n<li>default Stream&lt; E&gt; parallelStream() : 返回一个并行流</li>\n</ul>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">Stream&lt;Employee&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-由数组创建流\"><a href=\"#3-2-由数组创建流\" class=\"headerlink\" title=\"3.2 由数组创建流\"></a>3.2 由数组创建流</h3><p>通过 Arrays中的静态方法 stream() 创建数据源 。<br>static &lt; T&gt; Stream&lt; T&gt; stream(T[] array): 返回一个流</p>\n<p>重载形式，能够处理对应基本类型的数组: </p>\n<ul>\n<li>public static IntStream stream(int[] array) </li>\n<li>public static LongStream stream(long[] array) </li>\n<li>public static DoubleStream stream(double[] array)</li>\n</ul>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] num = new Integer[23];</span><br><span class=\"line\">Stream&lt;Integer&gt; stream1 = Arrays.stream(num);12</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-由值创建流\"><a href=\"#3-3-由值创建流\" class=\"headerlink\" title=\"3.3 由值创建流\"></a>3.3 由值创建流</h3><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。<br>public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流</p>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; stream2 = Stream.of(1, 5, 7);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-由函数创建流\"><a href=\"#3-4-由函数创建流\" class=\"headerlink\" title=\"3.4 由函数创建流\"></a>3.4 由函数创建流</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 </p>\n<ul>\n<li>迭代：public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f) </li>\n<li>生成：public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s)</li>\n</ul>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 迭代</span><br><span class=\"line\">Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(2);</span><br><span class=\"line\">stream3.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;-------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 生成</span><br><span class=\"line\">Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(4);</span><br><span class=\"line\">stream4.forEach(System.out::println);123456789</span><br></pre></td></tr></table></figure>\n<p><strong>执行结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">2</span><br><span class=\"line\">-------------</span><br><span class=\"line\">0.8009341328264229</span><br><span class=\"line\">0.3393727316726045</span><br><span class=\"line\">0.16402941830797657</span><br><span class=\"line\">0.189839641538307121234567</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、Stream的中间操作\"><a href=\"#四、Stream的中间操作\" class=\"headerlink\" title=\"四、Stream的中间操作\"></a>四、Stream的中间操作</h2><p>多个 中间操作 可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理! 而在终止操作时一次性全部处理，称为“惰性求值”。</p>\n<h3 id=\"4-1-筛选与切片\"><a href=\"#4-1-筛选与切片\" class=\"headerlink\" title=\"4.1 筛选与切片\"></a>4.1 筛选与切片</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter(Predicate p)</td>\n<td>接收 Lambda ， 从流中排除某些元素。</td>\n</tr>\n<tr>\n<td>distinct()</td>\n<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去 除重复元素</td>\n</tr>\n<tr>\n<td>limit(long maxSize)</td>\n<td>截断流，使其元素不超过给定数量</td>\n</tr>\n<tr>\n<td>skip(long n)</td>\n<td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong></p>\n<p>定义一个集合： Employee 重写 hashcode ， equals — 去重时使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class=\"line\">          new Employee(101, &quot;林青霞&quot;, 28, 9889.99),</span><br><span class=\"line\">          new Employee(102, &quot;东方不败&quot;, 29, 4329.85),</span><br><span class=\"line\">          new Employee(103, &quot;周星驰&quot;, 40, 1233.88),</span><br><span class=\"line\">          new Employee(104, &quot;大圣&quot;, 500, 5000.44),</span><br><span class=\"line\">          new Employee(105, &quot;张无忌&quot;, 15, 3000.09),</span><br><span class=\"line\">          new Employee(102, &quot;东方不败&quot;, 29, 4329.85)</span><br><span class=\"line\">  );12345678</span><br></pre></td></tr></table></figure>\n<p><strong>执行操作：</strong></p>\n<p>1.内部迭代 - 迭代操作由Stream API 完成操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test2() &#123;</span><br><span class=\"line\">    // 中间操作不会做任何处理</span><br><span class=\"line\">    Stream&lt;Employee&gt; stream = emps.stream()</span><br><span class=\"line\">            .filter((e) -&gt; &#123;</span><br><span class=\"line\">                System.out.println(&quot;惰性求值&quot;);</span><br><span class=\"line\">                return e.getAge() &lt; 30;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    System.out.println(&quot;--------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 终止操作，一次性执行全部功能， 称为 &quot;惰性求值&quot;</span><br><span class=\"line\">    stream.forEach(System.out::println);</span><br><span class=\"line\">&#125;12345678910111213</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;1234567891011</span><br></pre></td></tr></table></figure>\n<p>2.外部迭代</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test3() &#123;</span><br><span class=\"line\">     Iterator&lt;Employee&gt; iterator = emps.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">     while (iterator.hasNext()) &#123;</span><br><span class=\"line\">         System.out.println(iterator.next());</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;123456</span><br></pre></td></tr></table></figure>\n<p>3.中间操作 - 截断流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test4() &#123;</span><br><span class=\"line\">     emps.stream()</span><br><span class=\"line\">             .filter(employee -&gt; employee.getAge() &lt; 30) // 过滤年龄小于30的人</span><br><span class=\"line\">             .limit(1) // 截取一个</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\"> &#125;1234567</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<p>4.中间操作 - 跳过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test5() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     emps.stream()</span><br><span class=\"line\">             .filter(employee -&gt; employee.getAge() &lt; 30)</span><br><span class=\"line\">             .skip(2)</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\"> &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n<p>5.中间操作 - 筛选去重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test6() &#123;</span><br><span class=\"line\">     emps.stream()</span><br><span class=\"line\">             .distinct()</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\"> &#125;123456</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;12345</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-映射\"><a href=\"#4-2-映射\" class=\"headerlink\" title=\"4.2 映射\"></a>4.2 映射</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>map(Function f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。</td>\n</tr>\n<tr>\n<td>mapToDouble(ToDoubleFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。</td>\n</tr>\n<tr>\n<td>mapToInt(ToIntFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。</td>\n</tr>\n<tr>\n<td>mapToLong(ToLongFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。</td>\n</tr>\n<tr>\n<td>flatMap(Function f)</td>\n<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.map操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test7() &#123;</span><br><span class=\"line\">    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;java&quot;, &quot;ccc&quot;, &quot;java8&quot;, &quot;hello world&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    list.stream()</span><br><span class=\"line\">            .map((x) -&gt; x.toUpperCase())</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    emps.stream()</span><br><span class=\"line\">            .map(Employee::getAge)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;1234567891011121314</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AAA</span><br><span class=\"line\">JAVA</span><br><span class=\"line\">CCC</span><br><span class=\"line\">JAVA8</span><br><span class=\"line\">HELLO WORLD</span><br><span class=\"line\">-------------</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">40</span><br><span class=\"line\">500</span><br><span class=\"line\">15</span><br><span class=\"line\">29123456789101112</span><br></pre></td></tr></table></figure>\n<p>2.flatMap操作</p>\n<p>先定义一个 filterCharacter(String str) 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Stream&lt;Character&gt; filterCharacter(String str) &#123;</span><br><span class=\"line\">        List&lt;Character&gt; characters = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Character character : str.toCharArray()) &#123;</span><br><span class=\"line\">            characters.add(character);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return characters.stream();</span><br><span class=\"line\">    &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test8() &#123;</span><br><span class=\"line\">    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;hello world&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream()</span><br><span class=\"line\">            .map(LambdaStramAPI::filterCharacter);</span><br><span class=\"line\"></span><br><span class=\"line\">    streamStream.forEach((s) -&gt; &#123;</span><br><span class=\"line\">        s.forEach((c) -&gt; System.out.println(c + &quot;&quot;));</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;----------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    list.stream()</span><br><span class=\"line\">            .flatMap(LambdaStramAPI::filterCharacter)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\"></span><br><span class=\"line\">h</span><br><span class=\"line\">e</span><br><span class=\"line\">l</span><br><span class=\"line\">l</span><br><span class=\"line\">o</span><br><span class=\"line\"></span><br><span class=\"line\">w</span><br><span class=\"line\">o</span><br><span class=\"line\">r</span><br><span class=\"line\">l</span><br><span class=\"line\">d</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------</span><br><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\">h</span><br><span class=\"line\">e</span><br><span class=\"line\">l</span><br><span class=\"line\">l</span><br><span class=\"line\">o</span><br><span class=\"line\"></span><br><span class=\"line\">w</span><br><span class=\"line\">o</span><br><span class=\"line\">r</span><br><span class=\"line\">l</span><br><span class=\"line\">d12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-排序\"><a href=\"#4-3-排序\" class=\"headerlink\" title=\"4.3 排序\"></a>4.3 排序</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sorted()</td>\n<td>产生一个新流，其中按自然顺序排序</td>\n</tr>\n<tr>\n<td>sorted(Comparator comp)</td>\n<td>产生一个新流，其中按比较器顺序排序</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test9() &#123;</span><br><span class=\"line\">    emps.stream()</span><br><span class=\"line\">            .map(Employee::getSalary)</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    emps.stream()</span><br><span class=\"line\">            .map(Employee::getAge)</span><br><span class=\"line\">            .sorted(Integer::compare)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;1234567891011121314</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1233.88</span><br><span class=\"line\">3000.09</span><br><span class=\"line\">4329.85</span><br><span class=\"line\">4329.85</span><br><span class=\"line\">5000.44</span><br><span class=\"line\">9889.99</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">15</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">29</span><br><span class=\"line\">40</span><br><span class=\"line\">50012345678910111213</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、-Stream的终止操作\"><a href=\"#五、-Stream的终止操作\" class=\"headerlink\" title=\"五、 Stream的终止操作\"></a>五、 Stream的终止操作</h2><p>终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如:List、Integer，甚至是 void 。</p>\n<h3 id=\"5-1-查找与匹配\"><a href=\"#5-1-查找与匹配\" class=\"headerlink\" title=\"5.1 查找与匹配\"></a>5.1 查找与匹配</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>allMatch(Predicate p)</td>\n<td>检查是否匹配所有元素</td>\n</tr>\n<tr>\n<td>anyMatch(Predicate p)</td>\n<td>检查是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td>noneMatch(Predicate p)</td>\n<td>检查是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td>findFirst()</td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td>findAny()</td>\n<td>返回当前流中的任意元素</td>\n</tr>\n<tr>\n<td>count()</td>\n<td>返回流中元素总数</td>\n</tr>\n<tr>\n<td>max(Comparator c)</td>\n<td>返回流中最大值</td>\n</tr>\n<tr>\n<td>min(Comparator c)</td>\n<td>返回流中最小值</td>\n</tr>\n<tr>\n<td>forEach(Consumer c)</td>\n<td>内部迭代(使用 Collection 接口需要用户去做迭 代，称为外部迭代。相反，Stream API 使用内部 迭代——它帮你把迭代做了)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test10() &#123;</span><br><span class=\"line\">    boolean allMatch = emps.stream()</span><br><span class=\"line\">            .allMatch((employee -&gt; employee.getName().equals(&quot;林青霞&quot;)));</span><br><span class=\"line\">    System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean anyMatch = emps.stream()</span><br><span class=\"line\">            .anyMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;));</span><br><span class=\"line\">    System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean noneMatch = emps.stream()</span><br><span class=\"line\">            .noneMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;));</span><br><span class=\"line\">    System.out.println(noneMatch);</span><br><span class=\"line\">&#125;123456789101112131415161718</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">true</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">false12345</span><br></pre></td></tr></table></figure>\n<p>2.第一个元素 、 任意一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @Test</span><br><span class=\"line\">public void test12() &#123;</span><br><span class=\"line\">    Optional&lt;String&gt; first = emps.stream()</span><br><span class=\"line\">            .map(Employee::getName)</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .findFirst(); // 获取第一个元素</span><br><span class=\"line\">    System.out.println(first.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Optional&lt;Employee&gt; findAny = emps.parallelStream()</span><br><span class=\"line\">            .filter(employee -&gt; employee.getName().equals(&quot;林青霞&quot;))</span><br><span class=\"line\">            .findAny(); //任意一个元素</span><br><span class=\"line\">    System.out.println(findAny.get());</span><br><span class=\"line\">&#125;123456789101112131415</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">东方不败</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;123</span><br></pre></td></tr></table></figure>\n<p>3.统计总个数、 最大、 最小值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注意： 流一旦执行终止操作后， 就不能在重复使用</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void test13() &#123;</span><br><span class=\"line\">    Stream&lt;Employee&gt; stream = emps.stream();</span><br><span class=\"line\">    long count = stream.count();</span><br><span class=\"line\">    System.out.println(count);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Optional&lt;Double&gt; doubleOptional = emps.stream()</span><br><span class=\"line\">            .map(Employee::getSalary)</span><br><span class=\"line\">            .max(Double::compare); //最大值</span><br><span class=\"line\">    System.out.println(doubleOptional.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Optional&lt;Employee&gt; employeeOptional = emps.stream()</span><br><span class=\"line\">            .min((x, y) -&gt; Double.compare(x.getSalary(),  y.getSalary())); // 最小值</span><br><span class=\"line\">    System.out.println(employeeOptional.get());</span><br><span class=\"line\">&#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">9889.99</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;12345</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-归约\"><a href=\"#5-2-归约\" class=\"headerlink\" title=\"5.2 归约\"></a>5.2 归约</h3><p><strong>备注:map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reduce(T iden, BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值。 返回 T</td>\n</tr>\n<tr>\n<td>reduce(BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值。 返回 Optional&lt; T&gt;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.求和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test14() &#123;</span><br><span class=\"line\">     List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class=\"line\"></span><br><span class=\"line\">     Integer sum = list.stream()</span><br><span class=\"line\">             .reduce(0, (x, y) -&gt; x + y);</span><br><span class=\"line\">     System.out.println(sum);</span><br><span class=\"line\"> &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">551</span><br></pre></td></tr></table></figure>\n<p>2.计算次数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test15() &#123;</span><br><span class=\"line\">    Optional&lt;Double&gt; doubleOptional = emps.stream()</span><br><span class=\"line\">            .map(Employee::getSalary)</span><br><span class=\"line\">            .reduce(Double::max);</span><br><span class=\"line\">    System.out.println(doubleOptional);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //查看 东方不败 出现的次数 -- 【此处还有点毛病】</span><br><span class=\"line\">    Optional&lt;Integer&gt; sumOptional = emps.stream()</span><br><span class=\"line\">            .map(Employee::getName)</span><br><span class=\"line\">            .flatMap(LambdaStramAPI::filterCharacter)</span><br><span class=\"line\">            .map((c) -&gt; &#123;</span><br><span class=\"line\">                if (c.equals(&quot;东&quot;)) return 1;</span><br><span class=\"line\">                else return 0;</span><br><span class=\"line\">            &#125;).reduce(Integer::sum);</span><br><span class=\"line\">    System.out.println(sumOptional.get());</span><br><span class=\"line\">&#125;12345678910111213141516171819</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional[9889.99]</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">0123</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-3-收集\"><a href=\"#5-3-收集\" class=\"headerlink\" title=\"5.3 收集\"></a>5.3 收集</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>collect(Collector c)</td>\n<td>将流转换为其他形式。接收一个 Collector接口的 实现，用于给Stream中元素做汇总的方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.收集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test16()&#123;</span><br><span class=\"line\">   List&lt;String&gt; collect = emps.stream()</span><br><span class=\"line\">           .map(Employee::getName)</span><br><span class=\"line\">           .collect(Collectors.toList());</span><br><span class=\"line\">   collect.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   Set&lt;String&gt; set = emps.stream()</span><br><span class=\"line\">           .map(Employee::getName)</span><br><span class=\"line\">           .collect(Collectors.toSet());</span><br><span class=\"line\">   set.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   HashSet&lt;String&gt; hashSet = emps.stream()</span><br><span class=\"line\">           .map(Employee::getName)</span><br><span class=\"line\">           .collect(Collectors.toCollection(HashSet::new));</span><br><span class=\"line\">   hashSet.forEach(System.out::println);</span><br><span class=\"line\">&#125;123456789101112131415161718192021</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">林青霞</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">周星驰</span><br><span class=\"line\">大圣</span><br><span class=\"line\">张无忌</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">周星驰</span><br><span class=\"line\">林青霞</span><br><span class=\"line\">大圣</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">张无忌</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">周星驰</span><br><span class=\"line\">林青霞</span><br><span class=\"line\">大圣</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">张无忌123456789101112131415161718</span><br></pre></td></tr></table></figure>\n<p>2.收集统计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 收集统计</span><br><span class=\"line\"> @Test</span><br><span class=\"line\"> public  void test17()&#123;</span><br><span class=\"line\">     // 统计总个数</span><br><span class=\"line\">     Long count = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.counting());</span><br><span class=\"line\">     System.out.println(count);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     // 求平均值</span><br><span class=\"line\">     Double avg = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class=\"line\">     System.out.println(avg);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     // 求和</span><br><span class=\"line\">     Double sum = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class=\"line\">     System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //求最大值</span><br><span class=\"line\">     Optional&lt;Employee&gt; max = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.maxBy((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary())));</span><br><span class=\"line\">     System.out.println(max.get());</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //求最小值</span><br><span class=\"line\">     Optional&lt;Double&gt; min = emps.stream()</span><br><span class=\"line\">             .map(Employee::getSalary)</span><br><span class=\"line\">             .collect(Collectors.minBy(Double::compare));</span><br><span class=\"line\">     System.out.println(min.get());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //统计分析</span><br><span class=\"line\">     DoubleSummaryStatistics doubleSummaryStatistics = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class=\"line\">     System.out.println(doubleSummaryStatistics.getAverage());</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //拼接</span><br><span class=\"line\">     String join = emps.stream()</span><br><span class=\"line\">             .map(Employee::getName)</span><br><span class=\"line\">             .collect(Collectors.joining(&quot;,&quot;, &quot;--&quot;, &quot;--&quot;));</span><br><span class=\"line\">     System.out.println(join);</span><br><span class=\"line\"> &#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">4630.683333333333</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">27784.1</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">1233.88</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">4630.683333333333</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">--林青霞,东方不败,周星驰,大圣,张无忌,东方不败--12345678910111213</span><br></pre></td></tr></table></figure>\n<p>3.收集-分组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 分组</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public  void test18()&#123;</span><br><span class=\"line\">    Map&lt;String, List&lt;Employee&gt;&gt; group = emps.stream()</span><br><span class=\"line\">            .collect(Collectors.groupingBy(Employee::getName));</span><br><span class=\"line\">    System.out.println(group);</span><br><span class=\"line\">&#125;1234567</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">周星驰=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;], </span><br><span class=\"line\">林青霞=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;], </span><br><span class=\"line\">大圣=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;], </span><br><span class=\"line\">东方不败=[</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, </span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">], </span><br><span class=\"line\">张无忌=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;123456789</span><br></pre></td></tr></table></figure>\n<p>4.收集-多级分组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 多级分组</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void test19()&#123;</span><br><span class=\"line\">    Map&lt;String, Map&lt;String, List&lt;Employee&gt;&gt;&gt; group = emps.stream()</span><br><span class=\"line\">            .collect(Collectors.groupingBy(Employee::getName, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class=\"line\">                if (e.getAge() &lt; 30) return &quot;青年&quot;;</span><br><span class=\"line\">                else if (e.getAge() &lt; 50) return &quot;中年&quot;;</span><br><span class=\"line\">                else return &quot;老年&quot;;</span><br><span class=\"line\">            &#125;)));</span><br><span class=\"line\">    System.out.println(group);</span><br><span class=\"line\">&#125;1234567891011</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;周星驰=&#123;中年=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;]&#125;, </span><br><span class=\"line\">林青霞=&#123;青年=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;]&#125;, </span><br><span class=\"line\">大圣=&#123;老年=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;]&#125;, </span><br><span class=\"line\">东方不败=&#123;青年=[</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, </span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">]&#125;, </span><br><span class=\"line\">张无忌=&#123;青年=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;&#125;</span><br><span class=\"line\">123456789</span><br></pre></td></tr></table></figure>\n<p><strong>Collector 接口中方法的实现决定了如何对流执行收集操作(如收 集到 List、Set、Map)。但是 Collectors 实用类 供了很多静态 方法，可以方便地创建常见收集器实例，具体方法与实例如下表:</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>返回类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>toList</td>\n<td>List<t></t></td>\n<td>把流中元素收集到List</td>\n</tr>\n<tr>\n<td>List<employee> emps= list.stream().collect(Collectors.toList());</employee></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>toSet</td>\n<td>Set<t></t></td>\n<td>把流中元素收集到Set</td>\n</tr>\n<tr>\n<td>Set<employee> emps= list.stream().collect(Collectors.toSet());</employee></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>toCollection</td>\n<td>Collection<t></t></td>\n<td>把流中元素收集到创建的集合</td>\n</tr>\n<tr>\n<td>Collection<employee>emps=list.stream().collect(Collectors.toCollection(ArrayList::new));</employee></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>counting</td>\n<td>Long</td>\n<td>计算流中元素的个数</td>\n</tr>\n<tr>\n<td>long count = list.stream().collect(Collectors.counting());</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>summingInt</td>\n<td>Integer</td>\n<td>对流中元素的整数属性求和</td>\n</tr>\n<tr>\n<td>inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>averagingInt</td>\n<td>Double</td>\n<td>计算流中元素Integer属性的平均 值</td>\n</tr>\n<tr>\n<td>doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>summarizingInt</td>\n<td>IntSummaryStatistics</td>\n<td>收集流中Integer属性的统计值。 如:平均值</td>\n</tr>\n<tr>\n<td>IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>joining</td>\n<td>String</td>\n<td>连接流中每个字符串</td>\n</tr>\n<tr>\n<td>String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>maxBy</td>\n<td>Optional<t></t></td>\n<td>根据比较器选择最大值</td>\n</tr>\n<tr>\n<td>Optional<emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</emp></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>minBy</td>\n<td>Optional<t></t></td>\n<td>根据比较器选择最小值</td>\n</tr>\n<tr>\n<td>Optional<emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</emp></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reducing</td>\n<td>归约产生的类型</td>\n<td>从一个作为累加器的初始值 开始，利用BinaryOperator与 流中元素逐个结合，从而归 约成单个值</td>\n</tr>\n<tr>\n<td>inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>collectingAndThen</td>\n<td>转换函数返回的类型</td>\n<td>包裹另一个收集器，对其结 果转换函数</td>\n</tr>\n<tr>\n<td>inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>groupingBy</td>\n<td>Map&lt;K, List<t>&gt;</t></td>\n<td>根据某属性值对流分组，属 性为K，结果为V</td>\n</tr>\n<tr>\n<td>Map&lt;Emp.Status, List<emp>&gt; map= list.stream() .collect(Collectors.groupingBy(Employee::getStatus));</emp></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>partitioningBy</td>\n<td>Map&lt;Boolean, List<t>&gt;</t></td>\n<td>根据true或false进行分区</td>\n</tr>\n<tr>\n<td>Map&lt;Boolean,List<emp>&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage));</emp></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://github.com/liudongdong0909/java8/tree/master/java8-Lambda/src/com/donggua\" target=\"_blank\" rel=\"noopener\">相关源码地址：https://github.com/liudongdong0909/java8/tree/master/java8-Lambda/src/com/donggua</a></p>\n<p>以上就是全文的内容，由于水平有限，文章中难免会有错误，希望大家指正。谢谢~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://blog.csdn.net/liudongdong0909/article/details/77429875\" target=\"_blank\" rel=\"noopener\">JAVA8新特性——StreamAPI</a></p>\n"},{"title":"快速搭建小程序项目","text":"小程序搭建 开发工具安装微信公众平台提供了winddows64,windows32,mac三个操作系统下的安装包，我们选择合适自己下载即可。（微信开发者工具下载链接） 备注： 小程序的开发工具除了使用官方提供的微信开发者工具之外，还可以使用SublimeText,或者是WebStrom等，然后配合使用微信开发者工具进行调试操作。 快速创建项目在根据提示安装完成之后，我们需要用微信扫描二维码登录微信开发者工具。然后选择小程序项目 然后我们选择小程序存放的位置，填写对应的demo，选择体验小程序，并且勾选建立普通快速启动模板。 这里我们先使用无appId的方式即体验模式，虽然无法进行代码真机预览和上传等操作，部分 API 无法正常调用，但是不影响我们正常的开发。项目创建完如下图所示 关于开发工具再此不做详细说明，详情可以参考小程序开发工具介绍 项目结构介绍小程序文件类型小程序中有且只有以下4中类型的文件： json 后缀的 JSON 配置文件 wxml 后缀的 WXML 模板文件 wxss 后缀的 WXSS 样式文件 js 后缀的 JS 脚本逻辑文件 包结构小程序的默认的包结构如下所示 1234567891011121314151617+- pages +- indexs - index.js - index.json - index.wsml - index.wxss +- logs - logs.js - logs.json - logs.wsml - logs.wxss+- utils - util.jsapp.jsapp.jsonapp.wxssproject.config.json 所有的配置遵循就近原则 包结构说明1.app.json 小程序逻辑（必须） app.json中的App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。 2.app.json 小程序公共设置（必须） app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 3.app.wxss 全局样式文件 在app.wxss中可以定义一些全局属性的样式，这样相同的养生石在单独的页面中就无需在配置了。 4.project.config.json 是工具配置文件。 所有对当前开发工具做的操作都会保存到project.config.json文件中，当我们重新安装工具或者是更换电脑时，只需导入项目的代码即可恢复我们之前对工具的一些设置。 5.pages 小程序模板存放的文件夹 在小程序中所有的模板都在此文件中，并且每一个页面对应中有4个文件 文件类型 必填 作用 js 是 页面逻辑 wxml 是 页面结构 wxss 否 页面样式表 json 否 页面配置 为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 页面中的wxss样式配置如果与app.wxss有相同的，那么采取就近原则，优先使用页面的样式。 小程序的页面是可以嵌套的，对应的可以有二级页面，三级页面等等，但是最多只能支持5级页面，这一点主要是从小程序的性能方面考虑，从而做的限制。 编写简单页面移动端的分辨率与rpx在开始编写页面之前我们首先要了解一下分辨率的概念，因为小程序是移动端的开发，在不同的机型中是需要进行适配的，所以要注意像素的使用。 pt 逻辑分辨率，pt的大小与屏幕尺寸与关系，简单可以理解为长度和视觉单位 px 物理分辨率，与屏幕尺寸没有关系，用于描述一个单位中像素点的多少 reader 设备像素比 一个pt包含多少个px，人类视觉极限为@2x ppi(dpi） 每一寸包含的px 从上述图中可以看出1个pt可以有1个px构成也可以有2个，甚至是3个… 小程序推荐的使用的单位是rpx。他和px之间的关系为 1rpx = 1px 。 唯一的区别就是rpx可以根据屏幕进行适配，而px不可以。 扩展 不是所有的单位都适合rpx当需要的元素大小适应屏幕尺寸，就选择rpx作为单位，否者使用px作为单位。一般来说文字不建议使用rpx；建议margin-top，margint-bottom 使用rpx,因为屏幕是可以进行垂直滚动的，而margin-left，margin-right使用px，当然这个不是绝对的也是根据具体问题具体分析的。 为什么使用ip6的物理分辨率来设计UI?小程序的模拟器采用的是逻辑分辨率。在设计时采用的就是根据iphone6的屏幕来设计的。所以存在:1px = 1rpx=2pt。方便开发，所以在调试时使用iphone6模拟器进行调试。 为什么iphone plus 的设备相素比大于iphone6的，但是图像并没有更清晰呢？从理论上来说同一个单位的包含的物理像素点多，显示的图像会更细腻，更清晰，但是人类的极限的2备的像素比，所以虽然iphone6 plus 的像素比为3备的像素比但是我们视觉上并没有太大的感觉。 创建页面下图是我们将要实现的一个页面。 创建文件首先创建一个空的项目，建立小程序中必须的文件app.json，app.wxss以及pages文件夹,以及。然在pages下面创建welcome文件夹，然后建立对应welcome.wxml,welcome.wxss文件。 创建完之后我们需要把页面注册的小程序中，也就是配置到app.json的pages中。否则是不可以预览这个页面的。 12345&#123; &quot;pages&quot;: [ &quot;pages/welcome/welcome&quot; ]&#125; 小程序中规定，pages下面的第一个页面，默认为显示的第一个页面 创建页面的一个快捷方式就是在直接在 app.json的pages数组中加入“pages/xxx/xxx”。在保存之后会在pages生成对应的xxx文件下面生成xxx.wxml、xxx.wxss、xxx.js以及xxx.json。 编写welcome.wxml小程序中有一个基本的视图容器view,类似于html里面的div,用来分割页面中的不同部分。文字可以直接写也可使用text标签包围。 1234567&lt;view class=&apos;container&apos;&gt; &lt;image class=&quot;welcome-avatar&quot; src=&apos;/images/welcome.jpg&apos;&gt;&lt;/image&gt; &lt;text class=&quot;welcome-title&quot;&gt;Cheryl Demo&lt;/text&gt; &lt;view class=&apos;moto-container&apos;&gt; &lt;text class=&apos;moto&apos;&gt;开启小程序之旅 &lt;/text&gt; &lt;/view&gt;&lt;/view&gt; text标签的相关Tips 使用text包围的文字可以添加自定义样式，也可在手机中可以长按选中。 可以识别转移字符,例如\\n识别为换行 各个操作系统的空格标准并不一致。 组件内只支持 嵌套。 在编写完页面之后，编写对应的wxss文件。 1234567891011121314151617181920212223242526272829303132333435363738/* pages/welcome/welcome.wxss */.container&#123; display:flex;/变成弹性模型/ flex-direction: column;/垂直布局/ align-items: center;/* 居中对齐 */&#125;.welcome-avatar&#123; width: 200rpx; height: 200rpx; margin-top: 160rpx; /*图片显示成圆形 */ border-radius: 500px; &#125;.welcome-title&#123; font-size: 22px; font-weight: bold; margin-top: 40rpx; color: gray;&#125;.moto-container&#123; border: 1px solid #FF99FF; border-radius: 5px; margin-top: 60rpx; background-color: #FF99FF;&#125;.moto&#123; font-size: 20px; color: #ffffff; padding: 20px;&#125;page&#123; background-color: #FFCCFF;&#125; 在小程序中不需要引入 wxss,因为app.json的pages中注册页面的时候无需指明具体的文件，所以pages可以自动的把welcome中4中不同类型的文件关联在一起。 在wxml中样式可以使用class也可以使用style设置，建议静态样式放在wxss中有class指明，动态样式放在style。 可能遇到的问题在设置页面背景色的时候，如果我们在.container{}中设定了 background-color,那么会出现如下的结果 [解决方法] 指定height:1334rpx;但是如果换在其他模拟器中还是会出现上述问题。 指定height:100% 也无法实现预期的效果，原因的container中是有元素扩充起来的。 注意小程序默认在我们编写的骨架外面包裹了一个page标签，可以通过这个标签来设置整屏的颜色。","content":"<h1 id=\"小程序搭建\"><a href=\"#小程序搭建\" class=\"headerlink\" title=\"小程序搭建\"></a>小程序搭建</h1><hr>\n<h2 id=\"开发工具安装\"><a href=\"#开发工具安装\" class=\"headerlink\" title=\"开发工具安装\"></a>开发工具安装</h2><p>微信公众平台提供了winddows64,windows32,mac三个操作系统下的安装包，我们选择合适自己下载即可。（<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\" target=\"_blank\" rel=\"noopener\">微信开发者工具下载链接</a>）</p>\n<blockquote>\n<p>备注： 小程序的开发工具除了使用官方提供的微信开发者工具之外，还可以使用SublimeText,或者是WebStrom等，然后配合使用微信开发者工具进行调试操作。</p>\n</blockquote>\n<h2 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h2><p>在根据提示安装完成之后，我们需要用微信扫描二维码登录微信开发者工具。然后选择小程序项目</p>\n<p><img src=\"/images/miniprogram/choose.png\" alt=\"avatar\"></p>\n<p>然后我们选择小程序存放的位置，填写对应的demo，选择体验小程序，并且勾选建立普通快速启动模板。</p>\n<p><img src=\"/images/miniprogram/newDemo.png\" alt=\"avatar\"></p>\n<p>这里我们先使用无appId的方式即体验模式，虽然无法进行代码真机预览和上传等操作，部分 API 无法正常调用，但是不影响我们正常的开发。项目创建完如下图所示</p>\n<p><img src=\"/images/miniprogram/demo-detail.png\" alt=\"avatar\"></p>\n<blockquote>\n<p>关于开发工具再此不做详细说明，详情可以参考<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/page.html#%E5%90%AF%E5%8A%A8%E9%A1%B5\" target=\"_blank\" rel=\"noopener\">小程序开发工具介绍</a></p>\n</blockquote>\n<h2 id=\"项目结构介绍\"><a href=\"#项目结构介绍\" class=\"headerlink\" title=\"项目结构介绍\"></a>项目结构介绍</h2><h3 id=\"小程序文件类型\"><a href=\"#小程序文件类型\" class=\"headerlink\" title=\"小程序文件类型\"></a>小程序文件类型</h3><p>小程序中有且只有以下4中类型的文件：</p>\n<ul>\n<li>json 后缀的 JSON 配置文件</li>\n<li>wxml 后缀的 WXML 模板文件</li>\n<li>wxss 后缀的 WXSS 样式文件</li>\n<li>js 后缀的 JS 脚本逻辑文件</li>\n</ul>\n<h3 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h3><p>小程序的默认的包结构如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+- pages</span><br><span class=\"line\">\t+- indexs</span><br><span class=\"line\">\t\t- index.js</span><br><span class=\"line\">\t\t- index.json</span><br><span class=\"line\">\t\t- index.wsml</span><br><span class=\"line\">\t\t- index.wxss</span><br><span class=\"line\">\t+- logs</span><br><span class=\"line\">\t\t- logs.js</span><br><span class=\"line\">\t\t- logs.json</span><br><span class=\"line\">\t\t- logs.wsml</span><br><span class=\"line\">\t\t- logs.wxss</span><br><span class=\"line\">+- utils</span><br><span class=\"line\">\t- util.js</span><br><span class=\"line\">app.js</span><br><span class=\"line\">app.json</span><br><span class=\"line\">app.wxss</span><br><span class=\"line\">project.config.json</span><br></pre></td></tr></table></figure>\n<p>所有的配置遵循就近原则</p>\n<h3 id=\"包结构说明\"><a href=\"#包结构说明\" class=\"headerlink\" title=\"包结构说明\"></a>包结构说明</h3><p>1.app.json 小程序逻辑（必须）</p>\n<blockquote>\n<p>app.json中的App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。</p>\n</blockquote>\n<p>2.app.json 小程序公共设置（必须）</p>\n<blockquote>\n<p>app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>\n</blockquote>\n<p>3.app.wxss 全局样式文件 </p>\n<blockquote>\n<p>在app.wxss中可以定义一些全局属性的样式，这样相同的养生石在单独的页面中就无需在配置了。</p>\n</blockquote>\n<p>4.project.config.json 是工具配置文件。</p>\n<blockquote>\n<p>所有对当前开发工具做的操作都会保存到project.config.json文件中，当我们重新安装工具或者是更换电脑时，只需导入项目的代码即可恢复我们之前对工具的一些设置。</p>\n</blockquote>\n<p>5.pages 小程序模板存放的文件夹</p>\n<blockquote>\n<p>在小程序中所有的模板都在此文件中，并且每一个页面对应中有4个文件</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>必填</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>js</td>\n<td>是</td>\n<td>页面逻辑</td>\n</tr>\n<tr>\n<td>wxml</td>\n<td>是</td>\n<td>页面结构</td>\n</tr>\n<tr>\n<td>wxss</td>\n<td>否</td>\n<td>页面样式表</td>\n</tr>\n<tr>\n<td>json</td>\n<td>否</td>\n<td>页面配置</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ul>\n<li>为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。  </li>\n<li>页面中的wxss样式配置如果与app.wxss有相同的，那么采取就近原则，优先使用页面的样式。 </li>\n<li>小程序的页面是可以嵌套的，对应的可以有二级页面，三级页面等等，但是最多只能支持5级页面，这一点主要是从小程序的性能方面考虑，从而做的限制。  </li>\n</ul>\n</blockquote>\n<h1 id=\"编写简单页面\"><a href=\"#编写简单页面\" class=\"headerlink\" title=\"编写简单页面\"></a>编写简单页面</h1><h2 id=\"移动端的分辨率与rpx\"><a href=\"#移动端的分辨率与rpx\" class=\"headerlink\" title=\"移动端的分辨率与rpx\"></a>移动端的分辨率与rpx</h2><p>在开始编写页面之前我们首先要了解一下分辨率的概念，因为小程序是移动端的开发，在不同的机型中是需要进行适配的，所以要注意像素的使用。</p>\n<p><img src=\"/images/miniprogram/resolution.png\" alt=\"avatar\"></p>\n<ul>\n<li>pt  逻辑分辨率，pt的大小与屏幕尺寸与关系，简单可以理解为长度和视觉单位</li>\n<li>px  物理分辨率，与屏幕尺寸没有关系，用于描述一个单位中像素点的多少</li>\n<li>reader 设备像素比 一个pt包含多少个px，人类视觉极限为@2x</li>\n<li>ppi(dpi） 每一寸包含的px</li>\n</ul>\n<p>从上述图中可以看出1个pt可以有1个px构成也可以有2个，甚至是3个…</p>\n<p>小程序推荐的使用的单位是rpx。他和px之间的关系为 1rpx = 1px 。 唯一的区别就是rpx可以根据屏幕进行适配，而px不可以。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><ul>\n<li>不是所有的单位都适合rpx<br>当需要的元素大小适应屏幕尺寸，就选择rpx作为单位，否者使用px作为单位。一般来说文字不建议使用rpx；建议margin-top，margint-bottom 使用rpx,因为屏幕是可以进行垂直滚动的，而margin-left，margin-right使用px，当然这个不是绝对的也是根据具体问题具体分析的。</li>\n<li>为什么使用ip6的物理分辨率来设计UI?<br>小程序的模拟器采用的是逻辑分辨率。在设计时采用的就是根据iphone6的屏幕来设计的。所以存在:1px = 1rpx=2pt。方便开发，所以在调试时使用iphone6模拟器进行调试。</li>\n<li>为什么iphone plus 的设备相素比大于iphone6的，但是图像并没有更清晰呢？<br>从理论上来说同一个单位的包含的物理像素点多，显示的图像会更细腻，更清晰，但是人类的极限的2备的像素比，所以虽然iphone6 plus 的像素比为3备的像素比但是我们视觉上并没有太大的感觉。</li>\n</ul>\n<h2 id=\"创建页面\"><a href=\"#创建页面\" class=\"headerlink\" title=\"创建页面\"></a>创建页面</h2><p>下图是我们将要实现的一个页面。<br><img src=\"/images/miniprogram/welcome.png\" alt=\"avatar\"></p>\n<h3 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h3><p>首先创建一个空的项目，建立小程序中必须的文件app.json，app.wxss以及pages文件夹,以及。然在pages下面创建welcome文件夹，然后建立对应welcome.wxml,welcome.wxss文件。</p>\n<p><img src=\"/images/miniprogram/2-package.png\" alt=\"avatar\"></p>\n<p>创建完之后我们需要把页面注册的小程序中，也就是配置到app.json的pages中。否则是不可以预览这个页面的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;pages&quot;: [</span><br><span class=\"line\">    &quot;pages/welcome/welcome&quot;   </span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>小程序中规定，pages下面的第一个页面，默认为显示的第一个页面  </li>\n<li>创建页面的一个快捷方式就是在直接在 app.json的pages数组中加入“pages/xxx/xxx”。在保存之后会在pages生成对应的xxx文件下面生成xxx.wxml、xxx.wxss、xxx.js以及xxx.json。</li>\n</ul>\n</blockquote>\n<h3 id=\"编写welcome-wxml\"><a href=\"#编写welcome-wxml\" class=\"headerlink\" title=\"编写welcome.wxml\"></a>编写welcome.wxml</h3><p>小程序中有一个基本的视图容器view,类似于html里面的div,用来分割页面中的不同部分。文字可以直接写也可使用text标签包围。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view class=&apos;container&apos;&gt;</span><br><span class=\"line\">  &lt;image class=&quot;welcome-avatar&quot; src=&apos;/images/welcome.jpg&apos;&gt;&lt;/image&gt;</span><br><span class=\"line\">  &lt;text class=&quot;welcome-title&quot;&gt;Cheryl  Demo&lt;/text&gt;</span><br><span class=\"line\">  &lt;view class=&apos;moto-container&apos;&gt;</span><br><span class=\"line\">    &lt;text class=&apos;moto&apos;&gt;开启小程序之旅 &lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>text标签的相关Tips  </li>\n</ul>\n<blockquote>\n<ul>\n<li>使用text包围的文字可以添加自定义样式，也可在手机中可以长按选中。</li>\n<li>可以识别转移字符,例如\\n识别为换行   </li>\n<li>各个操作系统的空格标准并不一致。  </li>\n<li><text> 组件内只支持 <text> 嵌套。  </text></text></li>\n</ul>\n</blockquote>\n<p>在编写完页面之后，编写对应的wxss文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* pages/welcome/welcome.wxss */</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display:flex;/变成弹性模型/</span><br><span class=\"line\">  flex-direction: column;/垂直布局/</span><br><span class=\"line\">  align-items: center;/* 居中对齐 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.welcome-avatar&#123;</span><br><span class=\"line\">  width: 200rpx;</span><br><span class=\"line\">  height: 200rpx;</span><br><span class=\"line\">  margin-top: 160rpx;</span><br><span class=\"line\">  /*图片显示成圆形  */</span><br><span class=\"line\">  border-radius: 500px; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.welcome-title&#123;</span><br><span class=\"line\">  font-size: 22px;</span><br><span class=\"line\">  font-weight: bold; </span><br><span class=\"line\">  margin-top: 40rpx;</span><br><span class=\"line\">  color:  gray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.moto-container&#123;</span><br><span class=\"line\">  border: 1px solid #FF99FF;</span><br><span class=\"line\">  border-radius: 5px;</span><br><span class=\"line\">  margin-top: 60rpx;</span><br><span class=\"line\">  background-color: #FF99FF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.moto&#123;</span><br><span class=\"line\">  font-size: 20px;</span><br><span class=\"line\">  color: #ffffff;</span><br><span class=\"line\">  padding: 20px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">page&#123;</span><br><span class=\"line\">  background-color: #FFCCFF;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在小程序中不需要引入 wxss,因为app.json的pages中注册页面的时候无需指明具体的文件，所以pages可以自动的把welcome中4中不同类型的文件关联在一起。</p>\n<blockquote>\n<p>在wxml中样式可以使用class也可以使用style设置，建议静态样式放在wxss中有class指明，动态样式放在style。</p>\n</blockquote>\n<ul>\n<li>可能遇到的问题<br>在设置页面背景色的时候，如果我们在.container{}中设定了 background-color,那么会出现如下的结果<br><img src=\"F:/hexo/source/_posts/minipogram/images/miniprogram/2-error.png\" alt=\"avatar\"></li>\n</ul>\n<p>[解决方法]  </p>\n<ul>\n<li>指定height:1334rpx;但是如果换在其他模拟器中还是会出现上述问题。  </li>\n<li>指定height:100% 也无法实现预期的效果，原因的container中是有元素扩充起来的。  </li>\n<li>注意小程序默认在我们编写的骨架外面包裹了一个page标签，可以通过这个标签来设置整屏的颜色。</li>\n</ul>\n"},{"title":"计算两个经纬度之间的距离","text":"计算两个经纬度之间的距离本文使用的是距离公式是有google地图提供的。 公式说明 对上面的公式解释如下：1.Lat1 Lng1 表示A点经纬度，Lat2 Lng2 表示B点经纬度；2.a=Lat1 – Lat2 为两点纬度之差 b=Lng1 -Lng2 为两点经度之差；3.6378.137为地球半径，单位为千米；计算出来的结果单位为千米，若将半径改为米为单位则计算的结果单位为米。计算精度与谷歌地图的距离精度差不多，相差范围在0.2米以下。 代码示例123456789101112131415161718192021222324252627private static final double EARTH_RADIUS = 6378.137;// 地球半径,单位千米//将角度换算成弧度private static double rad(double d) &#123; return d * Math.PI / 180.0;&#125;/*** 用来比较是否在规定考勤范围* @param lat1第一个纬度* @param lng1第一个经度* @param lat2第二个纬度* @param lng2第二个经度* @return 两个经纬度的距离（km）*/public static double getDistance(double lat1, double lng1, double lat2,double lng2) &#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2); double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; //此处加上double类型转换是因为对于在几百的距离差值之前计算为0，无法达到预期效果 s = (double)Math.round(s * 10000) / 10000; s = s * 10000/ 10000; return s;&#125; 顺带提一下百度地图提供的计算两地经纬度的方法，很简单的一句话调用，可以自行去看百度地图API试试，计算结果单位：米 123var map = new BMap.Map(&quot;allmap&quot;);var pointA = new BMap.Point(106.486654,29.490295); // 点坐标Avar pointB = new BMap.Point(106.581515,29.615467); // 点坐标B 参考文章 地理空间距离计算及优化 根据两点经纬度计算距离","content":"<h1 id=\"计算两个经纬度之间的距离\"><a href=\"#计算两个经纬度之间的距离\" class=\"headerlink\" title=\"计算两个经纬度之间的距离\"></a>计算两个经纬度之间的距离</h1><p>本文使用的是距离公式是有google地图提供的。</p>\n<h3 id=\"公式说明\"><a href=\"#公式说明\" class=\"headerlink\" title=\"公式说明\"></a>公式说明</h3><p> <img src=\"http://img849.ph.126.net/GNSrkddcKlz3MbknMDS1zA==/2693715527121896352.bmp\" alt=\"关于经纬度求距离 - cza55007 - NO.1.LY\"></p>\n<p>对上面的公式解释如下：<br>1.Lat1 Lng1 表示A点经纬度，Lat2 Lng2 表示B点经纬度；<br>2.a=Lat1 – Lat2 为两点纬度之差  b=Lng1 -Lng2 为两点经度之差；<br>3.6378.137为地球半径，单位为千米；<br>计算出来的结果单位为千米，若将半径改为米为单位则计算的结果单位为米。<br>计算精度与谷歌地图的距离精度差不多，相差范围在0.2米以下。</p>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final double EARTH_RADIUS = 6378.137;// 地球半径,单位千米</span><br><span class=\"line\">//将角度换算成弧度</span><br><span class=\"line\">private static double rad(double d) &#123;</span><br><span class=\"line\">\treturn d * Math.PI / 180.0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\">* 用来比较是否在规定考勤范围</span><br><span class=\"line\">* @param lat1第一个纬度</span><br><span class=\"line\">* @param lng1第一个经度</span><br><span class=\"line\">* @param lat2第二个纬度</span><br><span class=\"line\">* @param lng2第二个经度</span><br><span class=\"line\">* @return 两个经纬度的距离（km）</span><br><span class=\"line\">*/</span><br><span class=\"line\">public static double getDistance(double lat1, double lng1, double lat2,double lng2) &#123;</span><br><span class=\"line\">    double radLat1 = rad(lat1);</span><br><span class=\"line\">    double radLat2 = rad(lat2);</span><br><span class=\"line\">    double a = radLat1 - radLat2;</span><br><span class=\"line\">    double b = rad(lng1) - rad(lng2);</span><br><span class=\"line\">    double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2)</span><br><span class=\"line\">    + Math.cos(radLat1) * Math.cos(radLat2)</span><br><span class=\"line\">    * Math.pow(Math.sin(b / 2), 2)));</span><br><span class=\"line\">    s = s * EARTH_RADIUS;</span><br><span class=\"line\">    //此处加上double类型转换是因为对于在几百的距离差值之前计算为0，无法达到预期效果</span><br><span class=\"line\">    s = (double)Math.round(s * 10000) / 10000;</span><br><span class=\"line\">    s = s * 10000/ 10000;</span><br><span class=\"line\">    return s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顺带提一下百度地图提供的计算两地经纬度的方法，很简单的一句话调用，可以自行去看百度地图API试试，计算结果单位：米</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var map = new BMap.Map(&quot;allmap&quot;);</span><br><span class=\"line\">var pointA = new BMap.Point(106.486654,29.490295);  // 点坐标A</span><br><span class=\"line\">var pointB = new BMap.Point(106.581515,29.615467);  // 点坐标B</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011001084/article/details/52980834\" target=\"_blank\" rel=\"noopener\">地理空间距离计算及优化</a></li>\n<li><a href=\"https://blog.csdn.net/b_h_l/article/details/8657040\" target=\"_blank\" rel=\"noopener\">根据两点经纬度计算距离</a></li>\n</ul>\n"}]}