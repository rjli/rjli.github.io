{"pages":[{"title":"","date":"2018-07-12T07:06:42.844Z","updated":"2018-07-12T07:03:11.873Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"","date":"2018-07-12T07:06:42.860Z","updated":"2018-07-12T07:03:11.989Z","comments":true,"path":"images/流媒体.html","permalink":"http://yoursite.com/images/流媒体.html","excerpt":"","text":"流媒体 流媒体（Streaming media）是指将一连串的媒体数据压缩后，经过网络分段发送数据，在网络上即时传输影音以供观赏的一种技术与过程，此技术使得数据包得以像流水一样发送；如果不使用此技术，就必须在使用前下载整个媒体文件。 流媒体协议介绍常见的流媒体协议有很多比如: RTP(Real-time Transport Protocol), 常用语电话会议, 网络电话等场景, 但是缺点是不提供网络保障 RTCP(Real-time Transport Control Protocol), 是实时传输协议（RTP）的一个姐妹协议, 也常用于语电话会议, 网络电话等场景. RTMP(Real Time Streaming Protocol), RTMP是Adobe开发的协议 HLS(HTTP Live Streaming)是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播 RTMPReal Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和HLS一样都可以应用于视频直播，区别是RTMP基于flash无法在ios的浏览器里播放，但是实时性比HLS要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。 RTSP协议（ 实时流协议)是一种基于文本的应用层协议，在语法及一些消息参数等方面，RTSP协议与HTTP协议类似。 RTSP 以客户服务器方式工作，它是一个多媒体播放控制协议，用来使用户在播放从因特网下载的实时数据时能够进行控制，如：暂停/继续、后退、前进等。因此 RTSP 又称为“因特网录像机遥控协议”。 要实现 RTSP 的控制功能，不仅要有协议，而且要有专门的媒体播放器(media player)和媒体服务器(media server)。媒体服务器与媒体播放器的关系是服务器与客户的关系。 HLS备注用于视频录制和直播: OBS [http://www.obsapp.net/#] ffmpeg vlc 【相关文章】 1.H5在线直播"},{"title":"","date":"2018-07-12T11:46:50.990Z","updated":"2018-07-12T07:03:11.991Z","comments":true,"path":"images/海康摄像头获取rtsp.html","permalink":"http://yoursite.com/images/海康摄像头获取rtsp.html","excerpt":"","text":"海康视屏获取rtsp1、登录企业视屏管理平台，系统登录界面如下所示： 企 业 名 称：虹桥药用访 问 地 址：http://www.hik-online.com/rchongqiao用户名/密码：admin/hbj3022810 2.登录成功之后的在配置中查找都赢的RTSP对应的端口号，此处为外网端口为2554。 3.查看视频编码设置,此处的视频采用H.264编码实现。 4.登录9800平台，查看对应的摄像头的通道信息（可省略） 访问地址：10.1.12.3:8090 用户名/密码： admin /Rchb2016 5.查看设备型号（可省略） 6.查看系统对应的摄像头的通道号：（可省略） 7.得到rtsp地址 URL规定： 1rtsp://username:password@&lt;ipaddress&gt;/&lt;videotype&gt;/ch&lt;number&gt;/&lt;streamtype&gt; 注： 1.VLC可以支持解析URL里的用户名密码，实际发给设备的RTSP请求不支持带用户名密码。 2.videotype:视屏编码格式[h6264/mpeg4] 3.ch 通道号 （ch33:IP通道1，ch34：IP通道2…/ ch1:模拟通道1, ch2:模拟通道2…） 4.streamtype:码流类型[主码流（main/av_stream） 子码流（sub/av_stream）] 我们的rtsp取流地址为： 1rtsp://admin:hbj3022810@171.121.218.169:2554/h264/ch33/main/av_stream 8、测试 使用vlc播放器在添加网络流地址中输入上述地址即可播放。 [相关文章] 最新海康摄像机、NVR、流媒体服务器、回放取流RTSP地址规则说明 海康大华RTSP取流URL格式"},{"title":"","date":"2018-07-12T07:06:42.867Z","updated":"2018-07-12T07:03:11.993Z","comments":true,"path":"images/海康视屏的rtsp实时播放.html","permalink":"http://yoursite.com/images/海康视屏的rtsp实时播放.html","excerpt":"","text":"实时视屏播放的简单实现 通过使用nginx搭建一个简单的服务器，使用ffmpeg推送rtmp实时流，利用video标签实现可以在web端和手机端的浏览器中进行直播。 Windows下面搭建基于rtmp的服务器硬件环境操作系统：windows7旗舰版 处 理 器：Intel(R) Core(TM)i5-5200 CPU @2.20GHz 2.20 GHz 系统内存： 8GB 系统类型：64位操作系统 软件环境及配置 下载 nginx 1.7.11.3 Gryphon，然后解压到对应的目录；下载链接-Gryphon.zip 将解压后的目录名:nginx 1.7.11.3 Gryphon改成:nginx-1.7.11.3-Gryphon ​ 下载服务器状态检查程序 stat.xsl 下载地址 将nginx-rtmp-module-master.zip解压后复制到目录:nginx-1.7.11.3-Gryphon中。 保证stat.xls的目录为:nginx-1.7.11.3-Gryphon\\nginx-rtmp-module\\stat.xsl 修改conf\\nginx-win.conf 配置文件。 添加rtmp服务。 123456789101112rtmp &#123; server &#123; listen 1935; chunk_size 4000; application hls&#123; live on ; hls on ; hls_path html/hls; hls_fragment 5s; &#125; &#125;&#125; 配置http server 12345678910server &#123; listen 80; location /hls &#123; types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root html; expires -1; &#125; 启动服务器 在nginx.exe所在的文件夹，按住shift+右键，选中在此处打开命令窗口，进入windows的cmd。输入以下命令启动nginx服务： 1nginx.exe -c conf\\nginx-win.conf 启动结果 直接在浏览器里输入127.0.0.1就可以进入浏览器的欢迎界面 提供rtmp直播源在搭建好基于rtmp的服务器之后，需要提供rtmp直播源。这里我们使用的海康视屏的rtsp直播源。根据nginx.conf中的hls_path配置，下面这个命令会向本地的html\\hls下面写入ts片段和m3u8文件。 1ffmpeg -f rtsp -re -analyzeduration 8000 -probesize 200000 -i &quot;rtsp://admin:hbj3022810@171.121.218.169:2554/h264/ch33/main/av_stream&quot; -strict -2 -c copy -flvflags aac_seq_header_detect -f flv rtmp://localhost/hls/mystream 注意 1、这里提供rtmp源的机器不一定和nginx在同一台物理主机上，可以是网络上的另一台机器，只要保证它能与nginx所在的主机建立tcp链接即可。（也就是nginx主机需要开启rtmp服务的监听端口，这里是1935，当然你也可以修改为其他的端口。） 在网页中展示视屏在nginx-1.7.11.3-Gryphon/html目录下面创建一个live.html。 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://vjs.zencdn.net/5.10/video-js.css&quot;&gt;&lt;/head&gt; &lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls autoplay=true&gt; &lt;source src=&quot;hls/mystream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt; &lt;script src=&quot;http://vjs.zencdn.net/5.10/video.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://npmcdn.com/videojs-contrib-hls@^3.0.0/dist/videojs-contrib-hls.js&quot;&gt;&lt;/script&gt; &lt;/script&gt; &lt;script&gt; var player = videojs(&apos;example-video&apos;); player.play(); &lt;/script&gt;&lt;/html&gt; 如果只是用video标签是无法播放.m3u8的视屏文件的，需要引入videojs-contrib-hls.js。videojs-contrib-hls支持一堆HLS功能 web端运行效果 手机端运行效果 手机端如果与web可以在同一个网络环境中，那么输入对应本机ip地址也是可以查看的，并且支持横屏、竖屏的切换。"},{"title":"","date":"2018-07-20T03:11:24.776Z","updated":"2018-07-20T03:11:24.776Z","comments":true,"path":"rtsp-hls-online-live/新建文本文档.html","permalink":"http://yoursite.com/rtsp-hls-online-live/新建文本文档.html","excerpt":"","text":"FFMPEG功能说明Fmpeg是用于录制、转换和流化音频和视频的完整解决方案， 包括 libavcodec ，一套领先的音/视频编解码类库。FFmpeg 在Linux上开发，当可以在大多数操作系统下编译，包括Windows。 Note FFmpeg对GCC的依赖很强，所以就算是在Windows上， 用VC编译FFmpeg也不是一件轻松的事情。请尽量使用 GCC来编译FFmpeg，比较事半功倍。 包组成结构FFmpeg主要由一下几个部分组成： libavcodec：一个包含了所有FFmpeg音视频编解码器的库。为了保证最优性能和高可复用性,大多数编解码器从头开发的。 libavformat： 一个包含了所有的普通音视格式的解析器和 产生器的库。 三个实例程序，这三个实例较为复杂，基本可以作为API使用手册： ffmpeg：命令行的视频格式转换程序。ffplay：视频播放程序。（需要SDL支持）ffserver：多媒体服务器 下载使用下载地址官网地址：http://ffmpeg.org/ git地址： https://github.com/FFmpeg/FFmpeg ffmpeg命令参数介绍 基本格式 -formats 输出所有可用格式 -f fmt 指定格式(音频或视频格式) -i filename 指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头 -y 覆盖已有文件 -t duration 记录时长为t -fs limit_size 设置文件大小上限 -ss time_off 从指定的时间(s)开始， [-]hh:mm:ss[.xxx]的格式也支持 -itsoffset time_off 设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss[.xxx]的格式也支持 -title string 标题 -timestamp time 时间戳 -author string 作者 -copyright string 版权信息 -comment string 评论 -album string album名 -v verbose 与log相关的 -target type 设置目标文件类型(“vcd”, “svcd”, “dvd”, “dv”, “dv50”, “pal-vcd”, “ntsc-svcd”, …) -dframes number 设置要记录的帧数 视屏选项 常用命令音频转换 ffmpeg -i my_audio.wav my_audio.mp3 视频转换 ffmpeg -i my_video.mpeg -s 500×500 my_video.flv 从视频中截取图片 分离视频音频流 ffmpeg -i input_file -vcodec copy -an output_file_video //分离视频流 ffmpeg -i input_file -acodec copy -vn output_file_audio //分离音频流 视频解复用 ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264``ffmpeg –i test.avi –vcodec copy –an –f m4v test.264 视频转码 ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264 //转码为码流原始文件ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264 //转码为码流原始文件 ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi //转码为封装文件//-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制 视频封装 ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file 视频剪切 ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg //提取图片 ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi //剪切视频//-r 提取图像的频率，-ss 开始时间，-t 持续时间 视频录制 ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi 常见错误相关文章1.ffmpeg常用参数一览表"},{"title":"","date":"2018-07-12T07:06:42.954Z","updated":"2018-07-12T07:03:11.980Z","comments":true,"path":"images/rtsp/videojs.html","permalink":"http://yoursite.com/images/rtsp/videojs.html","excerpt":"","text":"video标签插件库[TOC] videojs-contrib-hls官网地址 github地址 插件介绍插件说明：https://www.cnblogs.com/tinywan/p/6692098.html 常见错误 1、在播放.m3u8的文件时，浏览器出现了如下的错误，原因是对应的查看的js版本太低了，更换之后就不会出现下面的问题了。"}],"posts":[{"title":"https经过nginx后struts跳转成http","text":"用户登录后会跳转到登录后页面，由于经过了nginx，后端tomcat实际上被访问的是http协议，所以出现了 用 https://xxx.ecample.com/login.st 的请求，登录后跳转到 http://xxx.com/login.st 这样的情况。代码使用的是struts2 的 redirect方法。 123&lt;action name=&quot;login_*&quot; method=&quot;&#123;1&#125;&quot; class=&quot;loginAction&quot;&gt; &lt;result name=&quot;nextjsp&quot; type=&quot;redirect&quot;&gt;/skin/main/main.jsp&lt;/result&gt;&lt;/action&gt; 系统只用https访问 ​ 在tomcat的server.xml 的 connector 标签页里，增加 secure=”true” scheme=”https” proxyPort=”443” 三个选项，直接重启tomcat即可。 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8449&quot; URIEncoding=&quot;UTF-8&quot; secure=&quot;true&quot; scheme=&quot;https&quot; proxyPort=&quot;443&quot; /&gt; 这样所有访问到tomcat的请求，如果使用struts的redirect方法，都会跳转成https的方法。 两种方式都可以访问 如果项目有特殊要求，需要项目既可以使用http也可以使用https访问，可以采用如下的方法： ​ 在tomcat的server.xml配置文件中增加一个connector标签，内容和之前的一样即可，唯一的区别就是一个里面有https的三个参数，一个不带（这里要注意一下，2个connector的port不能一样，要不然端口冲突，tomcat起不来）。 123456 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8449&quot; URIEncoding=&quot;UTF-8&quot; /&gt;&lt;Connector port=&quot;8881&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8449&quot; URIEncoding=&quot;UTF-8&quot; secure=&quot;true&quot; scheme=&quot;https&quot; proxyPort=&quot;443&quot; /&gt; 在前端配置nginx的时候，可以选择把来自http的请求转发到后端 不带https参数的connector 端口上， 把https的请求转发到带https参数的connector 端口上。","content":"<p>用户登录后会跳转到登录后页面，由于经过了nginx，后端tomcat实际上被访问的是http协议，所以出现了 用 <a href=\"https://xxx.ecample.com/login.st\" target=\"_blank\" rel=\"noopener\">https://xxx.ecample.com/login.st</a> 的请求，登录后跳转到 <a href=\"http://xxx.com/login.st\" target=\"_blank\" rel=\"noopener\">http://xxx.com/login.st</a> 这样的情况。代码使用的是struts2 的 redirect方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action name=&quot;login_*&quot; method=&quot;&#123;1&#125;&quot; class=&quot;loginAction&quot;&gt;</span><br><span class=\"line\">\t&lt;result name=&quot;nextjsp&quot; type=&quot;redirect&quot;&gt;/skin/main/main.jsp&lt;/result&gt;</span><br><span class=\"line\">&lt;/action&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>系统只用https访问</li>\n</ul>\n<p>​      在tomcat的server.xml 的 connector 标签页里，增加 secure=”true” scheme=”https” proxyPort=”443” 三个选项，直接重启tomcat即可。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">           connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">           redirectPort=&quot;8449&quot; URIEncoding=&quot;UTF-8&quot;  secure=&quot;true&quot; scheme=&quot;https&quot; proxyPort=&quot;443&quot;  /&gt;</span><br></pre></td></tr></table></figure>\n<p>这样所有访问到tomcat的请求，如果使用struts的redirect方法，都会跳转成https的方法。</p>\n<ul>\n<li>两种方式都可以访问</li>\n</ul>\n<p>如果项目有特殊要求，需要项目既可以使用http也可以使用https访问，可以采用如下的方法： </p>\n<p>​      在tomcat的server.xml配置文件中增加一个connector标签，内容和之前的一样即可，唯一的区别就是一个里面有https的三个参数，一个不带（这里要注意一下，2个connector的port不能一样，要不然端口冲突，tomcat起不来）。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">            connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">            redirectPort=&quot;8449&quot; URIEncoding=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">&lt;Connector port=&quot;8881&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">               connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">               redirectPort=&quot;8449&quot; URIEncoding=&quot;UTF-8&quot;  secure=&quot;true&quot; scheme=&quot;https&quot; proxyPort=&quot;443&quot;  /&gt;</span><br></pre></td></tr></table></figure>\n<p>在前端配置nginx的时候，可以选择把来自http的请求转发到后端 不带https参数的connector 端口上， 把https的请求转发到带https参数的connector 端口上。</p>\n"},{"title":"小程序多文件上传","text":"在开发小程序，我们会开发一些意见反馈等等的接口，需要用户去上传图片来说明具体的情况。小程序为我们提供了文件上传的接口，但是一次只能上传一个文件，这样如果需要上传多个文件的时候对于用户的体验是非常不好的，如果解决呢？ 具体实现图片上传页面12 多文件上传函数1234567891011121314151617181920212223242526272829303132// 多文件上传函数 uploadFiles(filePaths, successUp, failUp, i, length) &#123; wx.uploadFile(&#123; url: app.globalData.baseUrl + &quot;/Example/bas/api/fapi0020_uploadfile.st?rkspAutoComplete=true&quot;, filePath: filePaths[i], name: &apos;file&apos;, formData: &#123; &apos;problemId&apos;: this.data.problemId, &apos;userId&apos;: wx.getStorageSync(&apos;userInfo&apos;).userid &#125;, success: (resp) =&gt; &#123; successUp++; &#125;, fail: (res) =&gt; &#123; failUp++; &#125;, complete: () =&gt; &#123; i++; if (i == length) &#123; this.setData(&#123; resultMessage: &apos;总共&apos; + successUp + &apos;张上传成功,&apos; + failUp + &apos;张上传失败！&apos; &#125;) wx.showToast(&#123; title: &apos;操作成功&apos;, &#125;) wx.hideLoading(); &#125; else &#123; //递归调用uploadFiles函数 this.uploadFiles(filePaths, successUp, failUp, i, length); &#125; &#125;, &#125;); &#125; 调用12345let length = this.data.picUrls.length; //总共个数let successUp = 0; //成功个数let failUp = 0; //失败个数let i = 0; //第几个this.uploadFiles(this.data.picUrls, successUp, failUp, i, length); 选择图片12345678910111213141516//拍照或选择相册 bindCamera: function() &#123; wx.chooseImage(&#123; count: 4, sizeType: [&apos;original&apos;, &apos;compressed&apos;], sourceType: [&apos;album&apos;, &apos;camera&apos;], success: (res) =&gt; &#123; let tfps = res.tempFilePaths; this.setData(&#123; picUrls: tfps, actionText: &quot;+&quot; &#125;); &#125; &#125;) &#125;, 删除图片123456789// 删除选择的图片 delPic: function(e) &#123; let index = e.target.dataset.index; let _picUrls = this.data.picUrls; _picUrls.splice(index, 1); this.setData(&#123; picUrls: _picUrls &#125;) &#125;, 结果展示","content":"<p>在开发小程序，我们会开发一些意见反馈等等的接口，需要用户去上传图片来说明具体的情况。小程序为我们提供了文件上传的接口，但是一次只能上传一个文件，这样如果需要上传多个文件的时候对于用户的体验是非常不好的，如果解决呢？</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h2 id=\"图片上传页面\"><a href=\"#图片上传页面\" class=\"headerlink\" title=\"图片上传页面\"></a>图片上传页面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"多文件上传函数\"><a href=\"#多文件上传函数\" class=\"headerlink\" title=\"多文件上传函数\"></a>多文件上传函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 多文件上传函数</span><br><span class=\"line\">  uploadFiles(filePaths, successUp, failUp, i, length) &#123;</span><br><span class=\"line\">    wx.uploadFile(&#123;</span><br><span class=\"line\">      url: app.globalData.baseUrl + &quot;/Example/bas/api/fapi0020_uploadfile.st?rkspAutoComplete=true&quot;,</span><br><span class=\"line\">      filePath: filePaths[i],</span><br><span class=\"line\">      name: &apos;file&apos;,</span><br><span class=\"line\">      formData: &#123;</span><br><span class=\"line\">        &apos;problemId&apos;: this.data.problemId,</span><br><span class=\"line\">        &apos;userId&apos;: wx.getStorageSync(&apos;userInfo&apos;).userid</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success: (resp) =&gt; &#123;</span><br><span class=\"line\">        successUp++;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail: (res) =&gt; &#123;</span><br><span class=\"line\">        failUp++;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      complete: () =&gt; &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        if (i == length) &#123;</span><br><span class=\"line\">          this.setData(&#123;</span><br><span class=\"line\">            resultMessage: &apos;总共&apos; + successUp + &apos;张上传成功,&apos; + failUp + &apos;张上传失败！&apos;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          wx.showToast(&#123;</span><br><span class=\"line\">            title: &apos;操作成功&apos;,</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          wx.hideLoading();</span><br><span class=\"line\">        &#125; else &#123; //递归调用uploadFiles函数</span><br><span class=\"line\">          this.uploadFiles(filePaths, successUp, failUp, i, length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let length = this.data.picUrls.length; //总共个数</span><br><span class=\"line\">let successUp = 0; //成功个数</span><br><span class=\"line\">let failUp = 0; //失败个数</span><br><span class=\"line\">let i = 0; //第几个</span><br><span class=\"line\">this.uploadFiles(this.data.picUrls, successUp, failUp, i, length);</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择图片\"><a href=\"#选择图片\" class=\"headerlink\" title=\"选择图片\"></a>选择图片</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拍照或选择相册</span><br><span class=\"line\">  bindCamera: function() &#123;</span><br><span class=\"line\">    wx.chooseImage(&#123;</span><br><span class=\"line\">      count: 4,</span><br><span class=\"line\">      sizeType: [&apos;original&apos;, &apos;compressed&apos;],</span><br><span class=\"line\">      sourceType: [&apos;album&apos;, &apos;camera&apos;],</span><br><span class=\"line\">      success: (res) =&gt; &#123;</span><br><span class=\"line\">        let tfps = res.tempFilePaths;</span><br><span class=\"line\">        this.setData(&#123;</span><br><span class=\"line\">          picUrls: tfps,</span><br><span class=\"line\">          actionText: &quot;+&quot;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除图片\"><a href=\"#删除图片\" class=\"headerlink\" title=\"删除图片\"></a>删除图片</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 删除选择的图片</span><br><span class=\"line\"> delPic: function(e) &#123;</span><br><span class=\"line\">   let index = e.target.dataset.index;</span><br><span class=\"line\">   let _picUrls = this.data.picUrls;</span><br><span class=\"line\">   _picUrls.splice(index, 1);</span><br><span class=\"line\">   this.setData(&#123;</span><br><span class=\"line\">     picUrls: _picUrls</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h2><p><img src=\"F:\\hexo\\source\\images\\miniprogram\\fileupload1.png\" alt=\"avatar\"></p>\n"},{"title":"微信小程序昵称特殊字符的处理","text":"​ 昵称处理 在小程序的开发过程中，我们不可避免的需要保存用户昵称，但是小程序中的昵称是支持特殊字符的。有的用户是很喜欢在昵称中加入emoj表情的。所以我们需要解决微信登录时昵称中包含特殊字符，不能存入数据库问题。 大致思路则是接收到的用户的昵称参数进行编码处理。 对昵称进行编码 首先对于获取到的字符串进行加密 1wc会员.set昵称(Base64.encodeBase64String(btbUser.getNickName().getBytes(&quot;utf-8&quot;))); 数据保存之后的结果如下图所示： 解码的时候采用： nickname = new String(Base64.decodeBase64(nickname.getBytes()), “utf-8”); 这里不使用这种方式解码的原因是如果是对页面初始化的中集合进行处理的话，需要对取出来的数据在进行一次遍历操作对字符进行处理，过程比较繁琐。 对昵称进行解码在后台页面展示时，对字符串进行解码操作，这里采用的是crypto-js。（这里试过很多种方法，但是对于包含特殊字符以及中文的编码和解码支持的都不是很好，无法和java、mysql等方式进行衔接） 首先在github上面下在对应的js , 或者使用npm的方式进行安装. 1npm install crypto-js 页面中引入相应的js文件。 12&lt;script type=&apos;text/javascript&apos; src=&quot;$&#123;appPath&#125;/common/btb/js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script type=&apos;text/javascript&apos; src=&quot;$&#123;appPath&#125;/common/btb/js/enc-base64.js&quot;&gt;&lt;/script&gt; js中定义个一处理昵称的函数： 12345678910111213141516171819function formatNickName(data) &#123; if(data)&#123; data = base64_decode(data); return data; &#125;else&#123; return &quot;&quot;; &#125; &#125;//编码function base64_encode(str)&#123; var tempstr=CryptoJS.enc.Utf8.parse($(&quot;#source&quot;).val()); var base64str=CryptoJS.enc.Base64.stringify(tempstr); return base64str;&#125;//解码function base64_decode(str)&#123; var words = CryptoJS.enc.Base64.parse(str); return words.toString(CryptoJS.enc.Utf8)&#125; 在对应列表中加入格式化函数 1234&lt;st:objList id=&quot;fusr0010&quot; tabRowId=&quot;oid&quot; tabSearchId=&quot;fusr0010QuerySearchForm&quot; tabPath=&quot;/btb/usr/fusr0010_query.st&quot; tabInstanceName=&quot;fusr0010Ap&quot; tabRowhandler=&quot;rightHander&quot; tabTitle=&quot;用户管理&quot; tabPageSize=&quot;7&quot;&gt; &lt;st:objListColumn columnDisplay=&quot;昵称&quot; columnName=&quot;昵称&quot; columnSortName=&quot;昵称&quot; columnWidth=&quot;10%&quot; columnProcess=&quot;formatNickName&quot;&gt;&lt;/st:objListColumn&gt;&lt;/st:objList&gt; 结果展示 【扩展】除了java和js中可以对字符进行处理。在mysql5.6及之后也有提供了响应函数支持。 to_base64 123456mysql&gt; select to_base64(&apos;helloworld&apos;);+-------------------------+| to_base64(&apos;helloworld&apos;) |+-------------------------+| aGVsbG93b3JsZA== |+-------------------------+ from_base64 123456mysql&gt; select from_base64(&apos;aGVsbG93b3JsZA==&apos;);+---------------------------------+| from_base64(&apos;aGVsbG93b3JsZA==&apos;) |+---------------------------------+| helloworld |+---------------------------------+","content":"<p>​    </p>\n<h1 id=\"昵称处理\"><a href=\"#昵称处理\" class=\"headerlink\" title=\"昵称处理\"></a>昵称处理</h1><p>   在小程序的开发过程中，我们不可避免的需要保存用户昵称，但是小程序中的昵称是支持特殊字符的。有的用户是很喜欢在昵称中加入emoj表情的。所以我们需要解决微信登录时昵称中包含特殊字符，不能存入数据库问题。</p>\n<p>大致思路则是接收到的用户的昵称参数进行编码处理。</p>\n<h2 id=\"对昵称进行编码\"><a href=\"#对昵称进行编码\" class=\"headerlink\" title=\"对昵称进行编码\"></a>对昵称进行编码</h2><ul>\n<li>首先对于获取到的字符串进行加密</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc会员.set昵称(Base64.encodeBase64String(btbUser.getNickName().getBytes(&quot;utf-8&quot;)));</span><br></pre></td></tr></table></figure>\n<p> 数据保存之后的结果如下图所示：</p>\n<p><img src=\"/images/miniprogram/nickname1.png\" alt=\"avatar\"></p>\n<blockquote>\n<p>解码的时候采用：</p>\n<p>nickname = new String(Base64.decodeBase64(nickname.getBytes()), “utf-8”);</p>\n<p>这里不使用这种方式解码的原因是如果是对页面初始化的中集合进行处理的话，需要对取出来的数据在进行一次遍历操作对字符进行处理，过程比较繁琐。</p>\n</blockquote>\n<h2 id=\"对昵称进行解码\"><a href=\"#对昵称进行解码\" class=\"headerlink\" title=\"对昵称进行解码\"></a>对昵称进行解码</h2><p>在后台页面展示时，对字符串进行解码操作，这里采用的是<a href=\"https://github.com/brix/crypto-js\" target=\"_blank\" rel=\"noopener\">crypto-js</a>。（这里试过很多种方法，但是对于包含特殊字符以及中文的编码和解码支持的都不是很好，无法和java、mysql等方式进行衔接）</p>\n<ul>\n<li>首先在github上面下在对应的js , 或者使用npm的方式进行安装.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install crypto-js</span><br></pre></td></tr></table></figure>\n<ul>\n<li>页面中引入相应的js文件。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&apos;text/javascript&apos; src=&quot;$&#123;appPath&#125;/common/btb/js/crypto-js.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&apos;text/javascript&apos; src=&quot;$&#123;appPath&#125;/common/btb/js/enc-base64.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>js中定义个一处理昵称的函数：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function formatNickName(data) &#123;\t</span><br><span class=\"line\">\t\tif(data)&#123;\t</span><br><span class=\"line\">\t \t\tdata = base64_decode(data);</span><br><span class=\"line\">\t\t\treturn data;\t\t</span><br><span class=\"line\">\t\t&#125;else&#123;\t\t\t</span><br><span class=\"line\">\t\t\treturn &quot;&quot;;\t\t</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">//编码</span><br><span class=\"line\">function base64_encode(str)&#123;</span><br><span class=\"line\">\tvar tempstr=CryptoJS.enc.Utf8.parse($(&quot;#source&quot;).val());</span><br><span class=\"line\">\tvar base64str=CryptoJS.enc.Base64.stringify(tempstr);</span><br><span class=\"line\">\treturn \tbase64str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//解码</span><br><span class=\"line\">function base64_decode(str)&#123;</span><br><span class=\"line\">\tvar words  = CryptoJS.enc.Base64.parse(str);</span><br><span class=\"line\">\treturn words.toString(CryptoJS.enc.Utf8)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在对应列表中加入格式化函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;st:objList id=&quot;fusr0010&quot; tabRowId=&quot;oid&quot; tabSearchId=&quot;fusr0010QuerySearchForm&quot; tabPath=&quot;/btb/usr/fusr0010_query.st&quot;  tabInstanceName=&quot;fusr0010Ap&quot; </span><br><span class=\"line\">\t    \t    tabRowhandler=&quot;rightHander&quot; tabTitle=&quot;用户管理&quot;  tabPageSize=&quot;7&quot;&gt;</span><br><span class=\"line\">\t&lt;st:objListColumn columnDisplay=&quot;昵称&quot; columnName=&quot;昵称&quot; columnSortName=&quot;昵称&quot; columnWidth=&quot;10%&quot; columnProcess=&quot;formatNickName&quot;&gt;&lt;/st:objListColumn&gt;</span><br><span class=\"line\">&lt;/st:objList&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h2><p><img src=\"/images/miniprogram/nickname2.png\" alt=\"avatar\"></p>\n<h1 id=\"【扩展】\"><a href=\"#【扩展】\" class=\"headerlink\" title=\"【扩展】\"></a>【扩展】</h1><p>除了java和js中可以对字符进行处理。在mysql5.6及之后也有提供了响应函数支持。</p>\n<ul>\n<li>to_base64</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select to_base64(&apos;helloworld&apos;);</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| to_base64(&apos;helloworld&apos;) |</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| aGVsbG93b3JsZA==        |</span><br><span class=\"line\">+-------------------------+</span><br></pre></td></tr></table></figure>\n<ul>\n<li>from_base64</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select from_base64(&apos;aGVsbG93b3JsZA==&apos;);</span><br><span class=\"line\">+---------------------------------+</span><br><span class=\"line\">| from_base64(&apos;aGVsbG93b3JsZA==&apos;) |</span><br><span class=\"line\">+---------------------------------+</span><br><span class=\"line\">| helloworld                      |</span><br><span class=\"line\">+---------------------------------+</span><br></pre></td></tr></table></figure>\n"},{"title":"Mysql常见问题及解决","text":"UTF-8编码字节个数问题Incorrect string value: ‘\\xF0\\x9F…’ for column ‘XXX’ at row 1 这个问题，原因是UTF-8编码有可能是两个、三个、四个字节。Emoji表情或者某些特殊字符是4个字节，而Mysql的utf8编码最多3个字节，所以数据插不进去。 【解决方法】 在mysql的安装目录下找到my.ini,作如下修改： 12345[mysqld]character-set-server=utf8mb4[mysql]default-character-set=utf8mb4修改后重启Mysql 将已经建好的表也转换成utf8mb4 12更改数据库编码：ALTER DATABASE caitu99 CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;alter table TABLE_NAME convert to character set utf8mb4 collate utf8mb4_bin; （将TABLE_NAME替换成你的表名） 修改mysql配置文件my.cnf（windows为my.ini） my.cnf一般在/etc/my.cnf位置。找到后请在以下三部分里添加如下内容： 123456789[client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4[mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect=&apos;SET NAMES utf8mb4&apos; 忽略大小写问题在系统运行时，ba_user表实际上是存在的，但是因为mysql大小写的问题，所以在执行服务时找不到对应的表。 12345Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &apos;booktobook.BA_User&apos; doesn&apos;t exista...com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.executeQuery(NewProxyPreparedStatement.java:116) at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(ResultSetReturnImpl.java:82) ... 82 more 查看大小写区分1mysql&gt; show variables like &quot;%case%&quot;; 执行结果： Variable_name Value lower_case_file_system OFF lower_case_table_names 0 【注意】 MYSQL在LINUX下数据库名、表名、列名、别名大小写规则如下： 据库名与表名是严格区分大小写的 表的别名是严格区分大小写的 列名与列的别名在所有的情况下均是忽略大小写的 变量名也是严格区分大小写的 【解决办法】 用ROOT登录，修改/etc/my.cnf 1vi /etc/my.cnf 在[mysqld]下加入一行：lower_case_table_names=1 重新启动数据库即可 1/etc/init.d/mysqld restart 链接超时问题使用Connector/J连接MySQL数据库，程序运行较长时间后就会报以下错误： 1Communications link failure，The last packet successfully received from the server was * millisecond ago.The last packet successfully sent to the server was * millisecond ago。 【原因】 MySQL服务器默认的“wait_timeout”是28800秒即8小时，意味着如果一个连接的空闲时间超过8个小时，MySQL将自动断开该连接，而连接池却认为该连接还是有效的(因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致上面的报错。 【解决】 修改数据库的wait_timeout最大为31536000即1年，在my.cnf中加入： [mysqld] wait_timeout=31536000 interactive_timeout=31536000 重启生效，需要同时修改这两个参数。","content":"<h1 id=\"UTF-8编码字节个数问题\"><a href=\"#UTF-8编码字节个数问题\" class=\"headerlink\" title=\"UTF-8编码字节个数问题\"></a>UTF-8编码字节个数问题</h1><p><strong>Incorrect string value: ‘\\xF0\\x9F…’ for column ‘XXX’ at row 1</strong></p>\n<p>这个问题，原因是UTF-8编码有可能是两个、三个、四个字节。Emoji表情或者某些特殊字符是4个字节，而Mysql的utf8编码最多3个字节，所以数据插不进去。</p>\n<p>【解决方法】</p>\n<ul>\n<li>在mysql的安装目录下找到my.ini,作如下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">character-set-server=utf8mb4</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8mb4</span><br><span class=\"line\">修改后重启Mysql</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将已经建好的表也转换成utf8mb4</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更改数据库编码：ALTER DATABASE caitu99 CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class=\"line\">alter table TABLE_NAME convert to character set utf8mb4 collate utf8mb4_bin; （将TABLE_NAME替换成你的表名）</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改mysql配置文件my.cnf（windows为my.ini） </li>\n</ul>\n<p>my.cnf一般在/etc/my.cnf位置。找到后请在以下三部分里添加如下内容： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client] </span><br><span class=\"line\">default-character-set = utf8mb4 </span><br><span class=\"line\">[mysql] </span><br><span class=\"line\">default-character-set = utf8mb4</span><br><span class=\"line\">[mysqld] </span><br><span class=\"line\">character-set-client-handshake = FALSE </span><br><span class=\"line\">character-set-server = utf8mb4 </span><br><span class=\"line\">collation-server = utf8mb4_unicode_ci </span><br><span class=\"line\">init_connect=&apos;SET NAMES utf8mb4&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"忽略大小写问题\"><a href=\"#忽略大小写问题\" class=\"headerlink\" title=\"忽略大小写问题\"></a>忽略大小写问题</h1><p>在系统运行时，ba_user表实际上是存在的，但是因为mysql大小写的问题，所以在执行服务时找不到对应的表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &apos;booktobook.BA_User&apos; doesn&apos;t exista</span><br><span class=\"line\">...</span><br><span class=\"line\">com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.executeQuery(NewProxyPreparedStatement.java:116)</span><br><span class=\"line\">\tat org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.extract(ResultSetReturnImpl.java:82)</span><br><span class=\"line\">\t... 82 more</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看大小写区分<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &quot;%case%&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>执行结果：</p>\n<table>\n<thead>\n<tr>\n<th>Variable_name</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lower_case_file_system</td>\n<td>OFF</td>\n</tr>\n<tr>\n<td>lower_case_table_names</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>【注意】</p>\n<p>MYSQL在LINUX下数据库名、表名、列名、别名大小写规则如下：</p>\n<ol>\n<li><p>据库名与表名是严格区分大小写的 </p>\n</li>\n<li><p>表的别名是严格区分大小写的  </p>\n</li>\n<li>列名与列的别名在所有的情况下均是忽略大小写的 </li>\n<li>变量名也是严格区分大小写的  </li>\n</ol>\n<p>【解决办法】</p>\n<ul>\n<li>用ROOT登录，修改/etc/my.cnf 　</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/my.cnf</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在[mysqld]下加入一行：lower_case_table_names=1 　　</li>\n<li>重新启动数据库即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure>\n<h1 id=\"链接超时问题\"><a href=\"#链接超时问题\" class=\"headerlink\" title=\"链接超时问题\"></a>链接超时问题</h1><p>使用Connector/J连接MySQL数据库，程序运行较长时间后就会报以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Communications link failure，The last packet successfully received from the server was * millisecond ago.The last packet successfully sent to the server was *  millisecond ago。</span><br></pre></td></tr></table></figure>\n<p>【原因】</p>\n<p>MySQL服务器默认的“wait_timeout”是28800秒即8小时，意味着如果一个连接的空闲时间超过8个小时，MySQL将自动断开该连接，而连接池却认为该连接还是有效的(因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致上面的报错。</p>\n<p>【解决】</p>\n<p>修改数据库的wait_timeout最大为31536000即1年，在my.cnf中加入：</p>\n<p>[mysqld]</p>\n<p>wait_timeout=31536000</p>\n<p>interactive_timeout=31536000</p>\n<p>重启生效，需要同时修改这两个参数。</p>\n"},{"title":"使用wxParse解析html富文本内容","text":"最近项目上遇到在微信小程序里需要显示新闻内，新闻内容是通过接口读取的服务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，那我们需要显示html内容的时候，就可以通过wxParse来实现。 结果展示","content":"<p>最近项目上遇到在微信小程序里需要显示新闻内，新闻内容是通过接口读取的服务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，那我们需要显示html内容的时候，就可以通过wxParse来实现。 </p>\n<h2 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h2><p><img src=\"F:\\hexo\\source\\images\\miniprogram\\fileupload1.png\" alt=\"avatar\"> </p>\n"},{"title":"在项目中使用Echarts","text":"前期准备在echart官网中下载对应的ecarts插件。 如果是开发中建议下载源代码，把下载下来的echarts.js 放在对应的文件中。 页面1、在页面中引入echarts.js。 1&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;appPath&#125;/plugins/echarts/echarts.js&quot;&gt;&lt;/script&gt; 2、定义存放ecahrt表格的容器。 12&lt;div id=&apos;line&apos; style=&quot;height: 450px; border: 1px solid #ccc; padding: 10px;&quot;&gt;&lt;/div&gt;&lt;div id=&apos;noData&apos; style=&quot;height: 450px; border: 1px solid #ccc; padding: 10px;text-align: center;color:red;font-size:16px;margin-top:20px;font-weight:bold&quot;&gt;没有数据&lt;/div&gt; 3、初始化echarts的配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var myChart = echarts.init(document.getElementById(&apos;line&apos;),&quot;light&quot;);var lineOption = &#123; title : &#123; text : &apos;&apos;, subtext : &apos;&apos; &#125;, tooltip : &#123; trigger : &apos;axis&apos; //item 在哪条线上显示哪条线上的数据，axis点在哪个坐标点上显示对于点上所有数据&#125;,legend : &#123; data : []&#125;,toolbox : &#123; //可视化的工具箱 show : true, feature : &#123; dataView : &#123; //数据视图 show : true &#125;, restore : &#123; //重置 show : true &#125;, dataZoom : &#123; //数据缩放视图 show : true &#125;, saveAsImage : &#123;//保存图片 show : true &#125;, magicType : &#123;//动态类型切换 type : [ &apos;bar&apos;, &apos;line&apos; ] &#125; &#125; &#125;, calculable : true, xAxis : [ &#123; type : &apos;category&apos;, boundaryGap : false, data : [] &#125; ], yAxis : [ &#123; type : &apos;value&apos;, axisLabel : &#123; formatter : &apos;&#123;value&#125; &apos; &#125; &#125; ], series : []&#125;;myChart.setOption(lineOption); 4、请求具体的统计数据，并更新echarts中的动态数据。 12345678910111213141516171819202122232425262728293031323334function queryData() &#123; $(&quot;#line&quot;).show(); $(&quot;#noData&quot;).hide(); $.ajax( &#123; url : &apos;$&#123;appPath&#125;/btb/sta/fsta0010_getLineImage.st&apos;, data : &#123;&#125;, method : &quot;POST&quot;, dataType : &apos;json&apos;, success : function(data) &#123; //请求成功时处理 var data = JSON.stringify(data.resultDataMap); var responseText = eval(&apos;(&apos; + data + &apos;)&apos;); lineOption.legend.data = responseText.legend; lineOption.xAxis[0].data = responseText.xAxis; var serieslist = responseText.series; if(serieslist.length &gt; 0)&#123; for ( var i = 0; i &lt; serieslist.length; i++) &#123; lineOption.series[i] = serieslist[i]; &#125; &#125;else&#123; $(&quot;#line&quot;).hide(); $(&quot;#noData&quot;).show(); &#125; myChart.setOption(lineOption, true); &#125;, complete : function() &#123; //请求完成的处理 &#125;, error : function() &#123; //请求出错处理 com_div_msg(&quot;加载失败&quot;); &#125; &#125;)&#125; 123456$(function()&#123; //相关页面初始化的处理； ...... //查询统计数据 queryData();&#125;) 后台在对应的统计的action中： 12345678910111213141516171819202122public String getLineImage() &#123; List&lt;EchartsEntity&gt; echarts = new ArrayList&lt;EchartsEntity&gt;(); // 自定义横坐标 String[] xAxis = &#123; &quot;周一&quot;, &quot;周二&quot;, &quot;周三&quot;, &quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot;, &quot;周日&quot; &#125;; // 自定义各种类型的显示数据 EchartsEntity entity1 = new EchartsEntity(&quot;邮件营销&quot;, &quot;line&quot;, Arrays .asList(120, 132, 101, 134, 90, 230, 210)); EchartsEntity entity2 = new EchartsEntity(&quot;联盟广告&quot;, &quot;line&quot;, Arrays .asList(220, 182, 191, 234, 290, 330, 310)); EchartsEntity entity3 = new EchartsEntity(&quot;视频广告&quot;, &quot;line&quot;, Arrays .asList(150, 232, 201, 154, 190, 330, 410)); echarts.add(entity1); echarts.add(entity2); echarts.add(entity3); String[] legend = &#123; &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot; &#125;; resultDataMap = new HashMap&lt;String, Object&gt;(); resultDataMap.put(&quot;xAxis&quot;, xAxis); resultDataMap.put(&quot;series&quot;, echarts); resultDataMap.put(&quot;legend&quot;, legend); System.out.println(GsonUtil.getJSONString(resultDataMap)); return &quot;json&quot;;&#125; 2、EchartsEntity 123456public class EchartsEntity &#123; public String name; public String type; public List&lt;?&gt; data; //此处省略get,set方法 &#125; 配置文件在对应的strus的配置文件中把后端的resultDataMap 作为json对象返回到页面中： 123456&lt;package name=&quot;btbsta&quot; extends=&quot;base&quot; namespace=&quot;/btb/sta&quot; strict-method-invocation=&quot;false&quot;&gt; &lt;action name=&quot;fsta0010_*&quot; method=&quot;&#123;1&#125;&quot; class=&quot;fsta0010Action&quot;&gt; &lt;result name=&quot;json&quot; type=&quot;json&quot;&gt; &lt;param name=&quot;includeProperties&quot;&gt;resultDataMap.*&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 示例结果 其他更换主题在有些情况下，为了和自己的系统的主题相适应，我们需要更改ecahrt默认的主题。 echarts.js自带官方自带的主题有default，dark，light。这三种主题是不需要下载的。使用方法如下： 1var myChart = echarts.init(document.getElementById(&apos;line&apos;), &apos;light&apos;); 官网下载echarts中除了自带的三种样式之外，还提供了其他主题。使用的方法如下： 1、在官网上下载对应的主题文件的js，例如macarons.js。 2、在页面中引入js。 3、在初始化echarts配置的时候，加入主题的名称即可。 1var myChart = echarts.init(document.getElementById(&apos;line&apos;), &apos;macarons&apos;); echarts2.0版本的使用示例","content":"<h1 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h1><p>在echart官网中<a href=\"http://echarts.baidu.com/download.html\" target=\"_blank\" rel=\"noopener\">下载对应的ecarts插件</a>。</p>\n<blockquote>\n<p>如果是开发中建议下载源代码，把下载下来的echarts.js 放在对应的文件中。</p>\n</blockquote>\n<h1 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h1><p>1、在页面中引入echarts.js。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;appPath&#125;/plugins/echarts/echarts.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>2、定义存放ecahrt表格的容器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;line&apos; style=&quot;height: 450px; border: 1px solid #ccc; padding: 10px;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&apos;noData&apos; style=&quot;height: 450px; border: 1px solid #ccc; padding: 10px;text-align: center;color:red;font-size:16px;margin-top:20px;font-weight:bold&quot;&gt;没有数据&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>3、初始化echarts的配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myChart = echarts.init(document.getElementById(&apos;line&apos;),&quot;light&quot;);</span><br><span class=\"line\">var lineOption = &#123;</span><br><span class=\"line\">\ttitle : &#123;</span><br><span class=\"line\">\t\ttext : &apos;&apos;,</span><br><span class=\"line\">\t\tsubtext : &apos;&apos;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttooltip : &#123;</span><br><span class=\"line\">\t\ttrigger : &apos;axis&apos; //item 在哪条线上显示哪条线上的数据，axis点在哪个坐标点上显示对于点上所有数据</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">legend : &#123;</span><br><span class=\"line\">\tdata : []</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">toolbox : &#123; //可视化的工具箱</span><br><span class=\"line\">\t\tshow : true,</span><br><span class=\"line\">\t\tfeature : &#123;</span><br><span class=\"line\">\t\t\tdataView : &#123; //数据视图</span><br><span class=\"line\">\t\t\t\tshow : true</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\trestore : &#123; //重置</span><br><span class=\"line\">\t\t\t\tshow : true</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tdataZoom : &#123; //数据缩放视图</span><br><span class=\"line\">\t\t\t\tshow : true</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tsaveAsImage : &#123;//保存图片</span><br><span class=\"line\">\t\t\t\tshow : true</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tmagicType : &#123;//动态类型切换</span><br><span class=\"line\">\t\t\t\ttype : [ &apos;bar&apos;, &apos;line&apos; ]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcalculable : true,</span><br><span class=\"line\">\txAxis : [ &#123;</span><br><span class=\"line\">\t\ttype : &apos;category&apos;,</span><br><span class=\"line\">\t\tboundaryGap : false,</span><br><span class=\"line\">\t\tdata : []</span><br><span class=\"line\">\t&#125; ],</span><br><span class=\"line\">\tyAxis : [ &#123;</span><br><span class=\"line\">\t\ttype : &apos;value&apos;,</span><br><span class=\"line\">\t\taxisLabel : &#123;</span><br><span class=\"line\">\t\t\tformatter : &apos;&#123;value&#125; &apos;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; ],</span><br><span class=\"line\">\tseries : []</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myChart.setOption(lineOption);</span><br></pre></td></tr></table></figure>\n<p>4、请求具体的统计数据，并更新echarts中的动态数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function queryData() &#123;</span><br><span class=\"line\">\t$(&quot;#line&quot;).show();</span><br><span class=\"line\">\t$(&quot;#noData&quot;).hide();</span><br><span class=\"line\">\t\t$.ajax( &#123;</span><br><span class=\"line\">\t\turl : &apos;$&#123;appPath&#125;/btb/sta/fsta0010_getLineImage.st&apos;,</span><br><span class=\"line\">\t\tdata : &#123;&#125;,</span><br><span class=\"line\">\t\tmethod : &quot;POST&quot;,</span><br><span class=\"line\">\t\tdataType : &apos;json&apos;,</span><br><span class=\"line\">\t\tsuccess : function(data) &#123;</span><br><span class=\"line\">\t\t//请求成功时处理</span><br><span class=\"line\">\t\tvar data = JSON.stringify(data.resultDataMap);</span><br><span class=\"line\">\t\tvar responseText = eval(&apos;(&apos; + data + &apos;)&apos;);</span><br><span class=\"line\">\t\tlineOption.legend.data = responseText.legend;</span><br><span class=\"line\">\t\tlineOption.xAxis[0].data = responseText.xAxis;</span><br><span class=\"line\">\t\tvar serieslist = responseText.series;</span><br><span class=\"line\">\t\tif(serieslist.length &gt; 0)&#123;</span><br><span class=\"line\">\t\t\tfor ( var i = 0; i &lt; serieslist.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\tlineOption.series[i] = serieslist[i];</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t$(&quot;#line&quot;).hide();</span><br><span class=\"line\">\t        $(&quot;#noData&quot;).show();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmyChart.setOption(lineOption, true);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcomplete : function() &#123;</span><br><span class=\"line\">\t\t//请求完成的处理</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\terror : function() &#123;</span><br><span class=\"line\">\t\t//请求出错处理</span><br><span class=\"line\">\t\tcom_div_msg(&quot;加载失败&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(function()&#123;</span><br><span class=\"line\">    //相关页面初始化的处理；</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    //查询统计数据</span><br><span class=\"line\">    queryData();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"后台\"><a href=\"#后台\" class=\"headerlink\" title=\"后台\"></a>后台</h1><p>在对应的统计的action中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getLineImage() &#123;</span><br><span class=\"line\">    List&lt;EchartsEntity&gt; echarts = new ArrayList&lt;EchartsEntity&gt;();</span><br><span class=\"line\">    // 自定义横坐标</span><br><span class=\"line\">    String[] xAxis = &#123; &quot;周一&quot;, &quot;周二&quot;, &quot;周三&quot;, &quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot;, &quot;周日&quot; &#125;;</span><br><span class=\"line\">    // 自定义各种类型的显示数据</span><br><span class=\"line\">    EchartsEntity entity1 = new EchartsEntity(&quot;邮件营销&quot;, &quot;line&quot;, Arrays</span><br><span class=\"line\">    .asList(120, 132, 101, 134, 90, 230, 210));</span><br><span class=\"line\">    EchartsEntity entity2 = new EchartsEntity(&quot;联盟广告&quot;, &quot;line&quot;, Arrays</span><br><span class=\"line\">    .asList(220, 182, 191, 234, 290, 330, 310));</span><br><span class=\"line\">    EchartsEntity entity3 = new EchartsEntity(&quot;视频广告&quot;, &quot;line&quot;, Arrays</span><br><span class=\"line\">    .asList(150, 232, 201, 154, 190, 330, 410));</span><br><span class=\"line\">    echarts.add(entity1);</span><br><span class=\"line\">    echarts.add(entity2);</span><br><span class=\"line\">    echarts.add(entity3);</span><br><span class=\"line\">    String[] legend = &#123; &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot; &#125;;</span><br><span class=\"line\">    resultDataMap = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">    resultDataMap.put(&quot;xAxis&quot;, xAxis);</span><br><span class=\"line\">    resultDataMap.put(&quot;series&quot;, echarts);</span><br><span class=\"line\">    resultDataMap.put(&quot;legend&quot;, legend);</span><br><span class=\"line\">    System.out.println(GsonUtil.getJSONString(resultDataMap));</span><br><span class=\"line\">    return &quot;json&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、EchartsEntity</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EchartsEntity &#123;</span><br><span class=\"line\">    public String name;</span><br><span class=\"line\">    public String type;</span><br><span class=\"line\">    public List&lt;?&gt; data;</span><br><span class=\"line\">    //此处省略get,set方法    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h1><p>在对应的strus的配置文件中把后端的resultDataMap 作为json对象返回到页面中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;package name=&quot;btbsta&quot; extends=&quot;base&quot; namespace=&quot;/btb/sta&quot; strict-method-invocation=&quot;false&quot;&gt;\t &lt;action name=&quot;fsta0010_*&quot; method=&quot;&#123;1&#125;&quot; class=&quot;fsta0010Action&quot;&gt;</span><br><span class=\"line\">\t \t&lt;result name=&quot;json&quot; type=&quot;json&quot;&gt;</span><br><span class=\"line\">\t\t \t\t&lt;param name=&quot;includeProperties&quot;&gt;resultDataMap.*&lt;/param&gt;</span><br><span class=\"line\">\t\t\t&lt;/result&gt;</span><br><span class=\"line\">\t &lt;/action&gt;</span><br><span class=\"line\">&lt;/package&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"示例结果\"><a href=\"#示例结果\" class=\"headerlink\" title=\"示例结果\"></a>示例结果</h1><p><img src=\"/images/plugins/echarts-2.png\" alt=\"avatar\"></p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>在有些情况下，为了和自己的系统的主题相适应，我们需要更改ecahrt默认的主题。</p>\n<h3 id=\"echarts-js自带\"><a href=\"#echarts-js自带\" class=\"headerlink\" title=\"echarts.js自带\"></a>echarts.js自带</h3><p>官方自带的主题有default，dark，light。这三种主题是不需要下载的。使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myChart = echarts.init(document.getElementById(&apos;line&apos;), &apos;light&apos;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"官网下载\"><a href=\"#官网下载\" class=\"headerlink\" title=\"官网下载\"></a>官网下载</h3><p>echarts中除了自带的三种样式之外，还提供了其他主题。使用的方法如下：</p>\n<p>1、在官网上下载对应的主题文件的js，例如macarons.js。</p>\n<p>2、在页面中引入js。</p>\n<p>3、在初始化echarts配置的时候，加入主题的名称即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myChart = echarts.init(document.getElementById(&apos;line&apos;), &apos;macarons&apos;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://echarts.baidu.com/echarts2/doc/example.html\" target=\"_blank\" rel=\"noopener\">echarts2.0版本的使用示例</a></p>\n"},{"title":"","text":"小程序分享转发实现小程序分享或转发有两种方式，一种是通过在页面中自定义按钮的形式，另外一种只需要在js中定义 onShareAppMessage 函数，页面右上角就会出现转发的按钮。详细文档请参阅微信官方文档微信转发API。 分享方式12345678910111213Page(&#123; onShareAppMessage: function (res) &#123; //menu 是来自右上角的转发，button是页面内的转发按钮。 if (res.from === &apos;button&apos;) &#123; // 来自页面内转发按钮 console.log(res.target) &#125; return &#123; title: &apos;自定义转发标题&apos;, //如不不写默认为小程序的名称 path: &apos;/page/index&apos; &#125; &#125;&#125;) 页面内按钮 首先在页面内定义一个按钮，设置open-type为share 1&lt;button open-type=&quot;share&quot;&gt;转发&lt;/button&gt; 分享内容静态动态参考文章 微信小程序 转发 微信小程序分享朋友圈的实现思路与解决办法","content":"<h1 id=\"小程序分享转发实现\"><a href=\"#小程序分享转发实现\" class=\"headerlink\" title=\"小程序分享转发实现\"></a>小程序分享转发实现</h1><p>小程序分享或转发有两种方式，一种是通过在页面中自定义按钮的形式，另外一种只需要在js中定义 onShareAppMessage 函数，页面右上角就会出现转发的按钮。详细文档请参阅微信官方文档<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/share.html#onshareappmessageoptions\" target=\"_blank\" rel=\"noopener\">微信转发API</a>。</p>\n<h2 id=\"分享方式\"><a href=\"#分享方式\" class=\"headerlink\" title=\"分享方式\"></a>分享方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  onShareAppMessage: function (res) &#123;</span><br><span class=\"line\">    //menu 是来自右上角的转发，button是页面内的转发按钮。</span><br><span class=\"line\">    if (res.from === &apos;button&apos;) &#123;</span><br><span class=\"line\">      // 来自页面内转发按钮</span><br><span class=\"line\">      console.log(res.target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      title: &apos;自定义转发标题&apos;, //如不不写默认为小程序的名称</span><br><span class=\"line\">      path: &apos;/page/index&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"页面内按钮\"><a href=\"#页面内按钮\" class=\"headerlink\" title=\"页面内按钮\"></a>页面内按钮</h2><ul>\n<li><p>首先在页面内定义一个按钮，设置open-type为share</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=&quot;share&quot;&gt;转发&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li></li>\n</ul>\n<h2 id=\"分享内容\"><a href=\"#分享内容\" class=\"headerlink\" title=\"分享内容\"></a>分享内容</h2><h3 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h3><h3 id=\"动态\"><a href=\"#动态\" class=\"headerlink\" title=\"动态\"></a>动态</h3><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://blog.csdn.net/xiaochun365/article/details/76546585\" target=\"_blank\" rel=\"noopener\">微信小程序 转发</a></li>\n<li><a href=\"https://www.cnblogs.com/till-the-end/p/8470557.html\" target=\"_blank\" rel=\"noopener\"><a href=\"https://www.cnblogs.com/till-the-end/p/8470557.html\" target=\"_blank\" rel=\"noopener\">微信小程序分享朋友圈的实现思路与解决办法</a></a></li>\n</ul>\n"},{"title":"","text":"npm常见问题rc-input-number导致install失败###【log】 12npm ERR! Unexpected end of input at 1:10970error shasum&quot;:&quot;c2ab41165bd3cf22077af7404e4b6a42df6c1b6e&quot;,&quot;tarball&quot;:&quot;https:/ ###【解决方案】 换cnpm 进行安装确认你安装了淘宝的cnpm 源没。 以上介绍了“ npm install antd 失败，怀疑是rc-input-number问题”的问题解答。","content":"<h1 id=\"npm常见问题\"><a href=\"#npm常见问题\" class=\"headerlink\" title=\"npm常见问题\"></a>npm常见问题</h1><h2 id=\"rc-input-number导致install失败\"><a href=\"#rc-input-number导致install失败\" class=\"headerlink\" title=\"rc-input-number导致install失败\"></a>rc-input-number导致install失败</h2><p>###【log】</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm ERR! Unexpected end of input at 1:10970</span><br><span class=\"line\">error shasum&quot;:&quot;c2ab41165bd3cf22077af7404e4b6a42df6c1b6e&quot;,&quot;tarball&quot;:&quot;https:/</span><br></pre></td></tr></table></figure>\n<p>###【解决方案】</p>\n<p>换cnpm 进行安装确认你安装了淘宝的cnpm 源没。<img src=\"http://image.codes51.com/Article/image/20170911/20170911004346_0781.jpg\" alt=\"img\"></p>\n<p>以上介绍了“ npm install antd 失败，怀疑是rc-input-number问题”的问题解答。</p>\n"},{"title":"","text":"Spring Boot学习单元测试模拟http请求MockServletContext web参数校验123456789101112131415@GetMapping(&quot;/savePerson&quot;) public String savePerson(@Valid Person person, BindingResult result)&#123; String message = &quot;&quot;; if(result.hasErrors())&#123; //list中需要指定具体的泛型，否则会编译保存，期望为Object类型但实际为ObjectError List&lt;ObjectError&gt; allErrors = result.getAllErrors(); for(ObjectError error : allErrors)&#123; message += error.getDefaultMessage()+&quot;\\n&quot;; &#125; &#125; if(message==&quot;&quot;)&#123; message = &quot;保存成功&quot;; &#125; return message; &#125; 1、xss威胁 过滤器12345678910111213@Componentpublic class MyFilterConfiguration &#123; public FilterRegistrationBean myFilterREgisteration()&#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter());//添加过滤器 ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;(); strings.add(&quot;/*&quot;); //这里必须为string类型的集合 registration.setUrlPatterns(strings);//设置过滤的路劲，/*为所有 return registration; &#125;&#125; 遇到的错误Data truncated for column修改了表的数据类型或者是长度，与表中原有的数据产生冲突，从而引发了错误。 【解决】删除表即可。 统一异常处理们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 当访问一个不存在的URL，或是修改处理内容，直接抛出异常，如： 1234@RequestMapping(&quot;/hello&quot;)public String hello() throws Exception &#123; throw new Exception(&quot;发生错误&quot;);&#125; 此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。 alt=默认的错误页面 统一异常处理虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。 下面我们以之前的Web应用例子为基础（Chapter3-1-2），进行统一异常处理的改造。 创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中 123456789101112131415@ControllerAdviceclass GlobalExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;; @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;, e); mav.addObject(&quot;url&quot;, req.getRequestURL()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; &#125;&#125; 实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;统一异常处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Error Handler&lt;/h1&gt; &lt;div th:text=&quot;$&#123;url&#125;&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;$&#123;exception.message&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动该应用，访问：http://localhost:8080/hello，可以看到如下错误提示页面。 alt=自定义的错误页面 通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。 返回JSON格式在上述例子中，通过@ControllerAdvice统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。 本质上，只需在@ExceptionHandler之后加入@ResponseBody，就能让处理函数return的内容转换为JSON格式。 下面以一个具体示例来实现返回JSON格式的异常处理。 创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据 12345678910111213public class ErrorInfo&lt;T&gt; &#123; public static final Integer OK = 0; public static final Integer ERROR = 100; private Integer code; private String message; private String url; private T data; // 省略getter和setter&#125; 创建一个自定义异常，用来实验捕获该异常，并返回json 1234567public class MyException extends Exception &#123; public MyException(String message) &#123; super(message); &#125; &#125; Controller中增加json映射，抛出MyException异常 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/json&quot;) public String json() throws MyException &#123; throw new MyException(&quot;发生错误2&quot;); &#125;&#125; 为MyException异常创建对应的处理 123456789101112131415@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = MyException.class) @ResponseBody public ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception &#123; ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;(); r.setMessage(e.getMessage()); r.setCode(ErrorInfo.ERROR); r.setData(&quot;Some Data&quot;); r.setUrl(req.getRequestURL().toString()); return r; &#125;&#125; 启动应用，访问：http://localhost:8080/json，可以得到如下返回内容： 123456&#123; code: 100， data: &quot;Some Data&quot;， message: &quot;发生错误2&quot;， url: &quot;http://localhost:8080/json&quot;&#125; 至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考Spring MVC的文档。 常见错误模板配置错误1org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field &apos;timestamp&apos; cannot be found on object of type &apos;java.util.HashMap&apos; - maybe not public? 原因是返回的模板页面 没有找到，所以会使用默认的默认页面，而在这个模板页面中是需要返回一个timestamp的。","content":"<h1 id=\"Spring-Boot学习\"><a href=\"#Spring-Boot学习\" class=\"headerlink\" title=\"Spring Boot学习\"></a>Spring Boot学习</h1><h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><h3 id=\"模拟http请求\"><a href=\"#模拟http请求\" class=\"headerlink\" title=\"模拟http请求\"></a>模拟http请求</h3><p><a href=\"https://docs.spring.io/spring-security/site/docs/current/reference/html/test-mockmvc.html\" target=\"_blank\" rel=\"noopener\">MockServletContext</a></p>\n<h2 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"web\"></a>web</h2><h3 id=\"参数校验\"><a href=\"#参数校验\" class=\"headerlink\" title=\"参数校验\"></a>参数校验</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/savePerson&quot;)</span><br><span class=\"line\">   public String savePerson(@Valid Person person, BindingResult result)&#123;</span><br><span class=\"line\">       String message = &quot;&quot;;</span><br><span class=\"line\">       if(result.hasErrors())&#123;</span><br><span class=\"line\">           //list中需要指定具体的泛型，否则会编译保存，期望为Object类型但实际为ObjectError</span><br><span class=\"line\">           List&lt;ObjectError&gt; allErrors  = result.getAllErrors();</span><br><span class=\"line\">           for(ObjectError error : allErrors)&#123;</span><br><span class=\"line\">               message += error.getDefaultMessage()+&quot;\\n&quot;;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if(message==&quot;&quot;)&#123;</span><br><span class=\"line\">           message = &quot;保存成功&quot;;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       return message;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>1、<a href=\"https://www.xncoding.com/2016/07/24/web/xss.html\" target=\"_blank\" rel=\"noopener\">xss威胁</a></p>\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class MyFilterConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public FilterRegistrationBean myFilterREgisteration()&#123;</span><br><span class=\"line\">        FilterRegistrationBean registration = new FilterRegistrationBean();</span><br><span class=\"line\">        registration.setFilter(new MyFilter());//添加过滤器</span><br><span class=\"line\">        ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">        strings.add(&quot;/*&quot;);</span><br><span class=\"line\">        //这里必须为string类型的集合</span><br><span class=\"line\">        registration.setUrlPatterns(strings);//设置过滤的路劲，/*为所有</span><br><span class=\"line\">        return registration;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遇到的错误\"><a href=\"#遇到的错误\" class=\"headerlink\" title=\"遇到的错误\"></a>遇到的错误</h2><h3 id=\"Data-truncated-for-column\"><a href=\"#Data-truncated-for-column\" class=\"headerlink\" title=\"Data truncated for column\"></a>Data truncated for column</h3><p>修改了表的数据类型或者是长度，与表中原有的数据产生冲突，从而引发了错误。</p>\n<p>【解决】删除表即可。</p>\n<h2 id=\"统一异常处理\"><a href=\"#统一异常处理\" class=\"headerlink\" title=\"统一异常处理\"></a>统一异常处理</h2><p>们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：<code>/error</code>，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。</p>\n<p>当访问一个不存在的URL，或是修改处理内容，直接抛出异常，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public String hello() throws Exception &#123;</span><br><span class=\"line\">    throw new Exception(&quot;发生错误&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。</p>\n<p><a href=\"http://blog.didispace.com/content/images/2016/04/241FA8A7-2493-44B9-A0A3-79849656074A.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://blog.didispace.com/content/images/2016/04/241FA8A7-2493-44B9-A0A3-79849656074A.png\" alt=\"alt=默认的错误页面\"></a>alt=默认的错误页面</p>\n<h2 id=\"统一异常处理-1\"><a href=\"#统一异常处理-1\" class=\"headerlink\" title=\"统一异常处理\"></a>统一异常处理</h2><p>虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。</p>\n<p>下面我们以之前的Web应用例子为基础（<a href=\"http://git.oschina.net/didispace/SpringBoot-Learning/tree/master/Chapter3-1-2\" target=\"_blank\" rel=\"noopener\">Chapter3-1-2</a>），进行统一异常处理的改造。</p>\n<ul>\n<li>创建全局异常处理类：通过使用<code>@ControllerAdvice</code>定义统一的异常处理类，而不是在每个Controller中逐个定义。<code>@ExceptionHandler</code>用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到<code>error.html</code>中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ControllerAdvice</span><br><span class=\"line\">class GlobalExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExceptionHandler(value = Exception.class)</span><br><span class=\"line\">    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123;</span><br><span class=\"line\">        ModelAndView mav = new ModelAndView();</span><br><span class=\"line\">        mav.addObject(&quot;exception&quot;, e);</span><br><span class=\"line\">        mav.addObject(&quot;url&quot;, req.getRequestURL());</span><br><span class=\"line\">        mav.setViewName(DEFAULT_ERROR_VIEW);</span><br><span class=\"line\">        return mav;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现<code>error.html</code>页面展示：在<code>templates</code>目录下创建<code>error.html</code>，将请求的URL和Exception对象的message输出。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head lang=&quot;en&quot;&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">    &lt;title&gt;统一异常处理&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;Error Handler&lt;/h1&gt;</span><br><span class=\"line\">    &lt;div th:text=&quot;$&#123;url&#125;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div th:text=&quot;$&#123;exception.message&#125;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>启动该应用，访问：<code>http://localhost:8080/hello</code>，可以看到如下错误提示页面。</p>\n<p><a href=\"http://blog.didispace.com/content/images/2016/05/8C9EACEE-9F7C-42F3-85D1-B5CAD746FA86.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://blog.didispace.com/content/images/2016/05/8C9EACEE-9F7C-42F3-85D1-B5CAD746FA86.png\" alt=\"alt=自定义的错误页面\"></a>alt=自定义的错误页面</p>\n<p><em>通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。</em></p>\n<h2 id=\"返回JSON格式\"><a href=\"#返回JSON格式\" class=\"headerlink\" title=\"返回JSON格式\"></a>返回JSON格式</h2><p>在上述例子中，通过<code>@ControllerAdvice</code>统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。</p>\n<p>本质上，只需在<code>@ExceptionHandler</code>之后加入<code>@ResponseBody</code>，就能让处理函数return的内容转换为JSON格式。</p>\n<p>下面以一个具体示例来实现返回JSON格式的异常处理。</p>\n<ul>\n<li>创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ErrorInfo&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static final Integer OK = 0;</span><br><span class=\"line\">    public static final Integer ERROR = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer code;</span><br><span class=\"line\">    private String message;</span><br><span class=\"line\">    private String url;</span><br><span class=\"line\">    private T data;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略getter和setter</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个自定义异常，用来实验捕获该异常，并返回json</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyException extends Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyException(String message) &#123;</span><br><span class=\"line\">        super(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Controller</code>中增加json映射，抛出<code>MyException</code>异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class HelloController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/json&quot;)</span><br><span class=\"line\">    public String json() throws MyException &#123;</span><br><span class=\"line\">        throw new MyException(&quot;发生错误2&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为<code>MyException</code>异常创建对应的处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ControllerAdvice</span><br><span class=\"line\">public class GlobalExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExceptionHandler(value = MyException.class)</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    public ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception &#123;</span><br><span class=\"line\">        ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;();</span><br><span class=\"line\">        r.setMessage(e.getMessage());</span><br><span class=\"line\">        r.setCode(ErrorInfo.ERROR);</span><br><span class=\"line\">        r.setData(&quot;Some Data&quot;);</span><br><span class=\"line\">        r.setUrl(req.getRequestURL().toString());</span><br><span class=\"line\">        return r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>启动应用，访问：<a href=\"http://localhost:8080/json%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BF%94%E5%9B%9E%E5%86%85%E5%AE%B9%EF%BC%9A\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/json，可以得到如下返回内容：</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    code: 100，</span><br><span class=\"line\">    data: &quot;Some Data&quot;，</span><br><span class=\"line\">    message: &quot;发生错误2&quot;，</span><br><span class=\"line\">    url: &quot;http://localhost:8080/json&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考Spring MVC的文档。</p>\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><h3 id=\"模板配置错误\"><a href=\"#模板配置错误\" class=\"headerlink\" title=\"模板配置错误\"></a>模板配置错误</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field &apos;timestamp&apos; cannot be found on object of type &apos;java.util.HashMap&apos; - maybe not public?</span><br></pre></td></tr></table></figure>\n<p>原因是返回的模板页面 没有找到，所以会使用默认的默认页面，而在这个模板页面中是需要返回一个timestamp的。</p>\n"},{"title":"","text":"SpringBoot ——属性配置文件 在SpringBoot中，在pom.xml中引入模块化的Starter POMs。其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。 application.porterties文件自定义属性基本使用在Springboot中，我们可能也需要定义一些自己的使用属性。可以在application.properties中使用如下方式 12com.cheryl.name = Cherylcom.cheryl.password = 123456 然后再实体类中，使用@ConfigurationProperties(prefix = “com.cheryl”)把当前前前缀下面的注解引入进来。 1234567@Component@ConfigurationProperties(prefix = &quot;com.cheryl&quot;)public class BlogProperties &#123; private String name; private String password; //此处省略get,set方法 &#125; 然后再控制器中使用 @Autowired把实体类注入到容器中，然后启动程序在浏览器中访问对应的路径即可。 123456789101112@RestController@RequestMapping(&quot;/blogPropertiesController&quot;)public class BlogPropertiesController &#123; @Autowired private BlogProperties blogProperties; @GetMapping(&quot;/info&quot;) public String blogInfo()&#123; return blogProperties.toString(); &#125;&#125; 参数间的引用在application.properties中的各个参数之间也可以直接引用来使用。使用‘${xxx}’的方式来引用定义过自定义属性，如下所示： 12com.cheryl.title = &quot;springboot技术实战&quot;com.cheryl.desc = $&#123;com.cheryl.name&#125;正在学习《$&#123;com.cheryl.title&#125;》 最后该值为Cheryl正在学习《springboot技术实战》 生成随机数在有一些情况中，我们希望一些属性使用随机值而不是一个固定的值，比如密钥等。Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 12345678910# 随机字符串（32位的随机字符串）com.cheryl.value=$&#123;random.value&#125;# 随机intcom.cheryl.number=$&#123;random.int&#125;# 随机longcom.cheryl.bignumber=$&#123;random.long&#125;# 10以内的随机数com.cheryl.test1=$&#123;random.int(10)&#125;# 10-20的随机数com.cheryl.test2=$&#123;random.int[10,20]&#125; 多环境配置我们在开发Spring Boot应用时，通常会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要修改配置文件的话，比较繁琐，而且容易出错。 一般来说多环境的配置使用各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外。 在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-test.properties：测试环境 application-prod.properties：生产环境 至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。 如：spring.profiles.active=test就会加载application-test.properties配置文件内容 下面，以不同环境配置不同的服务端口为例，进行样例实验。 针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties 在这三个文件均都设置不同的server.port属性，如：dev环境设置为82，test环境设置为83，prod环境设置为80 application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置 测试不同配置的加载 执行java -jar xxx.jar，可以观察到服务端口被设置为1111，也就是默认的开发环境（dev） 执行java -jar xxx.jar --spring.profiles.active=test，可以观察到服务端口被设置为2222，也就是测试环境的配置（test） 执行java -jar xxx.jar --spring.profiles.active=prod，可以观察到服务端口被设置为3333，也就是生产环境的配置（prod） 按照上面的实验，可以如下总结多环境的配置思路： application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置 application-{profile}.properties中配置各个环境不同的内容 通过命令行方式去激活不同环境的配置","content":"<h1 id=\"SpringBoot-——属性配置文件\"><a href=\"#SpringBoot-——属性配置文件\" class=\"headerlink\" title=\"SpringBoot ——属性配置文件\"></a>SpringBoot ——属性配置文件</h1><blockquote>\n<p>在SpringBoot中，在<code>pom.xml</code>中引入模块化的<code>Starter POMs</code>。其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在<code>application.properties</code>中完成一些属性配置就能开启各模块的应用。</p>\n</blockquote>\n<h2 id=\"application-porterties文件\"><a href=\"#application-porterties文件\" class=\"headerlink\" title=\"application.porterties文件\"></a>application.porterties文件</h2><h3 id=\"自定义属性\"><a href=\"#自定义属性\" class=\"headerlink\" title=\"自定义属性\"></a>自定义属性</h3><h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><p>在Springboot中，我们可能也需要定义一些自己的使用属性。可以在application.properties中使用如下方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.cheryl.name = Cheryl</span><br><span class=\"line\">com.cheryl.password = 123456</span><br></pre></td></tr></table></figure>\n<p>然后再实体类中，使用@ConfigurationProperties(prefix = “com.cheryl”)把当前前前缀下面的注解引入进来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;com.cheryl&quot;)</span><br><span class=\"line\">public class BlogProperties &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String password;</span><br><span class=\"line\">    //此处省略get,set方法</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>然后再控制器中使用 @Autowired把实体类注入到容器中，然后启动程序在浏览器中访问对应的路径即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/blogPropertiesController&quot;)</span><br><span class=\"line\">public class BlogPropertiesController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private BlogProperties blogProperties;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @GetMapping(&quot;/info&quot;)</span><br><span class=\"line\">    public String blogInfo()&#123;</span><br><span class=\"line\">        return blogProperties.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"参数间的引用\"><a href=\"#参数间的引用\" class=\"headerlink\" title=\"参数间的引用\"></a>参数间的引用</h4><p>在<code>application.properties</code>中的各个参数之间也可以直接引用来使用。使用‘${xxx}’的方式来引用定义过自定义属性，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.cheryl.title = &quot;springboot技术实战&quot;</span><br><span class=\"line\">com.cheryl.desc = $&#123;com.cheryl.name&#125;正在学习《$&#123;com.cheryl.title&#125;》</span><br></pre></td></tr></table></figure>\n<p>最后该值为Cheryl正在学习《springboot技术实战》</p>\n<h4 id=\"生成随机数\"><a href=\"#生成随机数\" class=\"headerlink\" title=\"生成随机数\"></a>生成随机数</h4><p>在有一些情况中，我们希望一些属性使用随机值而不是一个固定的值，比如密钥等。Spring Boot的属性配置文件中可以通过<code>${random}</code>来产生int值、long值或者string字符串，来支持属性的随机值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 随机字符串（32位的随机字符串）</span><br><span class=\"line\">com.cheryl.value=$&#123;random.value&#125;</span><br><span class=\"line\"># 随机int</span><br><span class=\"line\">com.cheryl.number=$&#123;random.int&#125;</span><br><span class=\"line\"># 随机long</span><br><span class=\"line\">com.cheryl.bignumber=$&#123;random.long&#125;</span><br><span class=\"line\"># 10以内的随机数</span><br><span class=\"line\">com.cheryl.test1=$&#123;random.int(10)&#125;</span><br><span class=\"line\"># 10-20的随机数</span><br><span class=\"line\">com.cheryl.test2=$&#123;random.int[10,20]&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多环境配置\"><a href=\"#多环境配置\" class=\"headerlink\" title=\"多环境配置\"></a>多环境配置</h2><p>我们在开发Spring Boot应用时，通常会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要修改配置文件的话，比较繁琐，而且容易出错。</p>\n<p>一般来说多环境的配置使用各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外。</p>\n<p>在Spring Boot中多环境配置文件名需要满足<code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识，比如：</p>\n<ul>\n<li><code>application-dev.properties</code>：开发环境</li>\n<li><code>application-test.properties</code>：测试环境</li>\n<li><code>application-prod.properties</code>：生产环境</li>\n</ul>\n<p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>{profile}</code>值。</p>\n<p>如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容</p>\n<p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p>\n<ul>\n<li>针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></li>\n<li>在这三个文件均都设置不同的<code>server.port</code>属性，如：dev环境设置为82，test环境设置为83，prod环境设置为80</li>\n<li>application.properties中设置<code>spring.profiles.active=dev</code>，就是说默认以dev环境设置</li>\n<li>测试不同配置的加载<ul>\n<li>执行<code>java -jar xxx.jar</code>，可以观察到服务端口被设置为<code>1111</code>，也就是默认的开发环境（dev）</li>\n<li>执行<code>java -jar xxx.jar --spring.profiles.active=test</code>，可以观察到服务端口被设置为<code>2222</code>，也就是测试环境的配置（test）</li>\n<li>执行<code>java -jar xxx.jar --spring.profiles.active=prod</code>，可以观察到服务端口被设置为<code>3333</code>，也就是生产环境的配置（prod）</li>\n</ul>\n</li>\n</ul>\n<p>按照上面的实验，可以如下总结多环境的配置思路：</p>\n<ul>\n<li><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</li>\n<li><code>application-{profile}.properties</code>中配置各个环境不同的内容</li>\n<li>通过命令行方式去激活不同环境的配置</li>\n</ul>\n"},{"title":"","text":"spring-data-jpa自定义ID的生成策略如何指定id策略在JPA中，我们是通过@id和@GeneratedValue来指定id主键和id策略的，比如： 1234@Id@GeneratedValue(strategy = GenerationType.AUTO)@Column(name = &quot;id&quot;)private String id; 这样也就指定了id和生成id所使用的策略，那么JPA提供了那些策略呢？ JPA提供的4种策略从@GeneratedValue源码里可以看到，strategy属性是由GenerationType指定的，而在GenerationType中定义了四种策略： TABLE：使用一个特定的数据库表格来保存主键。 SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。 IDENTITY：主键由数据库自动生成（主要是自动增长型） AUTO：主键由程序控制(也是默认的,在指定主键时，如果不指定主键生成策略，默认为AUTO) 这些策略也不是所有数据库都支持的，具体情况如下： 策略\\数据库 mysql oracle postgreSQL kingbase TABLE 支持 支持 支持 支持 SEQUENCE 不支持 支持 支持 支持 IDENTITY 支持 不支持 支持 支持 AUTO 支持 支持 支持 支持 在@GeneratedValue 中还有一个generator属性 Hibernate拓展id策略当然，很多时候，这么几种策略并不够用，这里hibernate也拓展了JPA的id策略，我们可以在org.hibernate.id.IdentifierGeneratorFactory中看到，主要提供了这么些策略： native: 对于oracle采用Sequence方式，对于MySQL和SQL Server采用identity(自增主键生成机制)，native就是将主键的生成工作交由数据库完成，hibernate不管(很常用)。 uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大(字符串类型)。 hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key,默认字段为Integer类型，名称是next_hi(比较少用)。 assigned: 在插入数据的时候主键由程序处理(很常用)，这是generator元素没有指定时的默认生成策略。等同于JPA中的AUTO。 identity: 使用SQL Server和MySQL的自增字段，这个方法不能放到Oracle中，Oracle不支持自增字段，要设定sequence(MySQL和SQL Server中很常用)。等同于JPA中的IDENTITY。 select: 使用触发器生成主键(主要用于早期的数据库主键生成机制，少用)。 sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持Sequence的数据库，如Oracle(比较少用)。 increment: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 foreign: 使用另外一个相关联的对象的主键。通常和联合起来使用。 guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 uuid.hex: 看uuid，建议用uuid替换。 sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 。 具体使用就是多了一个@GenericGenerator注解，指定自定义名称以及策略，然后在@GeneratedValue中使用该策略，比如： 1234@Id@GeneratedValue(generator = &quot;comnIdStrategy&quot;)@GenericGenerator(name = &quot;comnIdStrategy&quot;, strategy = &quot;uuid&quot;)private String id; 使用自定义的id策略hibernate 提供一种实现自定义id策略的接口IdentifierGenerator（位于org.hibernate.id中）。因此在生成自定义策略时，我们只需实现一下IdentifierGenerator接口，以及对应的generate方法即可： 12345678public class ExpId implements IdentifierGenerator&#123; ... @Override public Serializable generate(SessionImplementor sessionImplementor, Object o) throws HibernateException &#123; String date = String.valueOf(new Date().getTime()); return &quot;exp&quot; + date+&quot;_&quot;+generateRandom(); &#125;&#125; 然后对对应的实体类的某个字段上面使用该策略即可，@GenericGenerator注解的strategy属性上说了，使用非默认策略的时候，需要使用全类名，即： 12345@Id@GeneratedValue(generator = &quot;expIdStrategy&quot;)@GenericGenerator(name = &quot;expIdStrategy&quot;, strategy = &quot;com.cheryl.learn.idworker.ExpId&quot;)@Column(name = &quot;id&quot;)private String id; 使用测试方法测试，可以看到在数据库中添加的数据的id是使用我们定义策略生成的。| id|address |balance |gender |name |password || ———– | —— | —— | ———- | ——– |———||exp1524189929776_13653 |山西太原| 5000.5| 男 |张三丰 |123456||exp1524189929853_22297 |山西晋中| 2000.1| 男 |李四 |123456|","content":"<h1 id=\"spring-data-jpa\"><a href=\"#spring-data-jpa\" class=\"headerlink\" title=\"spring-data-jpa\"></a>spring-data-jpa</h1><h2 id=\"自定义ID的生成策略\"><a href=\"#自定义ID的生成策略\" class=\"headerlink\" title=\"自定义ID的生成策略\"></a>自定义ID的生成策略</h2><h3 id=\"如何指定id策略\"><a href=\"#如何指定id策略\" class=\"headerlink\" title=\"如何指定id策略\"></a>如何指定id策略</h3><p>在JPA中，我们是通过<code>@id</code>和<code>@GeneratedValue</code>来指定id主键和id策略的，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Id</span><br><span class=\"line\">@GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class=\"line\">@Column(name = &quot;id&quot;)</span><br><span class=\"line\">private String id;</span><br></pre></td></tr></table></figure>\n<p>这样也就指定了id和生成id所使用的策略，那么JPA提供了那些策略呢？</p>\n<h3 id=\"JPA提供的4种策略\"><a href=\"#JPA提供的4种策略\" class=\"headerlink\" title=\"JPA提供的4种策略\"></a>JPA提供的4种策略</h3><p>从<code>@GeneratedValue</code>源码里可以看到，<code>strategy</code>属性是由<code>GenerationType</code>指定的，而在<code>GenerationType</code>中定义了四种策略： </p>\n<ul>\n<li><strong>TABLE</strong>：使用一个特定的数据库表格来保存主键。 </li>\n<li><strong>SEQUENCE</strong>：根据底层数据库的序列来生成主键，条件是数据库支持序列。 </li>\n<li><strong>IDENTITY</strong>：主键由数据库自动生成（主要是自动增长型）</li>\n<li><p><strong>AUTO</strong>：主键由程序控制(也是默认的,在指定主键时，如果不指定主键生成策略，默认为AUTO) </p>\n<p>这些策略也不是所有数据库都支持的，具体情况如下：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>策略\\数据库</th>\n<th>mysql</th>\n<th>oracle</th>\n<th>postgreSQL</th>\n<th>kingbase</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TABLE</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>SEQUENCE</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>IDENTITY</td>\n<td>支持</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>AUTO</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<p>在<code>@GeneratedValue</code> 中还有一个generator属性</p>\n<h3 id=\"Hibernate拓展id策略\"><a href=\"#Hibernate拓展id策略\" class=\"headerlink\" title=\"Hibernate拓展id策略\"></a>Hibernate拓展id策略</h3><p>当然，很多时候，这么几种策略并不够用，这里hibernate也拓展了JPA的id策略，我们可以在<code>org.hibernate.id.IdentifierGeneratorFactory</code>中看到，主要提供了这么些策略： </p>\n<ol>\n<li><strong>native</strong>: 对于oracle采用Sequence方式，对于MySQL和SQL Server采用identity(自增主键生成机制)，native就是将主键的生成工作交由数据库完成，hibernate不管(很常用)。 </li>\n<li><strong>uuid</strong>: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大(字符串类型)。 </li>\n<li><strong>hilo</strong>: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key,默认字段为Integer类型，名称是next_hi(比较少用)。 </li>\n<li><strong>assigned</strong>: 在插入数据的时候主键由程序处理(很常用)，这是<code>generator</code>元素没有指定时的默认生成策略。等同于JPA中的AUTO。 </li>\n<li><strong>identity</strong>: 使用SQL Server和MySQL的自增字段，这个方法不能放到Oracle中，Oracle不支持自增字段，要设定sequence(MySQL和SQL Server中很常用)。等同于JPA中的IDENTITY。 </li>\n<li><strong>select</strong>: 使用触发器生成主键(主要用于早期的数据库主键生成机制，少用)。 </li>\n<li><strong>sequence</strong>: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 </li>\n<li><strong>seqhilo</strong>: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持Sequence的数据库，如Oracle(比较少用)。 </li>\n<li><strong>increment</strong>: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 </li>\n<li><strong>foreign</strong>: 使用另外一个相关联的对象的主键。通常和联合起来使用。 </li>\n<li><strong>guid</strong>: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 </li>\n<li><strong>uuid.hex</strong>: 看uuid，建议用uuid替换。 </li>\n<li><strong>sequence-identity</strong>: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 。 </li>\n</ol>\n<p>具体使用就是多了一个<code>@GenericGenerator</code>注解，指定自定义名称以及策略，然后在<code>@GeneratedValue</code>中使用该策略，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Id</span><br><span class=\"line\">@GeneratedValue(generator  = &quot;comnIdStrategy&quot;)</span><br><span class=\"line\">@GenericGenerator(name = &quot;comnIdStrategy&quot;, strategy = &quot;uuid&quot;)</span><br><span class=\"line\">private String id;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用自定义的id策略\"><a href=\"#使用自定义的id策略\" class=\"headerlink\" title=\"使用自定义的id策略\"></a>使用自定义的id策略</h3><p>hibernate 提供一种实现自定义id策略的接口<code>IdentifierGenerator</code>（位于org.hibernate.id中）。因此在生成自定义策略时，我们只需实现一下IdentifierGenerator接口，以及对应的generate方法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ExpId implements IdentifierGenerator&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">    public Serializable generate(SessionImplementor sessionImplementor, Object o) throws HibernateException &#123;</span><br><span class=\"line\">        String date = String.valueOf(new Date().getTime());</span><br><span class=\"line\">        return &quot;exp&quot; + date+&quot;_&quot;+generateRandom();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后对对应的实体类的某个字段上面使用该策略即可，<code>@GenericGenerator</code>注解的<code>strategy</code>属性上说了，使用非默认策略的时候，需要使用全类名，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Id</span><br><span class=\"line\">@GeneratedValue(generator  = &quot;expIdStrategy&quot;)</span><br><span class=\"line\">@GenericGenerator(name = &quot;expIdStrategy&quot;, strategy = &quot;com.cheryl.learn.idworker.ExpId&quot;)</span><br><span class=\"line\">@Column(name = &quot;id&quot;)</span><br><span class=\"line\">private String id;</span><br></pre></td></tr></table></figure>\n<p>使用测试方法测试，可以看到在数据库中添加的数据的id是使用我们定义策略生成的。<br>|    id|address    |balance    |gender     |name     |password     |<br>| ———– | —— | —— | ———- | ——– |———|<br>|exp1524189929776_13653    |山西太原|    5000.5|    男    |张三丰    |123456|<br>|exp1524189929853_22297    |山西晋中|    2000.1|    男    |李四    |123456|</p>\n"},{"title":"","text":"# spring-boot restful与集成测试 @Controller：修饰class，用来创建处理http请求的对象 @RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 @RequestMapping：配置url映射 下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。 RESTful API具体设计如下： 使用Swagger生成api","content":"<h1 id=\"spring-boot-restful与集成测试\"><a href=\"#spring-boot-restful与集成测试\" class=\"headerlink\" title=\"# spring-boot restful与集成测试\"></a># spring-boot restful与集成测试</h1><ul>\n<li><code>@Controller</code>：修饰class，用来创建处理http请求的对象</li>\n<li><code>@RestController</code>：Spring4之后加入的注解，原来在<code>@Controller</code>中返回json需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式。</li>\n<li><code>@RequestMapping</code>：配置url映射</li>\n</ul>\n<p>下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。</p>\n<p><strong>RESTful API具体设计如下：</strong></p>\n<p><a href=\"http://blog.didispace.com/content/images/posts/springbootrestfulapi-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://blog.didispace.com/content/images/posts/springbootrestfulapi-1.png\" alt=\"img\"></a></p>\n<h2 id=\"使用Swagger生成api\"><a href=\"#使用Swagger生成api\" class=\"headerlink\" title=\"使用Swagger生成api\"></a>使用Swagger生成api</h2>"},{"title":"","text":"JDBC Template 的使用数据源配置在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。 首先，为了连接数据库需要引入jdbc支持，在pom.xml中引入如下配置： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 嵌入式数据库支持嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。 比如，我们可以在pom.xml中引入如下配置使用HSQL 12345&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 连接生产数据源以MySQL数据库为例，先引入MySQL连接的依赖包，在pom.xml中加入： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 在src/main/resources/application.properties中配置数据源信息 1234spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=dbuserspring.datasource.password=dbpassspring.datasource.driver-class-name=com.mysql.jdbc.Driver 连接JNDI数据源当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。 1spring.datasource.jndi-name=java:jboss/datasources/customers 使用JDBCTemplate在数据库中创建一张User表（id，name,age）,其中id设置为自增长类型的。 创建一个UserService接口类，实现基本的增，删，改，查方法： 123456789101112131415161718192021222324public interface UserService&#123; /** * 新增一个用户 * @param name * @param age */ void create(String name, Integer age); /** * 根据name删除一个用户高 * @param name */ void deleteByName(String name); /** * 获取用户总量 */ Integer getAllUsers(); /** * 删除所有用户 */ void deleteAllUsers();&#125; 通过JdbcTemplate实现UserService中定义的数据访问操作创建对应的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 创建用户 * @param name * @param age */ @Override public void create(String name, Integer age) &#123; jdbcTemplate.update(&quot;insert into user(name,age) values(?,?)&quot;,name,age); &#125; /** * 根据名字删除用户 * @param name */ @Override public void deleteByName(String name) &#123; jdbcTemplate.update(&quot;delete from user where name = ? &quot;,name); &#125; /** * 获取所有用户 * @return */ @Override public Integer getAllUsers() &#123; return jdbcTemplate.queryForObject(&quot;select count(1) from user&quot;,Integer.class); &#125; /** * 删除用户 */ @Override public void deleteAllUsers() &#123; jdbcTemplate.update(&quot;delete from user&quot;); &#125;&#125; 创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。 12345678910111213141516171819202122232425262728@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserServiceTest &#123; @Autowired private UserService userService; @Before public void setUp() &#123; // 准备，清空user表 userService.deleteAllUsers(); &#125; @Test public void test()&#123; userService.create(&quot;张三&quot;,20); userService.create(&quot;李四&quot;,10); userService.create(&quot;王五&quot;,30); userService.create(&quot;赵六&quot;,42); userService.create(&quot;孙二&quot;,66); // 查数据库，应该有5个用户 Assert.assertEquals(5, userService.getAllUsers().intValue()); userService.deleteByName(&quot;张三&quot;); // 查数据库，应该有5个用户 Assert.assertEquals(4, userService.getAllUsers().intValue()); &#125;&#125; 其余详细的操作见jdbcTemplateApi","content":"<h1 id=\"JDBC-Template-的使用\"><a href=\"#JDBC-Template-的使用\" class=\"headerlink\" title=\"JDBC Template 的使用\"></a>JDBC Template 的使用</h1><h2 id=\"数据源配置\"><a href=\"#数据源配置\" class=\"headerlink\" title=\"数据源配置\"></a>数据源配置</h2><p>在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。</p>\n<p>首先，为了连接数据库需要引入jdbc支持，在<code>pom.xml</code>中引入如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"嵌入式数据库支持\"><a href=\"#嵌入式数据库支持\" class=\"headerlink\" title=\"嵌入式数据库支持\"></a>嵌入式数据库支持</h4><p>嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。</p>\n<p>比如，我们可以在<code>pom.xml</code>中引入如下配置使用HSQL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接生产数据源\"><a href=\"#连接生产数据源\" class=\"headerlink\" title=\"连接生产数据源\"></a>连接生产数据源</h4><p>以MySQL数据库为例，先引入MySQL连接的依赖包，在<code>pom.xml</code>中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>在<code>src/main/resources/application.properties</code>中配置数据源信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.datasource.url=jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">spring.datasource.username=dbuser</span><br><span class=\"line\">spring.datasource.password=dbpass</span><br><span class=\"line\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接JNDI数据源\"><a href=\"#连接JNDI数据源\" class=\"headerlink\" title=\"连接JNDI数据源\"></a>连接JNDI数据源</h4><p>当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.datasource.jndi-name=java:jboss/datasources/customers</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用JDBCTemplate\"><a href=\"#使用JDBCTemplate\" class=\"headerlink\" title=\"使用JDBCTemplate\"></a>使用JDBCTemplate</h2><p>在数据库中创建一张User表（id，name,age）,其中id设置为自增长类型的。</p>\n<p>创建一个UserService接口类，实现基本的增，删，改，查方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface UserService&#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 新增一个用户</span><br><span class=\"line\">     * @param name</span><br><span class=\"line\">     * @param age</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void create(String name, Integer age);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 根据name删除一个用户高</span><br><span class=\"line\">     * @param name</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void deleteByName(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取用户总量</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Integer getAllUsers();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 删除所有用户</span><br><span class=\"line\">     */</span><br><span class=\"line\">    void deleteAllUsers();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过JdbcTemplate实现UserService中定义的数据访问操作创建对应的实现类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class UserServiceImpl implements UserService&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private JdbcTemplate jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 创建用户</span><br><span class=\"line\">     * @param name</span><br><span class=\"line\">     * @param age</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void create(String name, Integer age) &#123;</span><br><span class=\"line\">        jdbcTemplate.update(&quot;insert into user(name,age) values(?,?)&quot;,name,age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 根据名字删除用户</span><br><span class=\"line\">     * @param name</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void deleteByName(String name) &#123;</span><br><span class=\"line\">        jdbcTemplate.update(&quot;delete from user where name = ? &quot;,name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取所有用户</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Integer getAllUsers() &#123;</span><br><span class=\"line\">       return jdbcTemplate.queryForObject(&quot;select count(1) from user&quot;,Integer.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 删除用户</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void deleteAllUsers() &#123;</span><br><span class=\"line\">        jdbcTemplate.update(&quot;delete from user&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class UserServiceTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Before</span><br><span class=\"line\">    public void setUp() &#123;</span><br><span class=\"line\">        // 准备，清空user表</span><br><span class=\"line\">        userService.deleteAllUsers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test()&#123;</span><br><span class=\"line\">        userService.create(&quot;张三&quot;,20);</span><br><span class=\"line\">        userService.create(&quot;李四&quot;,10);</span><br><span class=\"line\">        userService.create(&quot;王五&quot;,30);</span><br><span class=\"line\">        userService.create(&quot;赵六&quot;,42);</span><br><span class=\"line\">        userService.create(&quot;孙二&quot;,66);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 查数据库，应该有5个用户</span><br><span class=\"line\">        Assert.assertEquals(5, userService.getAllUsers().intValue());</span><br><span class=\"line\">        userService.deleteByName(&quot;张三&quot;);</span><br><span class=\"line\">        // 查数据库，应该有5个用户</span><br><span class=\"line\">        Assert.assertEquals(4, userService.getAllUsers().intValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其余详细的操作见<a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html\" target=\"_blank\" rel=\"noopener\">jdbcTemplateApi</a></p>\n"},{"title":"实时视屏播放的简单实现","text":"实时视屏播放的简单实现 通过使用nginx搭建一个简单的服务器，使用ffmpeg推送rtmp实时流，利用video标签实现可以在web端和手机端的浏览器中进行直播。 Windows下面搭建基于rtmp的服务器硬件环境操作系统：windows7旗舰版 处 理 器：Intel(R) Core(TM)i5-5200 CPU @2.20GHz 2.20 GHz 系统内存： 8GB 系统类型：64位操作系统 软件环境及配置 下载 nginx 1.7.11.3 Gryphon，然后解压到对应的目录，此处为D:\\Program Files；下载链接-Gryphon.zip 将解压后的目录名:nginx 1.7.11.3 Gryphon改成:nginx-1.7.11.3-Gryphon ​ 下载服务器状态检查程序 stat.xsl 下载地址 将nginx-rtmp-module-master.zip解压后复制到目录:nginx-1.7.11.3-Gryphon中。 保证stat.xls的目录为:nginx-1.7.11.3-Gryphon\\nginx-rtmp-module\\stat.xsl 修改conf\\nginx-win.conf 配置文件。 Nginx可以支持多虚机配置，如果是一个ip或域名多虚机的情况，就是要不同的虚机对应不同的端口服务，而如果是多ip或域名一个虚机的情况，则又不一样。这里的实际情况就是，80分别对应一个http协议的虚机，1935对应一个rtmp协议的虚机。 添加rtmp服务。 1234567891011121314151617181920rtmp &#123; server &#123; listen 1935; chunk_size 4000; application hls&#123; live on ; #启用rtmp直播 #地址为rtmp://[server]:[rtmp_port]/[app]/[stream] hls on ; #启用hls直播 #地址为地址为http://[server]:[http_port]/[app]/[stream].m3u8 hls_path html/hls; #此处hls需手动在html文件夹下面创建，否则程序会报错 hls_fragment 5s; recorder rec &#123; #启用录制 record all manual; #手动控制录制启停 record_suffix _rec.flv; record_path nginx-rtmp-module/tmp/rec/; #录制保存地址 record_unique on; &#125; &#125; &#125;&#125; 配置http server 12345678910111213141516171819202122server &#123; listen 80; # server_name localhost; location /stat &#123; # rtmp_stat all; # rtmp_stat_stylesheet stat.xls; #&#125; #location /stat.xls &#123; # root nginx-rtmp-module/; #&#125; #location /control &#123; # rtmp_control all; #&#125; location /hls &#123; # Serve HLS fragments types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root html; expires -1; &#125; 启动服务器 在nginx.exe所在的文件夹，按住shift+右键，选中在此处打开命令窗口，进入windows的cmd。输入以下命令启动nginx服务： 1nginx.exe -c conf\\nginx-win-.conf . 启动结果 直接在浏览器里输入127.0.0.1就可以进入浏览器的欢迎界面 ubuntu搭建推流服务器Nginx+rtmp 提供rtmp直播源在搭建好基于rtmp的服务器之后，需要提供rtmp直播源。这里我们使用的香港卫视的rtmp直播源。根据nginx.conf中的hls_path配置，下面这个命令会向本地的D:\\Program Files\\nginx-1.7.11.3-Gryphon\\html\\hls下面写入ts片段和m3u8文件。 1ffmpeg -re -analyzeduration 8000 -probesize 200000 -i &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot; -strict -2 -bsf:a aac_adtstoasc -c copy -flvflags aac_seq_header_detect -f flv rtmp://localhost/hls/mystream 注意 1、这里提供rtmp源的机器不一定和nginx在同一台物理主机上，可以是网络上的另一台机器，只要保证它能与nginx所在的主机建立tcp链接即可。（也就是nginx主机需要开启rtmp服务的监听端口，这里是1935，当然你也可以修改为其他的端口。） 2、ffmpeg下载地址 在网页中展示视屏在nginx-1.7.11.3-Gryphon/html目录下面创建一个live.html。 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://vjs.zencdn.net/5.10/video-js.css&quot;&gt;&lt;/head&gt; &lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls autoplay=true&gt; &lt;source src=&quot;hls/mystream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt; &lt;script src=&quot;http://vjs.zencdn.net/5.10/video.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/videojs-contrib-hls/5.14.1/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt; &lt;/script&gt; &lt;script&gt; var player = videojs(&apos;example-video&apos;); player.play(); &lt;/script&gt;&lt;/html&gt; 如果只是用video标签是无法播放.m3u8的视屏文件的，需要引入videojs-contrib-hls.js。videojs-contrib-hls支持一堆HLS功能，详情参考[https://www.cnblogs.com/tinywan/p/6692098.html] web端运行效果 手机端运行效果 手机端如果与web可以在同一个网络环境中，那么输入对应本机ip地址也是可以查看的，并且支持横屏、竖屏的切换。 其他 防火墙打开了1935 tcp端口，rtmp视屏还是不能播放， 可以用下面的命令暂停，systemctl stop firewalld.service [参考博文] 1、使用Nginx-rtmp-module搭建hls直播 2、 海康NVR设备RTSP协议转RTMP协议","content":"<h1 id=\"实时视屏播放的简单实现\"><a href=\"#实时视屏播放的简单实现\" class=\"headerlink\" title=\"实时视屏播放的简单实现\"></a>实时视屏播放的简单实现</h1><blockquote>\n<p>通过使用nginx搭建一个简单的服务器，使用ffmpeg推送rtmp实时流，利用video标签实现可以在web端和手机端的浏览器中进行直播。</p>\n</blockquote>\n<h2 id=\"Windows下面搭建基于rtmp的服务器\"><a href=\"#Windows下面搭建基于rtmp的服务器\" class=\"headerlink\" title=\"Windows下面搭建基于rtmp的服务器\"></a>Windows下面搭建基于rtmp的服务器</h2><h3 id=\"硬件环境\"><a href=\"#硬件环境\" class=\"headerlink\" title=\"硬件环境\"></a>硬件环境</h3><p>操作系统：windows7旗舰版 </p>\n<p>处  理  器：Intel(R) Core(TM)i5-5200 CPU @2.20GHz 2.20 GHz</p>\n<p>系统内存： 8GB</p>\n<p>系统类型：64位操作系统</p>\n<h3 id=\"软件环境及配置\"><a href=\"#软件环境及配置\" class=\"headerlink\" title=\"软件环境及配置\"></a>软件环境及配置</h3><ol>\n<li><p>下载 nginx 1.7.11.3 Gryphon，然后解压到对应的目录，此处为D:\\Program Files；<br><a href=\"http://nginx-win.ecsds.eu/download/nginx%201.7.11.3%20Gryphon.zip\" target=\"_blank\" rel=\"noopener\">下载链接-Gryphon.zip</a></p>\n<blockquote>\n<p>将解压后的目录名:nginx 1.7.11.3 Gryphon改成:nginx-1.7.11.3-Gryphon</p>\n</blockquote>\n<p>​</p>\n</li>\n<li><p>下载服务器状态检查程序 stat.xsl</p>\n<p><a href=\"https://github.com/arut/nginx-rtmp-module/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</li>\n<li><p>将nginx-rtmp-module-master.zip解压后复制到目录:nginx-1.7.11.3-Gryphon中。</p>\n<blockquote>\n<p> 保证stat.xls的目录为:nginx-1.7.11.3-Gryphon\\nginx-rtmp-module\\stat.xsl</p>\n</blockquote>\n</li>\n<li><p>修改conf\\nginx-win.conf 配置文件。</p>\n<p>Nginx可以支持多虚机配置，如果是一个ip或域名多虚机的情况，就是要不同的虚机对应不同的端口服务，而如果是多ip或域名一个虚机的情况，则又不一样。这里的实际情况就是，80分别对应一个http协议的虚机，1935对应一个rtmp协议的虚机。</p>\n<ul>\n<li>添加rtmp服务。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\"> server &#123;</span><br><span class=\"line\">     listen 1935;</span><br><span class=\"line\">     chunk_size 4000;</span><br><span class=\"line\">     application hls&#123;</span><br><span class=\"line\">         live on ; #启用rtmp直播</span><br><span class=\"line\">                   #地址为rtmp://[server]:[rtmp_port]/[app]/[stream]</span><br><span class=\"line\">         hls on ;  #启用hls直播</span><br><span class=\"line\">                   #地址为地址为http://[server]:[http_port]/[app]/[stream].m3u8</span><br><span class=\"line\">         hls_path html/hls; #此处hls需手动在html文件夹下面创建，否则程序会报错</span><br><span class=\"line\">         hls_fragment 5s;</span><br><span class=\"line\">         recorder rec &#123; #启用录制</span><br><span class=\"line\">         \trecord all manual; #手动控制录制启停</span><br><span class=\"line\">         \trecord_suffix _rec.flv;</span><br><span class=\"line\">         \trecord_path nginx-rtmp-module/tmp/rec/; #录制保存地址</span><br><span class=\"line\">         \trecord_unique on;</span><br><span class=\"line\">         &#125; \t\t\t</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置http server</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    # server_name  localhost;</span><br><span class=\"line\">    location /stat &#123;</span><br><span class=\"line\">    #\trtmp_stat all;</span><br><span class=\"line\">    #\trtmp_stat_stylesheet stat.xls;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">    #location /stat.xls &#123;</span><br><span class=\"line\">    #\troot nginx-rtmp-module/;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">    #location /control &#123;</span><br><span class=\"line\">    #\trtmp_control all;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\">    location /hls &#123;  </span><br><span class=\"line\">        # Serve HLS fragments  </span><br><span class=\"line\">        types &#123;  </span><br><span class=\"line\">            application/vnd.apple.mpegurl m3u8;  </span><br><span class=\"line\">            video/mp2t ts;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        root html;  </span><br><span class=\"line\">        expires -1;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>启动服务器</li>\n</ol>\n<p>在nginx.exe所在的文件夹，按住shift+右键，选中在此处打开命令窗口，进入windows的cmd。输入以下命令启动nginx服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx.exe -c conf\\nginx-win-.conf</span><br></pre></td></tr></table></figure>\n<p>. 启动结果    </p>\n<p> <img src=\"/images/rtsp/cmd-result.png\" alt=\"avatar\"></p>\n<ol start=\"7\">\n<li>直接在浏览器里输入127.0.0.1就可以进入浏览器的欢迎界面<br><img src=\"/images/rtsp/result.png\" alt=\"avatar\"></li>\n</ol>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/f0bf83ca3ea3\" target=\"_blank\" rel=\"noopener\">ubuntu搭建推流服务器Nginx+rtmp</a></p>\n</blockquote>\n<h2 id=\"提供rtmp直播源\"><a href=\"#提供rtmp直播源\" class=\"headerlink\" title=\"提供rtmp直播源\"></a>提供rtmp直播源</h2><p>在搭建好基于rtmp的服务器之后，需要提供rtmp直播源。这里我们使用的香港卫视的rtmp直播源。根据nginx.conf中的hls_path配置，下面这个命令会向本地的D:\\Program Files\\nginx-1.7.11.3-Gryphon\\html\\hls下面写入ts片段和m3u8文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -analyzeduration 8000 -probesize 200000 -i &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot; -strict -2 -bsf:a aac_adtstoasc -c copy -flvflags aac_seq_header_detect -f flv rtmp://localhost/hls/mystream</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>1、这里提供rtmp源的机器不一定和nginx在同一台物理主机上，可以是网络上的另一台机器，只要保证它能与nginx所在的主机建立tcp链接即可。（也就是nginx主机需要开启rtmp服务的监听端口，这里是1935，当然你也可以修改为其他的端口。）  </p>\n<p>2、<a href=\"https://www.ffmpeg.org/\" target=\"_blank\" rel=\"noopener\">ffmpeg下载地址</a></p>\n</blockquote>\n<h2 id=\"在网页中展示视屏\"><a href=\"#在网页中展示视屏\" class=\"headerlink\" title=\"在网页中展示视屏\"></a>在网页中展示视屏</h2><p>在nginx-1.7.11.3-Gryphon/html目录下面创建一个live.html。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://vjs.zencdn.net/5.10/video-js.css&quot;&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">    &lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls autoplay=true&gt;</span><br><span class=\"line\">        &lt;source src=&quot;hls/mystream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;</span><br><span class=\"line\">    &lt;/video&gt;</span><br><span class=\"line\">    &lt;script src=&quot;http://vjs.zencdn.net/5.10/video.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">   \t&lt;script src=&quot;https://cdn.bootcss.com/videojs-contrib-hls/5.14.1/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">   &lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var player = videojs(&apos;example-video&apos;);</span><br><span class=\"line\">        player.play();</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果只是用video标签是无法播放.m3u8的视屏文件的，需要引入videojs-contrib-hls.js。videojs-contrib-hls支持一堆HLS功能，详情参考[<a href=\"https://www.cnblogs.com/tinywan/p/6692098.html]\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/tinywan/p/6692098.html]</a></p>\n</blockquote>\n<ul>\n<li><p>web端运行效果</p>\n<p><img src=\"/images/rtsp/web.png\" alt=\"avatar\"></p>\n</li>\n<li><p>手机端运行效果</p>\n</li>\n</ul>\n<p>  手机端如果与web可以在同一个网络环境中，那么输入对应本机ip地址也是可以查看的，并且支持横屏、竖屏的切换。</p>\n<p>  <img src=\"/images/rtsp/app1.png\" alt=\"avatar\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>防火墙打开了1935 tcp端口，rtmp视屏还是不能播放，</p>\n<p>可以用下面的命令暂停，<br>systemctl stop firewalld.service</p>\n</li>\n</ul>\n<p>[参考博文]</p>\n<p>1、<a href=\"https://blog.csdn.net/tao_627/article/details/22271559\" target=\"_blank\" rel=\"noopener\"><a href=\"https://blog.csdn.net/tao_627/article/details/22271559\" target=\"_blank\" rel=\"noopener\">使用Nginx-rtmp-module搭建hls直播</a></a></p>\n<p>2、 <a href=\"https://blog.csdn.net/lee353086/article/details/78269590\" target=\"_blank\" rel=\"noopener\">海康NVR设备RTSP协议转RTMP协议</a></p>\n"},{"title":"java web应用的http请求改成https","text":"java web应用的http请求改成https 本文通过将简单介绍两种将http请求修改为https的方式。 1、通过使用sun公司提供的keytool工具结合tomcat实现 2、使用阿里云的免费证书结合nginx实现。 使用SUN公司的提供的工具配置证书 SUN公司提供了制作证书的工具keytool。 在JDK 1.4以后的版本中都包含了这一工具，它的位置为&lt;JAVA_HOME&gt;\\bin\\keytool.exe。 生成证书 这里只介绍简单的keytool生成证书的方法，如果想要了解更多关于keytool的知识，请参考 keytool用法总结 1.创建证书,在命令行中输入 1keytool -genkeypair -alias &quot;test1&quot; -keyalg &quot;RSA&quot; -keystore &quot;test.keystore&quot; 功能： 创建一个别名为test1的证书条目，该条目存放在名为test.keystore的密钥库中，若test.keystore密钥库不存在则创建。 参数说明： -genkeypair：生成一对非对称密钥; -alias：指定密钥对的别名，该别名是公开的; -keyalg：指定加密算法，本例中的采用通用的RAS加密算法; -keystore:密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个”.keystore”的文件 注意： 1.“名字与姓氏”应该是域名，若输成了姓名，和真正运行的时候域名不符，会出问题; 2.再次输入密码，第一次输入的是密钥库(keystore)的密码，第二次输入的是证书条目的密码 3.这里所说的证书库和密钥库是等同的(个人观点) 2.查看证书库 1keytool -list -keystore test.keystore 功能： 查看名为test.keystore的证书库中的证书条目 3.导出到证书文件 1keytool -export -alias test1 -file test.crt -keystore test.keystore 功能： 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt中 4.导入证书的信息 1keytool -import -keystore test_cacerts -file test.crt 功能： 将证书文件test.crt导入到名为test_cacerts的证书库中， 5.查看证书信息 1keytool -printcert -file &quot;test.crt&quot; 功能：查看证书文件test.crt的信息 执行完上述过程之后，我们会在&lt;JAVA_HOME&gt;\\bin目录下面发现生成了3个文件 修改web程序的web.xml123456789&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; &lt;/security-constraint&gt; url-pattern:可以对系统中访问的路径进行过滤 修改tomcat的conf文件1234567&lt;Connector port=&quot;72&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; keystoreFile=&quot;C:/tomcat/conf/test.keystore&quot; keystorePass=&quot;123456&quot; sslProtocol=&quot;TLS&quot; URIEncoding=&quot;UTF-8&quot;/&gt; keystoreFile：证书文件的位置 keystorePass: 是keystore的密码（你在生成证书的时候，会有的keystore密码和tomcat主密码） 使用阿里云服务器生成免费证书生成证书基于阿里云服务器生成密钥证书，请参考用阿里云的免费 SSL 证书让网站从 HTTP 换成 HTTPS 。一般如果证书申请时填写的信息正确，审核不超过10min，在审核通过之后我们选择对应的web服务器，不同的服务器的配置都不相同，这里我们使用ngnix服务器。（其他的web服务器可以在官文中查看，每种服务器都给出了基本的配置方法。） 阿里云免费证书只能对一个域名生效，如果涉及到二级域名或是其他域名，则需要申请不同的证书。 配置web服务器1、 在Nginx的安装目录的conf下创建cert目录，并且将下载的全部文件拷贝到cert目录中。生成证书时，如果是系统自动生成会自己带有私钥文件，如果是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并对其重命名建议和.pem证书文件的名称保持一致； 2、 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件进行修改(以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整)： 123456789101112131415161718192021222324server &#123; listen 443; server_name abc.test.com; ssl on; root html; index index.html index.htm; ssl_certificate cert/xxx.pem; ssl_certificate_key cert/xxx.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125; location /test&#123; tcp_nodelay on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://www.baidu.com; &#125;&#125; 1、 server_name 为系统监听的访问的服务域名。和阿里云中申请的证书的域名保持一致。 2、ssl_certificate 为证书文件的路径。 3、ssl_certificate_key 为私钥文件的路径。 4、在location中路径结合实际情况进行设置。其中/test则是对https的请求进行了转发操作。如何涉及到二级域名的转发操作，则可以在server下面在增加一个server配置项进行相关的配置。 3、启动 nginx，如果在启动时修改了配置文件则重启nginx即可。 4、通过 https 方式访问您的站点，测试站点证书的安装配置。 使用nginx服务器我们不需要对系统的后台服务器进行其他操作。 其他相关文章1、SSL证书与Https应用部署小结 2、https知识了解","content":"<h1 id=\"java-web应用的http请求改成https\"><a href=\"#java-web应用的http请求改成https\" class=\"headerlink\" title=\"java web应用的http请求改成https\"></a>java web应用的http请求改成https</h1><blockquote>\n<p>本文通过将简单介绍两种将http请求修改为https的方式。</p>\n<p>1、通过使用sun公司提供的keytool工具结合tomcat实现</p>\n<p>2、使用阿里云的免费证书结合nginx实现。</p>\n</blockquote>\n<h2 id=\"使用SUN公司的提供的工具配置证书\"><a href=\"#使用SUN公司的提供的工具配置证书\" class=\"headerlink\" title=\"使用SUN公司的提供的工具配置证书\"></a>使用SUN公司的提供的工具配置证书</h2><blockquote>\n<p>SUN公司提供了制作证书的工具keytool。 在JDK 1.4以后的版本中都包含了这一工具，它的位置为&lt;JAVA_HOME&gt;\\bin\\keytool.exe。</p>\n</blockquote>\n<h3 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h3><blockquote>\n<p>这里只介绍简单的keytool生成证书的方法，如果想要了解更多关于keytool的知识，请参考 <a href=\"http://ln-ydc.iteye.com/blog/1335213\" target=\"_blank\" rel=\"noopener\"> keytool用法总结</a></p>\n</blockquote>\n<p> 1.创建证书,在命令行中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -genkeypair -alias &quot;test1&quot; -keyalg &quot;RSA&quot; -keystore &quot;test.keystore&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/https/1.jpg\" alt=\"avatar\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p> 创建一个别名为test1的证书条目，该条目存放在名为test.keystore的密钥库中，若test.keystore密钥库不存在则创建。</p>\n</blockquote>\n<ul>\n<li>参数说明：</li>\n</ul>\n<blockquote>\n<p>-genkeypair：生成一对非对称密钥;</p>\n<p>-alias：指定密钥对的别名，该别名是公开的;</p>\n<p>-keyalg：指定加密算法，本例中的采用通用的RAS加密算法;</p>\n<p>-keystore:密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个”.keystore”的文件</p>\n</blockquote>\n<ul>\n<li>注意：</li>\n</ul>\n<blockquote>\n<p>1.“名字与姓氏”应该是域名，若输成了姓名，和真正运行的时候域名不符，会出问题;</p>\n<p>2.再次输入密码，第一次输入的是密钥库(keystore)的密码，第二次输入的是证书条目的密码</p>\n<p>3.这里所说的证书库和密钥库是等同的(个人观点)</p>\n</blockquote>\n<p> 2.查看证书库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -keystore test.keystore</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/https/2.jpg\" alt=\"avatar\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p>查看名为test.keystore的证书库中的证书条目</p>\n</blockquote>\n<p> 3.导出到证书文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -export -alias test1 -file test.crt -keystore test.keystore</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/https/3.jpg\" alt=\"avatar\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p> 将名为test.keystore的证书库中别名为test1的证书条目导出到证书文件test.crt中</p>\n</blockquote>\n<p> 4.导入证书的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -import -keystore test_cacerts -file test.crt</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/images/https/4.jpg\" alt=\"img\"></p>\n<ul>\n<li>功能：</li>\n</ul>\n<blockquote>\n<p>将证书文件test.crt导入到名为test_cacerts的证书库中，</p>\n</blockquote>\n<p>5.查看证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file &quot;test.crt&quot;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/images/https/5.jpg\" alt=\"img\"></p>\n<ul>\n<li>功能：查看证书文件test.crt的信息</li>\n</ul>\n<p>执行完上述过程之后，我们会在&lt;JAVA_HOME&gt;\\bin目录下面发现生成了3个文件</p>\n<h3 id=\"修改web程序的web-xml\"><a href=\"#修改web程序的web-xml\" class=\"headerlink\" title=\"修改web程序的web.xml\"></a>修改web程序的web.xml</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;security-constraint&gt; </span><br><span class=\"line\">\t\t   &lt;web-resource-collection&gt; </span><br><span class=\"line\">\t\t\t\t  &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt; </span><br><span class=\"line\">\t\t\t\t  &lt;url-pattern&gt;/*&lt;/url-pattern&gt; </span><br><span class=\"line\">\t\t   &lt;/web-resource-collection&gt;                           </span><br><span class=\"line\">\t\t   &lt;user-data-constraint&gt; </span><br><span class=\"line\">\t\t\t\t  &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; </span><br><span class=\"line\">\t\t   &lt;/user-data-constraint&gt; </span><br><span class=\"line\">\t&lt;/security-constraint&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>url-pattern:可以对系统中访问的路径进行过滤</li>\n</ul>\n<h3 id=\"修改tomcat的conf文件\"><a href=\"#修改tomcat的conf文件\" class=\"headerlink\" title=\"修改tomcat的conf文件\"></a>修改tomcat的conf文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;72&quot; protocol=&quot;HTTP/1.1&quot;    connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">                redirectPort=&quot;8443&quot; </span><br><span class=\"line\">\t\t\t   SSLEnabled=&quot;true&quot;   maxThreads=&quot;150&quot; </span><br><span class=\"line\">\t\t\t   scheme=&quot;https&quot; secure=&quot;true&quot;   clientAuth=&quot;false&quot;</span><br><span class=\"line\">\t\t\t   keystoreFile=&quot;C:/tomcat/conf/test.keystore&quot;   </span><br><span class=\"line\">\t\t\t   keystorePass=&quot;123456&quot; sslProtocol=&quot;TLS&quot;</span><br><span class=\"line\">\t\t\t   URIEncoding=&quot;UTF-8&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>keystoreFile：证书文件的位置</p>\n</li>\n<li><p>keystorePass: 是keystore的密码（你在生成证书的时候，会有的keystore密码和tomcat主密码）</p>\n</li>\n</ul>\n<h2 id=\"使用阿里云服务器生成免费证书\"><a href=\"#使用阿里云服务器生成免费证书\" class=\"headerlink\" title=\"使用阿里云服务器生成免费证书\"></a>使用阿里云服务器生成免费证书</h2><h3 id=\"生成证书-1\"><a href=\"#生成证书-1\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h3><p>基于阿里云服务器生成密钥证书，请参考<a href=\"https://ninghao.net/blog/4449\" target=\"_blank\" rel=\"noopener\">用阿里云的免费 SSL 证书让网站从 HTTP 换成 HTTPS</a> 。一般如果证书申请时填写的信息正确，审核不超过10min，在审核通过之后我们选择对应的web服务器，不同的服务器的配置都不相同，这里我们使用ngnix服务器。（其他的web服务器可以在官文中查看，每种服务器都给出了基本的配置方法。）</p>\n<blockquote>\n<p>阿里云免费证书只能对一个域名生效，如果涉及到二级域名或是其他域名，则需要申请不同的证书。</p>\n</blockquote>\n<h3 id=\"配置web服务器\"><a href=\"#配置web服务器\" class=\"headerlink\" title=\"配置web服务器\"></a>配置web服务器</h3><p>1、 在Nginx的安装目录的conf下创建cert目录，并且将下载的全部文件拷贝到cert目录中。生成证书时，如果是系统自动生成会自己带有私钥文件，如果是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并对其重命名建议和.pem证书文件的名称保持一致；</p>\n<p>2、 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件进行修改(以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name abc.test.com;</span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    root html;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    ssl_certificate   cert/xxx.pem;</span><br><span class=\"line\">    ssl_certificate_key  cert/xxx.key;</span><br><span class=\"line\">    ssl_session_timeout 5m;</span><br><span class=\"line\">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root html;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location /test&#123;</span><br><span class=\"line\">        tcp_nodelay     on;  </span><br><span class=\"line\">        proxy_set_header Host            $host;  </span><br><span class=\"line\">        proxy_set_header X-Real-IP       $remote_addr;  </span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class=\"line\">        proxy_pass http://www.baidu.com;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>1、 server_name 为系统监听的访问的服务域名。和阿里云中申请的证书的域名保持一致。</li>\n<li>2、ssl_certificate 为证书文件的路径。</li>\n<li>3、ssl_certificate_key 为私钥文件的路径。</li>\n<li>4、在location中路径结合实际情况进行设置。其中/test则是对https的请求进行了转发操作。如何涉及到二级域名的转发操作，则可以在server下面在增加一个server配置项进行相关的配置。</li>\n</ul>\n</blockquote>\n<p> 3、启动 nginx，如果在启动时修改了配置文件则重启nginx即可。</p>\n<p> 4、通过 https 方式访问您的站点，测试站点证书的安装配置。</p>\n<blockquote>\n<p> 使用nginx服务器我们不需要对系统的后台服务器进行其他操作。</p>\n</blockquote>\n<h2 id=\"其他相关文章\"><a href=\"#其他相关文章\" class=\"headerlink\" title=\"其他相关文章\"></a>其他相关文章</h2><p>1、<a href=\"https://blog.csdn.net/andy1219111/article/details/22716315\" target=\"_blank\" rel=\"noopener\">SSL证书与Https应用部署小结</a></p>\n<p>2、<a href=\"https://blog.csdn.net/andy1219111/article/details/22716315\" target=\"_blank\" rel=\"noopener\">https知识了解</a></p>\n"},{"title":"Tomcat配置定时启动","text":"Tomcat配置定时启动一、设置tomcat定时启动1、首先将tomcat注册为服务 先打开tomcat的bin目录下service.bat文件，修改下面的值，这是sevvice的注册名称和显示名称，一般可使用默认值。 1set SERVICE_NAME=Tomcat-DPlatform-Server``set DISPLAYNAME=Apache Tomcat 8.5 %SERVICE_NAME% ​ 然后修改jvm大小， 搜索到–JvmMs 128 –JvmMx 256 进行修改，因为做成服务启动，启动的时候就不会用到 catalina.bat，也就不会读取里面的jvm设置了。】（可选，可以不设置） 然后运行cmd命令窗口，cd 到tomcat的bin目录下，运行下面的命令 1service.bat install ​ 运行成功过后，会提示服务已经安装成功。如下图所示： 2、制作重启脚本restart.bat，文件内容如下： 123456789101112131415161718192021@echo off echo ***********************************************echo start time %DATE% %TIME% echo ***********************************************echo Start closing the service net stop Tomcat-DPlatform-Serverecho service has been closedecho *** echo start clean up catchingrd /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\work\\Catalina&quot;echo clean up end echo start clean up temp for /f &quot;delims=&quot; %%a in (&apos;dir /ad/b/s D:\\tomcat\\ydkq-tomcat-server\\temp&apos;) do (rd /q /s &quot;%%a&quot;)&gt;nulrem del /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\temp\\*.*&quot; echo clean up end echo Start the start of the service net start Tomcat-DPlatform-Server echo service has been startedecho ***********************************************echo end time %DATE% %TIME% echo *********************************************** 3、配置定时任务 （win7）开始–&gt;附件——&gt;系统工具——&gt;任务计划与程序，然后设置对应的脚本运行时间计划 【注意】 使用net stop / net start 命令的时候需要使用管理员权限也就是任务中的最高权限，否则会提示发生系统错误，拒绝访问。 4、删除服务 如果想要删除服务，也很简单，先把服务停掉，然后在cmd窗口运行下面的命令即可，后面那个Tomcat7是服务名。 sc delete Tomcat7 需要注意的是，需要先把服务停掉，才能一次删除成功，或者删除之后再停止服务，就会发现服务已经删除成功了。 【参考】 http://blog.csdn.net/lovelong8808/article/details/52052423","content":"<h1 id=\"Tomcat配置定时启动\"><a href=\"#Tomcat配置定时启动\" class=\"headerlink\" title=\"Tomcat配置定时启动\"></a>Tomcat配置定时启动</h1><h2 id=\"一、设置tomcat定时启动\"><a href=\"#一、设置tomcat定时启动\" class=\"headerlink\" title=\"一、设置tomcat定时启动\"></a>一、设置tomcat定时启动</h2><p>1、首先将tomcat注册为服务      先打开tomcat的bin目录下service.bat文件，修改下面的值，这是sevvice的注册名称和显示名称，一般可使用默认值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set SERVICE_NAME=Tomcat-DPlatform-Server``set DISPLAYNAME=Apache Tomcat 8.5 %SERVICE_NAME%</span><br></pre></td></tr></table></figure>\n<p>​     然后修改jvm大小， 搜索到–JvmMs 128 –JvmMx 256 进行修改，因为做成服务启动，启动的时候就不会用到 catalina.bat，也就不会读取里面的jvm设置了。】（可选，可以不设置）<br>     然后运行cmd命令窗口，cd 到tomcat的bin目录下，运行下面的命令 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service.bat install</span><br></pre></td></tr></table></figure>\n<p>​       运行成功过后，会提示服务已经安装成功。如下图所示：<br> <img src=\"file:///C:/Users/cheryl/Documents/My Knowledge/temp/3876c524-2e1d-4692-b26e-4642dd15485c/128/index_files/92bc70f4-85a4-4bc5-87db-9fb697dc3d20.png\" alt=\"img\"><br>2、制作重启脚本restart.bat，文件内容如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off </span><br><span class=\"line\">echo ***********************************************</span><br><span class=\"line\">echo start time %DATE% %TIME% </span><br><span class=\"line\">echo ***********************************************</span><br><span class=\"line\">echo Start closing the service </span><br><span class=\"line\">net stop Tomcat-DPlatform-Server</span><br><span class=\"line\">echo service has been closed</span><br><span class=\"line\">echo  *** </span><br><span class=\"line\">echo start clean up catching</span><br><span class=\"line\">rd /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\work\\Catalina&quot;</span><br><span class=\"line\">echo clean up end </span><br><span class=\"line\">echo start clean up temp </span><br><span class=\"line\">for /f &quot;delims=&quot; %%a in (&apos;dir /ad/b/s D:\\tomcat\\ydkq-tomcat-server\\temp&apos;) do (rd /q /s &quot;%%a&quot;)&gt;nul</span><br><span class=\"line\">rem del /q/s &quot;D:\\tomcat\\ydkq-tomcat-server\\temp\\*.*&quot;   </span><br><span class=\"line\">echo clean up end </span><br><span class=\"line\">echo Start the start of the service </span><br><span class=\"line\">net start Tomcat-DPlatform-Server </span><br><span class=\"line\">echo service has been started</span><br><span class=\"line\">echo ***********************************************</span><br><span class=\"line\">echo end time %DATE% %TIME% </span><br><span class=\"line\">echo ***********************************************</span><br></pre></td></tr></table></figure>\n<p>3、配置定时任务<br>    （win7）开始–&gt;附件——&gt;系统工具——&gt;任务计划与程序，然后设置对应的脚本运行时间计划   【注意】 使用net stop / net start 命令的时候需要使用管理员权限也就是任务中的最高权限，否则会提示发生系统错误，拒绝访问。</p>\n<p>4、删除服务</p>\n<p> 如果想要删除服务，也很简单，先把服务停掉，然后在cmd窗口运行下面的命令即可，后面那个Tomcat7是服务名。 sc delete Tomcat7</p>\n<p>需要注意的是，需要先把服务停掉，才能一次删除成功，或者删除之后再停止服务，就会发现服务已经删除成功了。</p>\n<p>【参考】 <a href=\"http://blog.csdn.net/lovelong8808/article/details/52052423\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/lovelong8808/article/details/52052423</a></p>\n"},{"title":"使用GitHub+Hexo搭建免费博客","text":"搭建博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后点击回车，接下来会提示输入密码，如果不设置密码则直接继续按两次回车即可，如果设置了则会提示再次输入密码确认。最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人-&gt; SETTINF -&gt; SSH and GPG keys -&gt; New SSH key，然后把复制的内容到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 使用hexo写博客hexo简介Hexo是一个基于 Github Pages 的博客发布工具，支持Markdown格式。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。创建好文件之后，执行下面命令： 1hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下： 12345678910.deploy_gitnode_modules #hexo需要的模块，不需要上传githubpubilc #生成的静态页面scaffolds #source #博文md文件themes #主题文件.gitignore #hexo默认生成的.gitignore_config.yml #全局配置文件db.jsonpackage.json #记录hexo需要的包信息 1.hexo帮助把博客发送到github，同时把md文件转换成网页文件。 2.hexo目录下的文件和github上的文件是不同的，public文件夹的文件通过hexo d 上传到github去了，其他的文件则留在本地目录下。 1hexo g # 生成 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github。 1hexo s # 启动服务 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题: 1.按下Win+R调出命令行窗口，输入netstat -aon|findstr “4000”，找到指定行最后一列的数字（PID），我们这里是xxxx.2.输入tasklist|findstr “xxxx”，发现是javaw.exe占用了4000端口。3.再次输入taskkill /f /t /im javaw.exe结束该进程。 修改主题第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，但是默认主题的样式个人觉得不是很喜欢。可以从Hexo官方主题 找一个自己喜欢的主题。在这里使用的是 ASnippet。 下载之后，把主题放在F:\\hexo\\themes，然后再_config.yml中把修改为: 1theme: snippet 重新发布之后就可以看到新的主题的样子啦。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会。 常见命令常用hexo命令常见命令 1234567hexo new / hexo n &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate /hexo g #生成静态页面至public目录hexo server / hexo s #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy / hexo d #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 写博客可以直接使用命令hexo n &quot;postName&quot;，当然也可以直接在_posts文件夹下面创建.md文章。 博客模板一般为： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 哈，这里推荐一个觉得不错的markdown的编辑器Typora。 扩展功能评论我们可以看到很多博客其实都是可以进行评论的，那么接下来看一下如何在博客中引入评论。这里我们使用的是来必力。 再注册成功之后，在都应的主题的_config.yml中加入如下配置即可： 123livere: enable: true livere_uid: xxxx #这里填写的是在来比力注册之后给的uuid 在引入之后重新发布，这里如果页面底部出现空白不要着急，耐心等待一下，那个是来比力正在加载。 多个分支提交博客创建分支1git branch hexo 更改默认分支在Github的username.github.io仓库上新建一个hexo分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，save保存。 切换分支并拷贝文件首先把F:/hexo下面的所有文件都复制上，然后再git bash中运行如下命令，切换到hexo分支： 1git checkout hexo 然后把刚刚复制的文件都拷贝的当前文件夹下面。 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可 提交分支再提交分支之前，记得把本地的库和远程的库建立关联 1git remote add origin git@github.com:xx/xxx.git #具体的仓库地址 执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push origin hexo即可将博客的hexo部署环境提交到GitHub个人仓库的hexo分支。 其他电脑克隆仓库到本地至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单： 将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支 123git init #初始化仓库git remote add origin git@github.com:xx/xxx.git #具体的仓库地址git fetch origin hexo #把分支克隆到本地 切换到hexo目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下) 更新博客依次执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push指令，保证hexo分支版本最新 执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先git pull 提交博客​ 按照之前的方法写自己博客， 然后将目录切换下username.github.io下，此时需要安装一下npm install， 最后执行hexo g、hexo s、hexo d等命令即可提交成功 参考博文 使用hexo+github搭建免费个人博客详细教程 Hexo 个性化配置(三) 利用Hexo在多台电脑上提交和更新github pages博客","content":"<h1 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h1><h2 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href=\"http://test.github.io/\" target=\"_blank\" rel=\"noopener\">http://test.github.io</a> 了，是不是很方便？</p>\n<p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>\n<p>几个注意的地方：</p>\n<ol>\n<li>注册的邮箱一定要验证，否则不会成功；</li>\n<li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li>\n<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟；</li>\n</ol>\n<p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p>\n<h2 id=\"配置SSH-key\"><a href=\"#配置SSH-key\" class=\"headerlink\" title=\"配置SSH key\"></a>配置SSH key</h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure>\n<p>如果提示：No such file or directory 说明你是第一次使用git。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>\n<p>然后点击回车，接下来会提示输入密码，如果不设置密码则直接继续按两次回车即可，如果设置了则会提示再次输入密码确认。最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人-&gt; SETTINF -&gt; SSH and GPG keys -&gt; New SSH key，然后把复制的内容到key那里，title随便填，保存。</p>\n<h2 id=\"测试是否成功\"><a href=\"#测试是否成功\" class=\"headerlink\" title=\"测试是否成功\"></a>测试是否成功</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure>\n<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>\n<blockquote>\n<p>Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>\n</blockquote>\n<p>看到这个信息说明SSH已配置成功！</p>\n<h1 id=\"使用hexo写博客\"><a href=\"#使用hexo写博客\" class=\"headerlink\" title=\"使用hexo写博客\"></a>使用hexo写博客</h1><h2 id=\"hexo简介\"><a href=\"#hexo简介\" class=\"headerlink\" title=\"hexo简介\"></a>hexo简介</h2><p>Hexo是一个基于 Github Pages 的博客发布工具，支持Markdown格式。</p>\n<p>官网： <a href=\"http://hexo.io/\" target=\"_blank\" rel=\"noopener\">http://hexo.io</a><br>github: <a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo</a></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>安装之前先来说几个注意事项：</p>\n<ol>\n<li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li>\n<li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li>\n<li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。创建好文件之后，执行下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n<p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.deploy_git</span><br><span class=\"line\">node_modules  #hexo需要的模块，不需要上传github</span><br><span class=\"line\">pubilc   #生成的静态页面</span><br><span class=\"line\">scaffolds  #</span><br><span class=\"line\">source     #博文md文件</span><br><span class=\"line\">themes     #主题文件</span><br><span class=\"line\">.gitignore #hexo默认生成的.gitignore</span><br><span class=\"line\">_config.yml   #全局配置文件</span><br><span class=\"line\">db.json</span><br><span class=\"line\">package.json   #记录hexo需要的包信息</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1.hexo帮助把博客发送到github，同时把md文件转换成网页文件。 </p>\n<p>2.hexo目录下的文件和github上的文件是不同的，public文件夹的文件通过hexo d 上传到github去了，其他的文件则留在本地目录下。 </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g # 生成</span><br></pre></td></tr></table></figure>\n<p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s # 启动服务</span><br></pre></td></tr></table></figure>\n<p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题:</p>\n<blockquote>\n<p>1.按下Win+R调出命令行窗口，输入netstat -aon|findstr “4000”，找到指定行最后一列的数字（PID），我们这里是xxxx.<br>2.输入tasklist|findstr “xxxx”，发现是javaw.exe占用了4000端口。<br>3.再次输入taskkill /f /t /im javaw.exe结束该进程。</p>\n</blockquote>\n<h2 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h2><p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，但是默认主题的样式个人觉得不是很喜欢。可以从<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo官方主题</a>  找一个自己喜欢的主题。在这里使用的是  <a href=\"https://github.com/shenliyang/hexo-theme-snippet\" target=\"_blank\" rel=\"noopener\">ASnippet</a>。</p>\n<p>下载之后，把主题放在F:\\hexo\\themes，然后再_config.yml中把修改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: snippet</span><br></pre></td></tr></table></figure>\n<p>重新发布之后就可以看到新的主题的样子啦。</p>\n<p><img src=\"/images/blog-img.png\" alt=\"avatar\"></p>\n<h2 id=\"上传到github\"><a href=\"#上传到github\" class=\"headerlink\" title=\"上传到github\"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p>\n<p>首先，<code>ssh key</code>肯定要配置好。</p>\n<p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p>\n<p>正确写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:liuxianan/liuxianan.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>此时直接执行<code>hexo d</code>的话一般会报如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure>\n<p>原因是还需要安装一个插件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p>\n<p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会。</p>\n<h2 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h2><h2 id=\"常用hexo命令\"><a href=\"#常用hexo命令\" class=\"headerlink\" title=\"常用hexo命令\"></a>常用hexo命令</h2><p>常见命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new /  hexo n &quot;postName&quot; #新建文章</span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面</span><br><span class=\"line\">hexo generate /hexo g #生成静态页面至public目录</span><br><span class=\"line\">hexo server / hexo s  #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class=\"line\">hexo deploy / hexo d #部署到GitHub</span><br><span class=\"line\">hexo help  # 查看帮助</span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>\n<p>组合命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s -g #生成并本地预览</span><br><span class=\"line\">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>\n<h2 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h2><p>可以直接使用命令<code>hexo n &quot;postName&quot;</code>，当然也可以直接在_posts文件夹下面创建.md文章。</p>\n<p>博客模板一般为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: postName #文章页面上的显示名称，一般是中文</span><br><span class=\"line\">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class=\"line\">categories: 默认分类 #分类</span><br><span class=\"line\">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class=\"line\">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">以下是正文</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>哈，这里推荐一个觉得不错的markdown的编辑器Typora。</p>\n</blockquote>\n<h1 id=\"扩展功能\"><a href=\"#扩展功能\" class=\"headerlink\" title=\"扩展功能\"></a>扩展功能</h1><h2 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h2><p>我们可以看到很多博客其实都是可以进行评论的，那么接下来看一下如何在博客中引入评论。这里我们使用的是<a href=\"https://livere.com/\" target=\"_blank\" rel=\"noopener\">来必力</a>。</p>\n<p>再注册成功之后，在都应的主题的_config.yml中加入如下配置即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">livere:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  livere_uid: xxxx  #这里填写的是在来比力注册之后给的uuid</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> 在引入之后重新发布，这里如果页面底部出现空白不要着急，耐心等待一下，那个是来比力正在加载。</p>\n</blockquote>\n<h1 id=\"多个分支提交博客\"><a href=\"#多个分支提交博客\" class=\"headerlink\" title=\"多个分支提交博客\"></a>多个分支提交博客</h1><h2 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch  hexo</span><br></pre></td></tr></table></figure>\n<h2 id=\"更改默认分支\"><a href=\"#更改默认分支\" class=\"headerlink\" title=\"更改默认分支\"></a>更改默认分支</h2><p>在Github的username.github.io仓库上新建一个hexo分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，save保存。</p>\n<h2 id=\"切换分支并拷贝文件\"><a href=\"#切换分支并拷贝文件\" class=\"headerlink\" title=\"切换分支并拷贝文件\"></a>切换分支并拷贝文件</h2><p>首先把F:/hexo下面的所有文件都复制上，然后再git bash中运行如下命令，切换到hexo分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout hexo</span><br></pre></td></tr></table></figure>\n<p>然后把刚刚复制的文件都拷贝的当前文件夹下面。</p>\n<blockquote>\n<ul>\n<li>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。</li>\n<li>可能有人会问，删除了themes目录中的.git不就不能<code>git pull</code>更新主题了吗，很简单，需要更新主题时在另一个地方<code>git clone</code>下来该主题的最新版本，然后将内容拷到当前主题目录即可</li>\n</ul>\n</blockquote>\n<h2 id=\"提交分支\"><a href=\"#提交分支\" class=\"headerlink\" title=\"提交分支\"></a>提交分支</h2><p>再提交分支之前，记得把本地的库和远程的库建立关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:xx/xxx.git   #具体的仓库地址</span><br></pre></td></tr></table></figure>\n<p>执行<code>git add .</code>、<code>git commit -m &#39;back up hexo files&#39;</code>（引号内容可改）、<code>git push origin hexo</code>即可将博客的hexo部署环境提交到GitHub个人仓库的hexo分支。 </p>\n<h2 id=\"其他电脑\"><a href=\"#其他电脑\" class=\"headerlink\" title=\"其他电脑\"></a>其他电脑</h2><h3 id=\"克隆仓库到本地\"><a href=\"#克隆仓库到本地\" class=\"headerlink\" title=\"克隆仓库到本地\"></a>克隆仓库到本地</h3><p>至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单：</p>\n<ul>\n<li><p>将新电脑的生成的ssh key添加到GitHub账户上</p>\n</li>\n<li><p>在新电脑上克隆username.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init   #初始化仓库</span><br><span class=\"line\">git remote add origin git@github.com:xx/xxx.git   #具体的仓库地址</span><br><span class=\"line\">git fetch origin hexo   #把分支克隆到本地</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>切换到hexo目录，执行<code>npm install</code>(由于仓库有一个.gitignore文件，里面默认是忽略掉  node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下)</li>\n</ul>\n<h3 id=\"更新博客\"><a href=\"#更新博客\" class=\"headerlink\" title=\"更新博客\"></a>更新博客</h3><p>依次执行<code>git add .</code>、<code>git commit -m &#39;back up hexo files&#39;</code>（引号内容可改）、<code>git push</code>指令，保证hexo分支版本最新</p>\n<p>执行<code>hexo d -g</code>指令（在此之前，有时可能需要执行<code>hexo clean</code>），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！</p>\n<blockquote>\n<p><strong> 注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先<code>git pull</code></strong> </p>\n</blockquote>\n<h3 id=\"提交博客\"><a href=\"#提交博客\" class=\"headerlink\" title=\"提交博客\"></a>提交博客</h3><p>​      按照之前的方法写自己博客， 然后将目录切换下username.github.io下，此时需要安装一下<code>npm install</code>， 最后执行<code>hexo g</code>、<code>hexo s</code>、<code>hexo d</code>等命令即可提交成功 </p>\n<h1 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h1><ul>\n<li><a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\" target=\"_blank\" rel=\"noopener\">使用hexo+github搭建免费个人博客详细教程</a></li>\n<li><a href=\"https://blog.csdn.net/kunkun5love/article/details/79403176\" target=\"_blank\" rel=\"noopener\">Hexo 个性化配置(三)</a></li>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">利用Hexo在多台电脑上提交和更新github pages博客</a></li>\n</ul>\n"},{"title":"Stream API","text":"Stream API Java8中有两大最为重要的改变。第一个是 Lambda 表达式 ;另外一 个则是 Stream API(java.util.stream.*) 。Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对 集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。也可以使用 Stream API 来并行执行操作。简而言之， Stream API 供了一种高效且易于使用的处理数据的方式。 一、什么是 Stream流(Stream) 到底是什么呢? 是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。集合讲的是数据，流讲的是计算!注意: Stream自己不会存储元素。 Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。 Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。 二、Stream操作的三个步骤2.1 创建stream 一个数据源（如：集合或数组），获取一个流 2.2 中间操作 一个中间操作链，对数据源的数据进行处理。 2.3 终止操作 一个终止操作，执行中间操作链，并产生结果。 三、创建Stream的四种方式3.1 由Collection创建流Java8 中的 Collection 接口被扩展， 供了两个获取流的方法: default Stream&lt; E&gt; stream() : 返回一个顺序流 default Stream&lt; E&gt; parallelStream() : 返回一个并行流 案例： 123List&lt;Employee&gt; list = new ArrayList&lt;&gt;();Stream&lt;Employee&gt; stream = list.stream();Stream&lt;Employee&gt; parallelStream = list.parallelStream(); 3.2 由数组创建流通过 Arrays中的静态方法 stream() 创建数据源 。static &lt; T&gt; Stream&lt; T&gt; stream(T[] array): 返回一个流 重载形式，能够处理对应基本类型的数组: public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 案例： 12Integer[] num = new Integer[23];Stream&lt;Integer&gt; stream1 = Arrays.stream(num);12 3.3 由值创建流可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流 案例： 1Stream&lt;Integer&gt; stream2 = Stream.of(1, 5, 7); 3.4 由函数创建流可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 迭代：public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f) 生成：public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s) 案例： 123456789// 迭代Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(2);stream3.forEach(System.out::println);System.out.println(&quot;-------------&quot;);// 生成Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(4);stream4.forEach(System.out::println);123456789 执行结果： 123456702-------------0.80093413282642290.33937273167260450.164029418307976570.189839641538307121234567 四、Stream的中间操作多个 中间操作 可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理! 而在终止操作时一次性全部处理，称为“惰性求值”。 4.1 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素。 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去 除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补 案例： 定义一个集合： Employee 重写 hashcode ， equals — 去重时使用 12345678List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, &quot;林青霞&quot;, 28, 9889.99), new Employee(102, &quot;东方不败&quot;, 29, 4329.85), new Employee(103, &quot;周星驰&quot;, 40, 1233.88), new Employee(104, &quot;大圣&quot;, 500, 5000.44), new Employee(105, &quot;张无忌&quot;, 15, 3000.09), new Employee(102, &quot;东方不败&quot;, 29, 4329.85) );12345678 执行操作： 1.内部迭代 - 迭代操作由Stream API 完成操作 12345678910111213@Testpublic void test2() &#123; // 中间操作不会做任何处理 Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; &#123; System.out.println(&quot;惰性求值&quot;); return e.getAge() &lt; 30; &#125;); System.out.println(&quot;--------------------&quot;); // 终止操作，一次性执行全部功能， 称为 &quot;惰性求值&quot; stream.forEach(System.out::println);&#125;12345678910111213 执行结果： 1234567891011--------------------惰性求值Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;惰性求值Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;惰性求值惰性求值惰性求值Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;惰性求值Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;1234567891011 2.外部迭代 12345678@Testpublic void test3() &#123; Iterator&lt;Employee&gt; iterator = emps.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;12345678 执行结果： 123456Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;123456 3.中间操作 - 截断流 1234567@Testpublic void test4() &#123; emps.stream() .filter(employee -&gt; employee.getAge() &lt; 30) // 过滤年龄小于30的人 .limit(1) // 截取一个 .forEach(System.out::println); &#125;1234567 执行结果： 12Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;12 4.中间操作 - 跳过 12345678@Testpublic void test5() &#123; emps.stream() .filter(employee -&gt; employee.getAge() &lt; 30) .skip(2) .forEach(System.out::println); &#125;12345678 执行结果： 123Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;123 5.中间操作 - 筛选去重 123456@Testpublic void test6() &#123; emps.stream() .distinct() .forEach(System.out::println); &#125;123456 执行结果： 12345Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;12345 4.2 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 案例：1.map操作 1234567891011121314@Testpublic void test7() &#123; List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;java&quot;, &quot;ccc&quot;, &quot;java8&quot;, &quot;hello world&quot;); list.stream() .map((x) -&gt; x.toUpperCase()) .forEach(System.out::println); System.out.println(&quot;-------------&quot;); emps.stream() .map(Employee::getAge) .forEach(System.out::println);&#125;1234567891011121314 执行结果： 123456789101112AAAJAVACCCJAVA8HELLO WORLD-------------2829405001529123456789101112 2.flatMap操作 先定义一个 filterCharacter(String str) 方法： 12345678private static Stream&lt;Character&gt; filterCharacter(String str) &#123; List&lt;Character&gt; characters = new ArrayList&lt;&gt;(); for (Character character : str.toCharArray()) &#123; characters.add(character); &#125; return characters.stream(); &#125;12345678 执行测试代码： 1234567891011121314151617181920@Testpublic void test8() &#123; List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;hello world&quot;); Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream() .map(LambdaStramAPI::filterCharacter); streamStream.forEach((s) -&gt; &#123; s.forEach((c) -&gt; System.out.println(c + &quot;&quot;)); System.out.println(); &#125;); System.out.println(&quot;----------------------&quot;); list.stream() .flatMap(LambdaStramAPI::filterCharacter) .forEach(System.out::println);&#125;1234567891011121314151617181920 执行结果： 12345678910111213141516171819202122232425262728293031aaahelloworld----------------------aaahelloworld12345678910111213141516171819202122232425262728293031 4.3 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 案例： 1234567891011121314@Testpublic void test9() &#123; emps.stream() .map(Employee::getSalary) .sorted() .forEach(System.out::println); System.out.println(&quot;-----------------&quot;); emps.stream() .map(Employee::getAge) .sorted(Integer::compare) .forEach(System.out::println);&#125;1234567891011121314 执行结果： 123456789101112131233.883000.094329.854329.855000.449889.99-----------------152829294050012345678910111213 五、 Stream的终止操作终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如:List、Integer，甚至是 void 。 5.1 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭 代，称为外部迭代。相反，Stream API 使用内部 迭代——它帮你把迭代做了) 案例：1.匹配 123456789101112131415161718@Testpublic void test10() &#123; boolean allMatch = emps.stream() .allMatch((employee -&gt; employee.getName().equals(&quot;林青霞&quot;))); System.out.println(allMatch); System.out.println(&quot;-----------------&quot;); boolean anyMatch = emps.stream() .anyMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;)); System.out.println(anyMatch); System.out.println(&quot;-----------------&quot;); boolean noneMatch = emps.stream() .noneMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;)); System.out.println(noneMatch);&#125;123456789101112131415161718 执行结果： 12345false-----------------true-----------------false12345 2.第一个元素 、 任意一个元素 123456789101112131415 @Testpublic void test12() &#123; Optional&lt;String&gt; first = emps.stream() .map(Employee::getName) .sorted() .findFirst(); // 获取第一个元素 System.out.println(first.get()); System.out.println(&quot;-----------------&quot;); Optional&lt;Employee&gt; findAny = emps.parallelStream() .filter(employee -&gt; employee.getName().equals(&quot;林青霞&quot;)) .findAny(); //任意一个元素 System.out.println(findAny.get());&#125;123456789101112131415 执行结果： 123东方不败-----------------Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;123 3.统计总个数、 最大、 最小值 1234567891011121314151617181920// 注意： 流一旦执行终止操作后， 就不能在重复使用@Testpublic void test13() &#123; Stream&lt;Employee&gt; stream = emps.stream(); long count = stream.count(); System.out.println(count); System.out.println(&quot;-----------------&quot;); Optional&lt;Double&gt; doubleOptional = emps.stream() .map(Employee::getSalary) .max(Double::compare); //最大值 System.out.println(doubleOptional.get()); System.out.println(&quot;-----------------&quot;); Optional&lt;Employee&gt; employeeOptional = emps.stream() .min((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary())); // 最小值 System.out.println(employeeOptional.get());&#125;1234567891011121314151617181920 执行结果： 123456-----------------9889.99-----------------Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;12345 5.2 归约备注:map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。 返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。 返回 Optional&lt; T&gt; 案例：1.求和 12345678@Testpublic void test14() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); &#125;12345678 执行结果： 1551 2.计算次数 12345678910111213141516171819@Testpublic void test15() &#123; Optional&lt;Double&gt; doubleOptional = emps.stream() .map(Employee::getSalary) .reduce(Double::max); System.out.println(doubleOptional); System.out.println(&quot;-----------------&quot;); //查看 东方不败 出现的次数 -- 【此处还有点毛病】 Optional&lt;Integer&gt; sumOptional = emps.stream() .map(Employee::getName) .flatMap(LambdaStramAPI::filterCharacter) .map((c) -&gt; &#123; if (c.equals(&quot;东&quot;)) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sumOptional.get());&#125;12345678910111213141516171819 执行结果： 123Optional[9889.99]-----------------0123 5.3 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的 实现，用于给Stream中元素做汇总的方法 案例：1.收集 123456789101112131415161718192021@Testpublic void test16()&#123; List&lt;String&gt; collect = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); collect.forEach(System.out::println); System.out.println(&quot;-------------------&quot;); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(&quot;-------------------&quot;); HashSet&lt;String&gt; hashSet = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hashSet.forEach(System.out::println);&#125;123456789101112131415161718192021 执行结果： 123456789101112131415161718林青霞东方不败周星驰大圣张无忌东方不败-------------------周星驰林青霞大圣东方不败张无忌-------------------周星驰林青霞大圣东方不败张无忌123456789101112131415161718 2.收集统计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 收集统计 @Test public void test17()&#123; // 统计总个数 Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println(&quot;-------------------&quot;); // 求平均值 Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); System.out.println(&quot;-------------------&quot;); // 求和 Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); System.out.println(&quot;-------------------&quot;); //求最大值 Optional&lt;Employee&gt; max = emps.stream() .collect(Collectors.maxBy((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary()))); System.out.println(max.get()); System.out.println(&quot;-------------------&quot;); //求最小值 Optional&lt;Double&gt; min = emps.stream() .map(Employee::getSalary) .collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); System.out.println(&quot;-------------------&quot;); //统计分析 DoubleSummaryStatistics doubleSummaryStatistics = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(doubleSummaryStatistics.getAverage()); System.out.println(&quot;-------------------&quot;); //拼接 String join = emps.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;,&quot;, &quot;--&quot;, &quot;--&quot;)); System.out.println(join); &#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 执行结果： 123456789101112136-------------------4630.683333333333-------------------27784.1-------------------Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;-------------------1233.88-------------------4630.683333333333---------------------林青霞,东方不败,周星驰,大圣,张无忌,东方不败--12345678910111213 3.收集-分组 1234567// 分组@Testpublic void test18()&#123; Map&lt;String, List&lt;Employee&gt;&gt; group = emps.stream() .collect(Collectors.groupingBy(Employee::getName)); System.out.println(group);&#125;1234567 执行结果： 123456789&#123;周星驰=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;], 林青霞=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;], 大圣=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;], 东方不败=[Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;], 张无忌=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;123456789 4.收集-多级分组 1234567891011// 多级分组@Testpublic void test19()&#123; Map&lt;String, Map&lt;String, List&lt;Employee&gt;&gt;&gt; group = emps.stream() .collect(Collectors.groupingBy(Employee::getName, Collectors.groupingBy((e) -&gt; &#123; if (e.getAge() &lt; 30) return &quot;青年&quot;; else if (e.getAge() &lt; 50) return &quot;中年&quot;; else return &quot;老年&quot;; &#125;))); System.out.println(group);&#125;1234567891011 执行结果： 123456789&#123;周星驰=&#123;中年=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;]&#125;, 林青霞=&#123;青年=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;]&#125;, 大圣=&#123;老年=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;]&#125;, 东方不败=&#123;青年=[Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;]&#125;, 张无忌=&#123;青年=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;&#125;123456789 Collector 接口中方法的实现决定了如何对流执行收集操作(如收 集到 List、Set、Map)。但是 Collectors 实用类 供了很多静态 方法，可以方便地创建常见收集器实例，具体方法与实例如下表: 方法 返回类型 作用 toList List 把流中元素收集到List List emps= list.stream().collect(Collectors.toList()); toSet Set 把流中元素收集到Set Set emps= list.stream().collect(Collectors.toSet()); toCollection Collection 把流中元素收集到创建的集合 Collectionemps=list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 long count = list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均 值 doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。 如:平均值 IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 String str= list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional 根据比较器选择最大值 Optionalmax= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional 根据比较器选择最小值 Optional min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型 从一个作为累加器的初始值 开始，利用BinaryOperator与 流中元素逐个结合，从而归 约成单个值 inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结 果转换函数 inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); groupingBy Map&lt;K, List&gt; 根据某属性值对流分组，属 性为K，结果为V Map&lt;Emp.Status, List&gt; map= list.stream() .collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map&lt;Boolean, List&gt; 根据true或false进行分区 Map&lt;Boolean,List&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 相关源码地址：https://github.com/liudongdong0909/java8/tree/master/java8-Lambda/src/com/donggua 以上就是全文的内容，由于水平有限，文章中难免会有错误，希望大家指正。谢谢~ 参考文章JAVA8新特性——StreamAPI","content":"<h1 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h1><blockquote>\n<p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式 ;另外一 个则是 Stream API(java.util.stream.*) 。<br>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对 集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。<br>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。也可以使用 Stream API 来并行执行操作。简而言之， Stream API 供了一种高效且易于使用的处理数据的方式。</p>\n</blockquote>\n<h2 id=\"一、什么是-Stream\"><a href=\"#一、什么是-Stream\" class=\"headerlink\" title=\"一、什么是 Stream\"></a>一、什么是 Stream</h2><p>流(Stream) 到底是什么呢? 是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。集合讲的是数据，流讲的是计算!<br><strong>注意:</strong> </p>\n<ol>\n<li>Stream自己不会存储元素。 </li>\n<li>Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。 </li>\n<li>Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。</li>\n</ol>\n<h2 id=\"二、Stream操作的三个步骤\"><a href=\"#二、Stream操作的三个步骤\" class=\"headerlink\" title=\"二、Stream操作的三个步骤\"></a>二、Stream操作的三个步骤</h2><h3 id=\"2-1-创建stream\"><a href=\"#2-1-创建stream\" class=\"headerlink\" title=\"2.1 创建stream\"></a>2.1 创建stream</h3><blockquote>\n<p>一个数据源（如：集合或数组），获取一个流</p>\n</blockquote>\n<h3 id=\"2-2-中间操作\"><a href=\"#2-2-中间操作\" class=\"headerlink\" title=\"2.2 中间操作\"></a>2.2 中间操作</h3><blockquote>\n<p>一个中间操作链，对数据源的数据进行处理。</p>\n</blockquote>\n<h3 id=\"2-3-终止操作\"><a href=\"#2-3-终止操作\" class=\"headerlink\" title=\"2.3 终止操作\"></a>2.3 终止操作</h3><blockquote>\n<p>一个终止操作，执行中间操作链，并产生结果。</p>\n</blockquote>\n<h2 id=\"三、创建Stream的四种方式\"><a href=\"#三、创建Stream的四种方式\" class=\"headerlink\" title=\"三、创建Stream的四种方式\"></a>三、创建Stream的四种方式</h2><h3 id=\"3-1-由Collection创建流\"><a href=\"#3-1-由Collection创建流\" class=\"headerlink\" title=\"3.1 由Collection创建流\"></a>3.1 由Collection创建流</h3><p>Java8 中的 Collection 接口被扩展， 供了两个获取流的方法: </p>\n<ul>\n<li>default Stream&lt; E&gt; stream() : 返回一个顺序流 </li>\n<li>default Stream&lt; E&gt; parallelStream() : 返回一个并行流</li>\n</ul>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">Stream&lt;Employee&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-由数组创建流\"><a href=\"#3-2-由数组创建流\" class=\"headerlink\" title=\"3.2 由数组创建流\"></a>3.2 由数组创建流</h3><p>通过 Arrays中的静态方法 stream() 创建数据源 。<br>static &lt; T&gt; Stream&lt; T&gt; stream(T[] array): 返回一个流</p>\n<p>重载形式，能够处理对应基本类型的数组: </p>\n<ul>\n<li>public static IntStream stream(int[] array) </li>\n<li>public static LongStream stream(long[] array) </li>\n<li>public static DoubleStream stream(double[] array)</li>\n</ul>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] num = new Integer[23];</span><br><span class=\"line\">Stream&lt;Integer&gt; stream1 = Arrays.stream(num);12</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-由值创建流\"><a href=\"#3-3-由值创建流\" class=\"headerlink\" title=\"3.3 由值创建流\"></a>3.3 由值创建流</h3><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。<br>public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流</p>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; stream2 = Stream.of(1, 5, 7);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-由函数创建流\"><a href=\"#3-4-由函数创建流\" class=\"headerlink\" title=\"3.4 由函数创建流\"></a>3.4 由函数创建流</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 </p>\n<ul>\n<li>迭代：public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f) </li>\n<li>生成：public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s)</li>\n</ul>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 迭代</span><br><span class=\"line\">Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(2);</span><br><span class=\"line\">stream3.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;-------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 生成</span><br><span class=\"line\">Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(4);</span><br><span class=\"line\">stream4.forEach(System.out::println);123456789</span><br></pre></td></tr></table></figure>\n<p><strong>执行结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">2</span><br><span class=\"line\">-------------</span><br><span class=\"line\">0.8009341328264229</span><br><span class=\"line\">0.3393727316726045</span><br><span class=\"line\">0.16402941830797657</span><br><span class=\"line\">0.189839641538307121234567</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、Stream的中间操作\"><a href=\"#四、Stream的中间操作\" class=\"headerlink\" title=\"四、Stream的中间操作\"></a>四、Stream的中间操作</h2><p>多个 中间操作 可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理! 而在终止操作时一次性全部处理，称为“惰性求值”。</p>\n<h3 id=\"4-1-筛选与切片\"><a href=\"#4-1-筛选与切片\" class=\"headerlink\" title=\"4.1 筛选与切片\"></a>4.1 筛选与切片</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter(Predicate p)</td>\n<td>接收 Lambda ， 从流中排除某些元素。</td>\n</tr>\n<tr>\n<td>distinct()</td>\n<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去 除重复元素</td>\n</tr>\n<tr>\n<td>limit(long maxSize)</td>\n<td>截断流，使其元素不超过给定数量</td>\n</tr>\n<tr>\n<td>skip(long n)</td>\n<td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong></p>\n<p>定义一个集合： Employee 重写 hashcode ， equals — 去重时使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class=\"line\">          new Employee(101, &quot;林青霞&quot;, 28, 9889.99),</span><br><span class=\"line\">          new Employee(102, &quot;东方不败&quot;, 29, 4329.85),</span><br><span class=\"line\">          new Employee(103, &quot;周星驰&quot;, 40, 1233.88),</span><br><span class=\"line\">          new Employee(104, &quot;大圣&quot;, 500, 5000.44),</span><br><span class=\"line\">          new Employee(105, &quot;张无忌&quot;, 15, 3000.09),</span><br><span class=\"line\">          new Employee(102, &quot;东方不败&quot;, 29, 4329.85)</span><br><span class=\"line\">  );12345678</span><br></pre></td></tr></table></figure>\n<p><strong>执行操作：</strong></p>\n<p>1.内部迭代 - 迭代操作由Stream API 完成操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test2() &#123;</span><br><span class=\"line\">    // 中间操作不会做任何处理</span><br><span class=\"line\">    Stream&lt;Employee&gt; stream = emps.stream()</span><br><span class=\"line\">            .filter((e) -&gt; &#123;</span><br><span class=\"line\">                System.out.println(&quot;惰性求值&quot;);</span><br><span class=\"line\">                return e.getAge() &lt; 30;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    System.out.println(&quot;--------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 终止操作，一次性执行全部功能， 称为 &quot;惰性求值&quot;</span><br><span class=\"line\">    stream.forEach(System.out::println);</span><br><span class=\"line\">&#125;12345678910111213</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;</span><br><span class=\"line\">惰性求值</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;1234567891011</span><br></pre></td></tr></table></figure>\n<p>2.外部迭代</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test3() &#123;</span><br><span class=\"line\">     Iterator&lt;Employee&gt; iterator = emps.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">     while (iterator.hasNext()) &#123;</span><br><span class=\"line\">         System.out.println(iterator.next());</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;123456</span><br></pre></td></tr></table></figure>\n<p>3.中间操作 - 截断流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test4() &#123;</span><br><span class=\"line\">     emps.stream()</span><br><span class=\"line\">             .filter(employee -&gt; employee.getAge() &lt; 30) // 过滤年龄小于30的人</span><br><span class=\"line\">             .limit(1) // 截取一个</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\"> &#125;1234567</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<p>4.中间操作 - 跳过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test5() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     emps.stream()</span><br><span class=\"line\">             .filter(employee -&gt; employee.getAge() &lt; 30)</span><br><span class=\"line\">             .skip(2)</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\"> &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n<p>5.中间操作 - 筛选去重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test6() &#123;</span><br><span class=\"line\">     emps.stream()</span><br><span class=\"line\">             .distinct()</span><br><span class=\"line\">             .forEach(System.out::println);</span><br><span class=\"line\"> &#125;123456</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;</span><br><span class=\"line\">Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;12345</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-映射\"><a href=\"#4-2-映射\" class=\"headerlink\" title=\"4.2 映射\"></a>4.2 映射</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>map(Function f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。</td>\n</tr>\n<tr>\n<td>mapToDouble(ToDoubleFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。</td>\n</tr>\n<tr>\n<td>mapToInt(ToIntFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。</td>\n</tr>\n<tr>\n<td>mapToLong(ToLongFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。</td>\n</tr>\n<tr>\n<td>flatMap(Function f)</td>\n<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.map操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test7() &#123;</span><br><span class=\"line\">    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;java&quot;, &quot;ccc&quot;, &quot;java8&quot;, &quot;hello world&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    list.stream()</span><br><span class=\"line\">            .map((x) -&gt; x.toUpperCase())</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    emps.stream()</span><br><span class=\"line\">            .map(Employee::getAge)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;1234567891011121314</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AAA</span><br><span class=\"line\">JAVA</span><br><span class=\"line\">CCC</span><br><span class=\"line\">JAVA8</span><br><span class=\"line\">HELLO WORLD</span><br><span class=\"line\">-------------</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">40</span><br><span class=\"line\">500</span><br><span class=\"line\">15</span><br><span class=\"line\">29123456789101112</span><br></pre></td></tr></table></figure>\n<p>2.flatMap操作</p>\n<p>先定义一个 filterCharacter(String str) 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Stream&lt;Character&gt; filterCharacter(String str) &#123;</span><br><span class=\"line\">        List&lt;Character&gt; characters = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Character character : str.toCharArray()) &#123;</span><br><span class=\"line\">            characters.add(character);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return characters.stream();</span><br><span class=\"line\">    &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test8() &#123;</span><br><span class=\"line\">    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;hello world&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream()</span><br><span class=\"line\">            .map(LambdaStramAPI::filterCharacter);</span><br><span class=\"line\"></span><br><span class=\"line\">    streamStream.forEach((s) -&gt; &#123;</span><br><span class=\"line\">        s.forEach((c) -&gt; System.out.println(c + &quot;&quot;));</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;----------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    list.stream()</span><br><span class=\"line\">            .flatMap(LambdaStramAPI::filterCharacter)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\"></span><br><span class=\"line\">h</span><br><span class=\"line\">e</span><br><span class=\"line\">l</span><br><span class=\"line\">l</span><br><span class=\"line\">o</span><br><span class=\"line\"></span><br><span class=\"line\">w</span><br><span class=\"line\">o</span><br><span class=\"line\">r</span><br><span class=\"line\">l</span><br><span class=\"line\">d</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------</span><br><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\">a</span><br><span class=\"line\">h</span><br><span class=\"line\">e</span><br><span class=\"line\">l</span><br><span class=\"line\">l</span><br><span class=\"line\">o</span><br><span class=\"line\"></span><br><span class=\"line\">w</span><br><span class=\"line\">o</span><br><span class=\"line\">r</span><br><span class=\"line\">l</span><br><span class=\"line\">d12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-排序\"><a href=\"#4-3-排序\" class=\"headerlink\" title=\"4.3 排序\"></a>4.3 排序</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sorted()</td>\n<td>产生一个新流，其中按自然顺序排序</td>\n</tr>\n<tr>\n<td>sorted(Comparator comp)</td>\n<td>产生一个新流，其中按比较器顺序排序</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test9() &#123;</span><br><span class=\"line\">    emps.stream()</span><br><span class=\"line\">            .map(Employee::getSalary)</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    emps.stream()</span><br><span class=\"line\">            .map(Employee::getAge)</span><br><span class=\"line\">            .sorted(Integer::compare)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;1234567891011121314</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1233.88</span><br><span class=\"line\">3000.09</span><br><span class=\"line\">4329.85</span><br><span class=\"line\">4329.85</span><br><span class=\"line\">5000.44</span><br><span class=\"line\">9889.99</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">15</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">29</span><br><span class=\"line\">40</span><br><span class=\"line\">50012345678910111213</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、-Stream的终止操作\"><a href=\"#五、-Stream的终止操作\" class=\"headerlink\" title=\"五、 Stream的终止操作\"></a>五、 Stream的终止操作</h2><p>终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如:List、Integer，甚至是 void 。</p>\n<h3 id=\"5-1-查找与匹配\"><a href=\"#5-1-查找与匹配\" class=\"headerlink\" title=\"5.1 查找与匹配\"></a>5.1 查找与匹配</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>allMatch(Predicate p)</td>\n<td>检查是否匹配所有元素</td>\n</tr>\n<tr>\n<td>anyMatch(Predicate p)</td>\n<td>检查是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td>noneMatch(Predicate p)</td>\n<td>检查是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td>findFirst()</td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td>findAny()</td>\n<td>返回当前流中的任意元素</td>\n</tr>\n<tr>\n<td>count()</td>\n<td>返回流中元素总数</td>\n</tr>\n<tr>\n<td>max(Comparator c)</td>\n<td>返回流中最大值</td>\n</tr>\n<tr>\n<td>min(Comparator c)</td>\n<td>返回流中最小值</td>\n</tr>\n<tr>\n<td>forEach(Consumer c)</td>\n<td>内部迭代(使用 Collection 接口需要用户去做迭 代，称为外部迭代。相反，Stream API 使用内部 迭代——它帮你把迭代做了)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test10() &#123;</span><br><span class=\"line\">    boolean allMatch = emps.stream()</span><br><span class=\"line\">            .allMatch((employee -&gt; employee.getName().equals(&quot;林青霞&quot;)));</span><br><span class=\"line\">    System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean anyMatch = emps.stream()</span><br><span class=\"line\">            .anyMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;));</span><br><span class=\"line\">    System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean noneMatch = emps.stream()</span><br><span class=\"line\">            .noneMatch(employee -&gt; employee.getName().equals(&quot;林青霞&quot;));</span><br><span class=\"line\">    System.out.println(noneMatch);</span><br><span class=\"line\">&#125;123456789101112131415161718</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">true</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">false12345</span><br></pre></td></tr></table></figure>\n<p>2.第一个元素 、 任意一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @Test</span><br><span class=\"line\">public void test12() &#123;</span><br><span class=\"line\">    Optional&lt;String&gt; first = emps.stream()</span><br><span class=\"line\">            .map(Employee::getName)</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .findFirst(); // 获取第一个元素</span><br><span class=\"line\">    System.out.println(first.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Optional&lt;Employee&gt; findAny = emps.parallelStream()</span><br><span class=\"line\">            .filter(employee -&gt; employee.getName().equals(&quot;林青霞&quot;))</span><br><span class=\"line\">            .findAny(); //任意一个元素</span><br><span class=\"line\">    System.out.println(findAny.get());</span><br><span class=\"line\">&#125;123456789101112131415</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">东方不败</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;123</span><br></pre></td></tr></table></figure>\n<p>3.统计总个数、 最大、 最小值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注意： 流一旦执行终止操作后， 就不能在重复使用</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void test13() &#123;</span><br><span class=\"line\">    Stream&lt;Employee&gt; stream = emps.stream();</span><br><span class=\"line\">    long count = stream.count();</span><br><span class=\"line\">    System.out.println(count);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Optional&lt;Double&gt; doubleOptional = emps.stream()</span><br><span class=\"line\">            .map(Employee::getSalary)</span><br><span class=\"line\">            .max(Double::compare); //最大值</span><br><span class=\"line\">    System.out.println(doubleOptional.get());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Optional&lt;Employee&gt; employeeOptional = emps.stream()</span><br><span class=\"line\">            .min((x, y) -&gt; Double.compare(x.getSalary(),  y.getSalary())); // 最小值</span><br><span class=\"line\">    System.out.println(employeeOptional.get());</span><br><span class=\"line\">&#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">9889.99</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;12345</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-归约\"><a href=\"#5-2-归约\" class=\"headerlink\" title=\"5.2 归约\"></a>5.2 归约</h3><p><strong>备注:map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reduce(T iden, BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值。 返回 T</td>\n</tr>\n<tr>\n<td>reduce(BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值。 返回 Optional&lt; T&gt;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.求和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test14() &#123;</span><br><span class=\"line\">     List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class=\"line\"></span><br><span class=\"line\">     Integer sum = list.stream()</span><br><span class=\"line\">             .reduce(0, (x, y) -&gt; x + y);</span><br><span class=\"line\">     System.out.println(sum);</span><br><span class=\"line\"> &#125;12345678</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">551</span><br></pre></td></tr></table></figure>\n<p>2.计算次数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test15() &#123;</span><br><span class=\"line\">    Optional&lt;Double&gt; doubleOptional = emps.stream()</span><br><span class=\"line\">            .map(Employee::getSalary)</span><br><span class=\"line\">            .reduce(Double::max);</span><br><span class=\"line\">    System.out.println(doubleOptional);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //查看 东方不败 出现的次数 -- 【此处还有点毛病】</span><br><span class=\"line\">    Optional&lt;Integer&gt; sumOptional = emps.stream()</span><br><span class=\"line\">            .map(Employee::getName)</span><br><span class=\"line\">            .flatMap(LambdaStramAPI::filterCharacter)</span><br><span class=\"line\">            .map((c) -&gt; &#123;</span><br><span class=\"line\">                if (c.equals(&quot;东&quot;)) return 1;</span><br><span class=\"line\">                else return 0;</span><br><span class=\"line\">            &#125;).reduce(Integer::sum);</span><br><span class=\"line\">    System.out.println(sumOptional.get());</span><br><span class=\"line\">&#125;12345678910111213141516171819</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional[9889.99]</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">0123</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-3-收集\"><a href=\"#5-3-收集\" class=\"headerlink\" title=\"5.3 收集\"></a>5.3 收集</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>collect(Collector c)</td>\n<td>将流转换为其他形式。接收一个 Collector接口的 实现，用于给Stream中元素做汇总的方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例：</strong><br>1.收集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test16()&#123;</span><br><span class=\"line\">   List&lt;String&gt; collect = emps.stream()</span><br><span class=\"line\">           .map(Employee::getName)</span><br><span class=\"line\">           .collect(Collectors.toList());</span><br><span class=\"line\">   collect.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   Set&lt;String&gt; set = emps.stream()</span><br><span class=\"line\">           .map(Employee::getName)</span><br><span class=\"line\">           .collect(Collectors.toSet());</span><br><span class=\"line\">   set.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   HashSet&lt;String&gt; hashSet = emps.stream()</span><br><span class=\"line\">           .map(Employee::getName)</span><br><span class=\"line\">           .collect(Collectors.toCollection(HashSet::new));</span><br><span class=\"line\">   hashSet.forEach(System.out::println);</span><br><span class=\"line\">&#125;123456789101112131415161718192021</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">林青霞</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">周星驰</span><br><span class=\"line\">大圣</span><br><span class=\"line\">张无忌</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">周星驰</span><br><span class=\"line\">林青霞</span><br><span class=\"line\">大圣</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">张无忌</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">周星驰</span><br><span class=\"line\">林青霞</span><br><span class=\"line\">大圣</span><br><span class=\"line\">东方不败</span><br><span class=\"line\">张无忌123456789101112131415161718</span><br></pre></td></tr></table></figure>\n<p>2.收集统计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 收集统计</span><br><span class=\"line\"> @Test</span><br><span class=\"line\"> public  void test17()&#123;</span><br><span class=\"line\">     // 统计总个数</span><br><span class=\"line\">     Long count = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.counting());</span><br><span class=\"line\">     System.out.println(count);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     // 求平均值</span><br><span class=\"line\">     Double avg = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class=\"line\">     System.out.println(avg);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     // 求和</span><br><span class=\"line\">     Double sum = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class=\"line\">     System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //求最大值</span><br><span class=\"line\">     Optional&lt;Employee&gt; max = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.maxBy((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary())));</span><br><span class=\"line\">     System.out.println(max.get());</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //求最小值</span><br><span class=\"line\">     Optional&lt;Double&gt; min = emps.stream()</span><br><span class=\"line\">             .map(Employee::getSalary)</span><br><span class=\"line\">             .collect(Collectors.minBy(Double::compare));</span><br><span class=\"line\">     System.out.println(min.get());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //统计分析</span><br><span class=\"line\">     DoubleSummaryStatistics doubleSummaryStatistics = emps.stream()</span><br><span class=\"line\">             .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class=\"line\">     System.out.println(doubleSummaryStatistics.getAverage());</span><br><span class=\"line\"></span><br><span class=\"line\">     System.out.println(&quot;-------------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">     //拼接</span><br><span class=\"line\">     String join = emps.stream()</span><br><span class=\"line\">             .map(Employee::getName)</span><br><span class=\"line\">             .collect(Collectors.joining(&quot;,&quot;, &quot;--&quot;, &quot;--&quot;));</span><br><span class=\"line\">     System.out.println(join);</span><br><span class=\"line\"> &#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">4630.683333333333</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">27784.1</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">1233.88</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">4630.683333333333</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">--林青霞,东方不败,周星驰,大圣,张无忌,东方不败--12345678910111213</span><br></pre></td></tr></table></figure>\n<p>3.收集-分组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 分组</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public  void test18()&#123;</span><br><span class=\"line\">    Map&lt;String, List&lt;Employee&gt;&gt; group = emps.stream()</span><br><span class=\"line\">            .collect(Collectors.groupingBy(Employee::getName));</span><br><span class=\"line\">    System.out.println(group);</span><br><span class=\"line\">&#125;1234567</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">周星驰=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;], </span><br><span class=\"line\">林青霞=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;], </span><br><span class=\"line\">大圣=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;], </span><br><span class=\"line\">东方不败=[</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, </span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">], </span><br><span class=\"line\">张无忌=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;123456789</span><br></pre></td></tr></table></figure>\n<p>4.收集-多级分组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 多级分组</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void test19()&#123;</span><br><span class=\"line\">    Map&lt;String, Map&lt;String, List&lt;Employee&gt;&gt;&gt; group = emps.stream()</span><br><span class=\"line\">            .collect(Collectors.groupingBy(Employee::getName, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class=\"line\">                if (e.getAge() &lt; 30) return &quot;青年&quot;;</span><br><span class=\"line\">                else if (e.getAge() &lt; 50) return &quot;中年&quot;;</span><br><span class=\"line\">                else return &quot;老年&quot;;</span><br><span class=\"line\">            &#125;)));</span><br><span class=\"line\">    System.out.println(group);</span><br><span class=\"line\">&#125;1234567891011</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;周星驰=&#123;中年=[Employee&#123;id=103, name=&apos;周星驰&apos;, age=40, salary=1233.88, status=null&#125;]&#125;, </span><br><span class=\"line\">林青霞=&#123;青年=[Employee&#123;id=101, name=&apos;林青霞&apos;, age=28, salary=9889.99, status=null&#125;]&#125;, </span><br><span class=\"line\">大圣=&#123;老年=[Employee&#123;id=104, name=&apos;大圣&apos;, age=500, salary=5000.44, status=null&#125;]&#125;, </span><br><span class=\"line\">东方不败=&#123;青年=[</span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;, </span><br><span class=\"line\">Employee&#123;id=102, name=&apos;东方不败&apos;, age=29, salary=4329.85, status=null&#125;</span><br><span class=\"line\">]&#125;, </span><br><span class=\"line\">张无忌=&#123;青年=[Employee&#123;id=105, name=&apos;张无忌&apos;, age=15, salary=3000.09, status=null&#125;]&#125;&#125;</span><br><span class=\"line\">123456789</span><br></pre></td></tr></table></figure>\n<p><strong>Collector 接口中方法的实现决定了如何对流执行收集操作(如收 集到 List、Set、Map)。但是 Collectors 实用类 供了很多静态 方法，可以方便地创建常见收集器实例，具体方法与实例如下表:</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>返回类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>toList</td>\n<td>List<t></t></td>\n<td>把流中元素收集到List</td>\n</tr>\n<tr>\n<td>List<employee> emps= list.stream().collect(Collectors.toList());</employee></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>toSet</td>\n<td>Set<t></t></td>\n<td>把流中元素收集到Set</td>\n</tr>\n<tr>\n<td>Set<employee> emps= list.stream().collect(Collectors.toSet());</employee></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>toCollection</td>\n<td>Collection<t></t></td>\n<td>把流中元素收集到创建的集合</td>\n</tr>\n<tr>\n<td>Collection<employee>emps=list.stream().collect(Collectors.toCollection(ArrayList::new));</employee></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>counting</td>\n<td>Long</td>\n<td>计算流中元素的个数</td>\n</tr>\n<tr>\n<td>long count = list.stream().collect(Collectors.counting());</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>summingInt</td>\n<td>Integer</td>\n<td>对流中元素的整数属性求和</td>\n</tr>\n<tr>\n<td>inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>averagingInt</td>\n<td>Double</td>\n<td>计算流中元素Integer属性的平均 值</td>\n</tr>\n<tr>\n<td>doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>summarizingInt</td>\n<td>IntSummaryStatistics</td>\n<td>收集流中Integer属性的统计值。 如:平均值</td>\n</tr>\n<tr>\n<td>IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>joining</td>\n<td>String</td>\n<td>连接流中每个字符串</td>\n</tr>\n<tr>\n<td>String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>maxBy</td>\n<td>Optional<t></t></td>\n<td>根据比较器选择最大值</td>\n</tr>\n<tr>\n<td>Optional<emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</emp></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>minBy</td>\n<td>Optional<t></t></td>\n<td>根据比较器选择最小值</td>\n</tr>\n<tr>\n<td>Optional<emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</emp></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reducing</td>\n<td>归约产生的类型</td>\n<td>从一个作为累加器的初始值 开始，利用BinaryOperator与 流中元素逐个结合，从而归 约成单个值</td>\n</tr>\n<tr>\n<td>inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>collectingAndThen</td>\n<td>转换函数返回的类型</td>\n<td>包裹另一个收集器，对其结 果转换函数</td>\n</tr>\n<tr>\n<td>inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>groupingBy</td>\n<td>Map&lt;K, List<t>&gt;</t></td>\n<td>根据某属性值对流分组，属 性为K，结果为V</td>\n</tr>\n<tr>\n<td>Map&lt;Emp.Status, List<emp>&gt; map= list.stream() .collect(Collectors.groupingBy(Employee::getStatus));</emp></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>partitioningBy</td>\n<td>Map&lt;Boolean, List<t>&gt;</t></td>\n<td>根据true或false进行分区</td>\n</tr>\n<tr>\n<td>Map&lt;Boolean,List<emp>&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage));</emp></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://github.com/liudongdong0909/java8/tree/master/java8-Lambda/src/com/donggua\" target=\"_blank\" rel=\"noopener\">相关源码地址：https://github.com/liudongdong0909/java8/tree/master/java8-Lambda/src/com/donggua</a></p>\n<p>以上就是全文的内容，由于水平有限，文章中难免会有错误，希望大家指正。谢谢~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://blog.csdn.net/liudongdong0909/article/details/77429875\" target=\"_blank\" rel=\"noopener\">JAVA8新特性——StreamAPI</a></p>\n"},{"title":"快速搭建小程序项目","text":"小程序搭建 开发工具安装微信公众平台提供了winddows64,windows32,mac三个操作系统下的安装包，我们选择合适自己下载即可。（微信开发者工具下载链接） 备注： 小程序的开发工具除了使用官方提供的微信开发者工具之外，还可以使用SublimeText,或者是WebStrom等，然后配合使用微信开发者工具进行调试操作。 快速创建项目在根据提示安装完成之后，我们需要用微信扫描二维码登录微信开发者工具。然后选择小程序项目 然后我们选择小程序存放的位置，填写对应的demo，选择体验小程序，并且勾选建立普通快速启动模板。 这里我们先使用无appId的方式即体验模式，虽然无法进行代码真机预览和上传等操作，部分 API 无法正常调用，但是不影响我们正常的开发。项目创建完如下图所示 关于开发工具再此不做详细说明，详情可以参考小程序开发工具介绍 项目结构介绍小程序文件类型小程序中有且只有以下4中类型的文件： json 后缀的 JSON 配置文件 wxml 后缀的 WXML 模板文件 wxss 后缀的 WXSS 样式文件 js 后缀的 JS 脚本逻辑文件 包结构小程序的默认的包结构如下所示 1234567891011121314151617+- pages +- indexs - index.js - index.json - index.wsml - index.wxss +- logs - logs.js - logs.json - logs.wsml - logs.wxss+- utils - util.jsapp.jsapp.jsonapp.wxssproject.config.json 所有的配置遵循就近原则 包结构说明1.app.json 小程序逻辑（必须） app.json中的App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。 2.app.json 小程序公共设置（必须） app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 3.app.wxss 全局样式文件 在app.wxss中可以定义一些全局属性的样式，这样相同的养生石在单独的页面中就无需在配置了。 4.project.config.json 是工具配置文件。 所有对当前开发工具做的操作都会保存到project.config.json文件中，当我们重新安装工具或者是更换电脑时，只需导入项目的代码即可恢复我们之前对工具的一些设置。 5.pages 小程序模板存放的文件夹 在小程序中所有的模板都在此文件中，并且每一个页面对应中有4个文件 文件类型 必填 作用 js 是 页面逻辑 wxml 是 页面结构 wxss 否 页面样式表 json 否 页面配置 为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 页面中的wxss样式配置如果与app.wxss有相同的，那么采取就近原则，优先使用页面的样式。 小程序的页面是可以嵌套的，对应的可以有二级页面，三级页面等等，但是最多只能支持5级页面，这一点主要是从小程序的性能方面考虑，从而做的限制。 编写简单页面移动端的分辨率与rpx在开始编写页面之前我们首先要了解一下分辨率的概念，因为小程序是移动端的开发，在不同的机型中是需要进行适配的，所以要注意像素的使用。 pt 逻辑分辨率，pt的大小与屏幕尺寸与关系，简单可以理解为长度和视觉单位 px 物理分辨率，与屏幕尺寸没有关系，用于描述一个单位中像素点的多少 reader 设备像素比 一个pt包含多少个px，人类视觉极限为@2x ppi(dpi） 每一寸包含的px 从上述图中可以看出1个pt可以有1个px构成也可以有2个，甚至是3个… 小程序推荐的使用的单位是rpx。他和px之间的关系为 1rpx = 1px 。 唯一的区别就是rpx可以根据屏幕进行适配，而px不可以。 扩展 不是所有的单位都适合rpx当需要的元素大小适应屏幕尺寸，就选择rpx作为单位，否者使用px作为单位。一般来说文字不建议使用rpx；建议margin-top，margint-bottom 使用rpx,因为屏幕是可以进行垂直滚动的，而margin-left，margin-right使用px，当然这个不是绝对的也是根据具体问题具体分析的。 为什么使用ip6的物理分辨率来设计UI?小程序的模拟器采用的是逻辑分辨率。在设计时采用的就是根据iphone6的屏幕来设计的。所以存在:1px = 1rpx=2pt。方便开发，所以在调试时使用iphone6模拟器进行调试。 为什么iphone plus 的设备相素比大于iphone6的，但是图像并没有更清晰呢？从理论上来说同一个单位的包含的物理像素点多，显示的图像会更细腻，更清晰，但是人类的极限的2备的像素比，所以虽然iphone6 plus 的像素比为3备的像素比但是我们视觉上并没有太大的感觉。 创建页面下图是我们将要实现的一个页面。 创建文件首先创建一个空的项目，建立小程序中必须的文件app.json，app.wxss以及pages文件夹,以及。然在pages下面创建welcome文件夹，然后建立对应welcome.wxml,welcome.wxss文件。 创建完之后我们需要把页面注册的小程序中，也就是配置到app.json的pages中。否则是不可以预览这个页面的。 12345&#123; &quot;pages&quot;: [ &quot;pages/welcome/welcome&quot; ]&#125; 小程序中规定，pages下面的第一个页面，默认为显示的第一个页面 创建页面的一个快捷方式就是在直接在 app.json的pages数组中加入“pages/xxx/xxx”。在保存之后会在pages生成对应的xxx文件下面生成xxx.wxml、xxx.wxss、xxx.js以及xxx.json。 编写welcome.wxml小程序中有一个基本的视图容器view,类似于html里面的div,用来分割页面中的不同部分。文字可以直接写也可使用text标签包围。 1234567&lt;view class=&apos;container&apos;&gt; &lt;image class=&quot;welcome-avatar&quot; src=&apos;/images/welcome.jpg&apos;&gt;&lt;/image&gt; &lt;text class=&quot;welcome-title&quot;&gt;Cheryl Demo&lt;/text&gt; &lt;view class=&apos;moto-container&apos;&gt; &lt;text class=&apos;moto&apos;&gt;开启小程序之旅 &lt;/text&gt; &lt;/view&gt;&lt;/view&gt; text标签的相关Tips 使用text包围的文字可以添加自定义样式，也可在手机中可以长按选中。 可以识别转移字符,例如\\n识别为换行 各个操作系统的空格标准并不一致。 组件内只支持 嵌套。 在编写完页面之后，编写对应的wxss文件。 1234567891011121314151617181920212223242526272829303132333435363738/* pages/welcome/welcome.wxss */.container&#123; display:flex;/变成弹性模型/ flex-direction: column;/垂直布局/ align-items: center;/* 居中对齐 */&#125;.welcome-avatar&#123; width: 200rpx; height: 200rpx; margin-top: 160rpx; /*图片显示成圆形 */ border-radius: 500px; &#125;.welcome-title&#123; font-size: 22px; font-weight: bold; margin-top: 40rpx; color: gray;&#125;.moto-container&#123; border: 1px solid #FF99FF; border-radius: 5px; margin-top: 60rpx; background-color: #FF99FF;&#125;.moto&#123; font-size: 20px; color: #ffffff; padding: 20px;&#125;page&#123; background-color: #FFCCFF;&#125; 在小程序中不需要引入 wxss,因为app.json的pages中注册页面的时候无需指明具体的文件，所以pages可以自动的把welcome中4中不同类型的文件关联在一起。 在wxml中样式可以使用class也可以使用style设置，建议静态样式放在wxss中有class指明，动态样式放在style。 可能遇到的问题在设置页面背景色的时候，如果我们在.container{}中设定了 background-color,那么会出现如下的结果 [解决方法] 指定height:1334rpx;但是如果换在其他模拟器中还是会出现上述问题。 指定height:100% 也无法实现预期的效果，原因的container中是有元素扩充起来的。 注意小程序默认在我们编写的骨架外面包裹了一个page标签，可以通过这个标签来设置整屏的颜色。","content":"<h1 id=\"小程序搭建\"><a href=\"#小程序搭建\" class=\"headerlink\" title=\"小程序搭建\"></a>小程序搭建</h1><hr>\n<h2 id=\"开发工具安装\"><a href=\"#开发工具安装\" class=\"headerlink\" title=\"开发工具安装\"></a>开发工具安装</h2><p>微信公众平台提供了winddows64,windows32,mac三个操作系统下的安装包，我们选择合适自己下载即可。（<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\" target=\"_blank\" rel=\"noopener\">微信开发者工具下载链接</a>）</p>\n<blockquote>\n<p>备注： 小程序的开发工具除了使用官方提供的微信开发者工具之外，还可以使用SublimeText,或者是WebStrom等，然后配合使用微信开发者工具进行调试操作。</p>\n</blockquote>\n<h2 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h2><p>在根据提示安装完成之后，我们需要用微信扫描二维码登录微信开发者工具。然后选择小程序项目</p>\n<p><img src=\"/images/miniprogram/choose.png\" alt=\"avatar\"></p>\n<p>然后我们选择小程序存放的位置，填写对应的demo，选择体验小程序，并且勾选建立普通快速启动模板。</p>\n<p><img src=\"/images/miniprogram/newDemo.png\" alt=\"avatar\"></p>\n<p>这里我们先使用无appId的方式即体验模式，虽然无法进行代码真机预览和上传等操作，部分 API 无法正常调用，但是不影响我们正常的开发。项目创建完如下图所示</p>\n<p><img src=\"/images/miniprogram/demo-detail.png\" alt=\"avatar\"></p>\n<blockquote>\n<p>关于开发工具再此不做详细说明，详情可以参考<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/page.html#%E5%90%AF%E5%8A%A8%E9%A1%B5\" target=\"_blank\" rel=\"noopener\">小程序开发工具介绍</a></p>\n</blockquote>\n<h2 id=\"项目结构介绍\"><a href=\"#项目结构介绍\" class=\"headerlink\" title=\"项目结构介绍\"></a>项目结构介绍</h2><h3 id=\"小程序文件类型\"><a href=\"#小程序文件类型\" class=\"headerlink\" title=\"小程序文件类型\"></a>小程序文件类型</h3><p>小程序中有且只有以下4中类型的文件：</p>\n<ul>\n<li>json 后缀的 JSON 配置文件</li>\n<li>wxml 后缀的 WXML 模板文件</li>\n<li>wxss 后缀的 WXSS 样式文件</li>\n<li>js 后缀的 JS 脚本逻辑文件</li>\n</ul>\n<h3 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h3><p>小程序的默认的包结构如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+- pages</span><br><span class=\"line\">\t+- indexs</span><br><span class=\"line\">\t\t- index.js</span><br><span class=\"line\">\t\t- index.json</span><br><span class=\"line\">\t\t- index.wsml</span><br><span class=\"line\">\t\t- index.wxss</span><br><span class=\"line\">\t+- logs</span><br><span class=\"line\">\t\t- logs.js</span><br><span class=\"line\">\t\t- logs.json</span><br><span class=\"line\">\t\t- logs.wsml</span><br><span class=\"line\">\t\t- logs.wxss</span><br><span class=\"line\">+- utils</span><br><span class=\"line\">\t- util.js</span><br><span class=\"line\">app.js</span><br><span class=\"line\">app.json</span><br><span class=\"line\">app.wxss</span><br><span class=\"line\">project.config.json</span><br></pre></td></tr></table></figure>\n<p>所有的配置遵循就近原则</p>\n<h3 id=\"包结构说明\"><a href=\"#包结构说明\" class=\"headerlink\" title=\"包结构说明\"></a>包结构说明</h3><p>1.app.json 小程序逻辑（必须）</p>\n<blockquote>\n<p>app.json中的App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。</p>\n</blockquote>\n<p>2.app.json 小程序公共设置（必须）</p>\n<blockquote>\n<p>app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>\n</blockquote>\n<p>3.app.wxss 全局样式文件 </p>\n<blockquote>\n<p>在app.wxss中可以定义一些全局属性的样式，这样相同的养生石在单独的页面中就无需在配置了。</p>\n</blockquote>\n<p>4.project.config.json 是工具配置文件。</p>\n<blockquote>\n<p>所有对当前开发工具做的操作都会保存到project.config.json文件中，当我们重新安装工具或者是更换电脑时，只需导入项目的代码即可恢复我们之前对工具的一些设置。</p>\n</blockquote>\n<p>5.pages 小程序模板存放的文件夹</p>\n<blockquote>\n<p>在小程序中所有的模板都在此文件中，并且每一个页面对应中有4个文件</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>必填</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>js</td>\n<td>是</td>\n<td>页面逻辑</td>\n</tr>\n<tr>\n<td>wxml</td>\n<td>是</td>\n<td>页面结构</td>\n</tr>\n<tr>\n<td>wxss</td>\n<td>否</td>\n<td>页面样式表</td>\n</tr>\n<tr>\n<td>json</td>\n<td>否</td>\n<td>页面配置</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ul>\n<li>为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。  </li>\n<li>页面中的wxss样式配置如果与app.wxss有相同的，那么采取就近原则，优先使用页面的样式。 </li>\n<li>小程序的页面是可以嵌套的，对应的可以有二级页面，三级页面等等，但是最多只能支持5级页面，这一点主要是从小程序的性能方面考虑，从而做的限制。  </li>\n</ul>\n</blockquote>\n<h1 id=\"编写简单页面\"><a href=\"#编写简单页面\" class=\"headerlink\" title=\"编写简单页面\"></a>编写简单页面</h1><h2 id=\"移动端的分辨率与rpx\"><a href=\"#移动端的分辨率与rpx\" class=\"headerlink\" title=\"移动端的分辨率与rpx\"></a>移动端的分辨率与rpx</h2><p>在开始编写页面之前我们首先要了解一下分辨率的概念，因为小程序是移动端的开发，在不同的机型中是需要进行适配的，所以要注意像素的使用。</p>\n<p><img src=\"/images/miniprogram/resolution.png\" alt=\"avatar\"></p>\n<ul>\n<li>pt  逻辑分辨率，pt的大小与屏幕尺寸与关系，简单可以理解为长度和视觉单位</li>\n<li>px  物理分辨率，与屏幕尺寸没有关系，用于描述一个单位中像素点的多少</li>\n<li>reader 设备像素比 一个pt包含多少个px，人类视觉极限为@2x</li>\n<li>ppi(dpi） 每一寸包含的px</li>\n</ul>\n<p>从上述图中可以看出1个pt可以有1个px构成也可以有2个，甚至是3个…</p>\n<p>小程序推荐的使用的单位是rpx。他和px之间的关系为 1rpx = 1px 。 唯一的区别就是rpx可以根据屏幕进行适配，而px不可以。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><ul>\n<li>不是所有的单位都适合rpx<br>当需要的元素大小适应屏幕尺寸，就选择rpx作为单位，否者使用px作为单位。一般来说文字不建议使用rpx；建议margin-top，margint-bottom 使用rpx,因为屏幕是可以进行垂直滚动的，而margin-left，margin-right使用px，当然这个不是绝对的也是根据具体问题具体分析的。</li>\n<li>为什么使用ip6的物理分辨率来设计UI?<br>小程序的模拟器采用的是逻辑分辨率。在设计时采用的就是根据iphone6的屏幕来设计的。所以存在:1px = 1rpx=2pt。方便开发，所以在调试时使用iphone6模拟器进行调试。</li>\n<li>为什么iphone plus 的设备相素比大于iphone6的，但是图像并没有更清晰呢？<br>从理论上来说同一个单位的包含的物理像素点多，显示的图像会更细腻，更清晰，但是人类的极限的2备的像素比，所以虽然iphone6 plus 的像素比为3备的像素比但是我们视觉上并没有太大的感觉。</li>\n</ul>\n<h2 id=\"创建页面\"><a href=\"#创建页面\" class=\"headerlink\" title=\"创建页面\"></a>创建页面</h2><p>下图是我们将要实现的一个页面。<br><img src=\"/images/miniprogram/welcome.png\" alt=\"avatar\"></p>\n<h3 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h3><p>首先创建一个空的项目，建立小程序中必须的文件app.json，app.wxss以及pages文件夹,以及。然在pages下面创建welcome文件夹，然后建立对应welcome.wxml,welcome.wxss文件。</p>\n<p><img src=\"/images/miniprogram/2-package.png\" alt=\"avatar\"></p>\n<p>创建完之后我们需要把页面注册的小程序中，也就是配置到app.json的pages中。否则是不可以预览这个页面的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;pages&quot;: [</span><br><span class=\"line\">    &quot;pages/welcome/welcome&quot;   </span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>小程序中规定，pages下面的第一个页面，默认为显示的第一个页面  </li>\n<li>创建页面的一个快捷方式就是在直接在 app.json的pages数组中加入“pages/xxx/xxx”。在保存之后会在pages生成对应的xxx文件下面生成xxx.wxml、xxx.wxss、xxx.js以及xxx.json。</li>\n</ul>\n</blockquote>\n<h3 id=\"编写welcome-wxml\"><a href=\"#编写welcome-wxml\" class=\"headerlink\" title=\"编写welcome.wxml\"></a>编写welcome.wxml</h3><p>小程序中有一个基本的视图容器view,类似于html里面的div,用来分割页面中的不同部分。文字可以直接写也可使用text标签包围。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view class=&apos;container&apos;&gt;</span><br><span class=\"line\">  &lt;image class=&quot;welcome-avatar&quot; src=&apos;/images/welcome.jpg&apos;&gt;&lt;/image&gt;</span><br><span class=\"line\">  &lt;text class=&quot;welcome-title&quot;&gt;Cheryl  Demo&lt;/text&gt;</span><br><span class=\"line\">  &lt;view class=&apos;moto-container&apos;&gt;</span><br><span class=\"line\">    &lt;text class=&apos;moto&apos;&gt;开启小程序之旅 &lt;/text&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>text标签的相关Tips  </li>\n</ul>\n<blockquote>\n<ul>\n<li>使用text包围的文字可以添加自定义样式，也可在手机中可以长按选中。</li>\n<li>可以识别转移字符,例如\\n识别为换行   </li>\n<li>各个操作系统的空格标准并不一致。  </li>\n<li><text> 组件内只支持 <text> 嵌套。  </text></text></li>\n</ul>\n</blockquote>\n<p>在编写完页面之后，编写对应的wxss文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* pages/welcome/welcome.wxss */</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display:flex;/变成弹性模型/</span><br><span class=\"line\">  flex-direction: column;/垂直布局/</span><br><span class=\"line\">  align-items: center;/* 居中对齐 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.welcome-avatar&#123;</span><br><span class=\"line\">  width: 200rpx;</span><br><span class=\"line\">  height: 200rpx;</span><br><span class=\"line\">  margin-top: 160rpx;</span><br><span class=\"line\">  /*图片显示成圆形  */</span><br><span class=\"line\">  border-radius: 500px; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.welcome-title&#123;</span><br><span class=\"line\">  font-size: 22px;</span><br><span class=\"line\">  font-weight: bold; </span><br><span class=\"line\">  margin-top: 40rpx;</span><br><span class=\"line\">  color:  gray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.moto-container&#123;</span><br><span class=\"line\">  border: 1px solid #FF99FF;</span><br><span class=\"line\">  border-radius: 5px;</span><br><span class=\"line\">  margin-top: 60rpx;</span><br><span class=\"line\">  background-color: #FF99FF;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.moto&#123;</span><br><span class=\"line\">  font-size: 20px;</span><br><span class=\"line\">  color: #ffffff;</span><br><span class=\"line\">  padding: 20px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">page&#123;</span><br><span class=\"line\">  background-color: #FFCCFF;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在小程序中不需要引入 wxss,因为app.json的pages中注册页面的时候无需指明具体的文件，所以pages可以自动的把welcome中4中不同类型的文件关联在一起。</p>\n<blockquote>\n<p>在wxml中样式可以使用class也可以使用style设置，建议静态样式放在wxss中有class指明，动态样式放在style。</p>\n</blockquote>\n<ul>\n<li>可能遇到的问题<br>在设置页面背景色的时候，如果我们在.container{}中设定了 background-color,那么会出现如下的结果<br><img src=\"F:/hexo/source/_posts/minipogram/images/miniprogram/2-error.png\" alt=\"avatar\"></li>\n</ul>\n<p>[解决方法]  </p>\n<ul>\n<li>指定height:1334rpx;但是如果换在其他模拟器中还是会出现上述问题。  </li>\n<li>指定height:100% 也无法实现预期的效果，原因的container中是有元素扩充起来的。  </li>\n<li>注意小程序默认在我们编写的骨架外面包裹了一个page标签，可以通过这个标签来设置整屏的颜色。</li>\n</ul>\n"},{"title":"git 命令","text":"初始化本地仓库12345git initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/xx/xx.gitgit push -u origin master 在github上面创建远程仓库的时候，不要创建readme.md,即可用上述命令创建成功 【问题】 因为本地创建了readme.md，导致提交的时候造成了冲突 gitignore文件 项目初始化的时候添加.gitignore 因为是点开头，没有文件名，没办法直接在windows目录下直接创建，必须通过右键Git Bash，按照linux的方式来新建.gitignore文件。具体步骤如下： 在需要创建 .gitignore 文件的文件夹, 右键选择Git Bash 进入命令行，进入项目所在目录。 输入 touch .gitignore 在文件夹就生成了一个“.gitignore”文件。 然后在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。 在添加.gitignore文件的时候，参照 gitignore 原则 查看查看commitscommits，它在git中扮演了一个重要角色，我们平常用的一些操作git clone ,git commit 都会产生commits，通俗的讲这个就是版本号。使用如下命令 1git reflog 回退push 成功后回退我们在使用Git进行版本控制时，有可能会出现这种情况。git push后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。 命令详解首先将本地的内容回退到自己想要的版本。回退版本我一般使用。在这里我们要明确的一点是git reset可以看成不产生commits，只是改变了当前HEAD指向的commits。 1git reset 其中这条命令中又分为两种 git reset –sort git reset –hard 前者表示只是改变了HEAD的指向，本地代码不会变化，我们使用git status依然可以看到，同时也可以git commit提交。 ​ 后者直接回改变本地源码，不仅仅指向变化了，代码也回到了那个版本时的代码，所以使用是一定要小心，想清楚。 如果只是回退到上个版本可以使用 12git reset -–soft xx版本号xxxx git reset –-hard xx版本号xxx 也可以使用下面的命令 12git reset –soft HEAD~1 git reset –hard HEAD~1 因为前面说了HEAD就代表当前，所以上一个版本其实就是当前-1 当我们使用下面的命令时，发现并没有发生什么变化，因为HEAD表示的就是当前版本。 1git reset HEAD 示例 git reset –soft HEAD~1 我们可以知道其实HEAD已经指向上一个commits了，我们可以是用git reflog验证下 我们再使用git status看看，发现没，代码还在缓存区中 这时候就好办了，我们选择很多，可以直接修改代码，再commit，也可以取消git add 命令，指令如下 git rm –cached xxx文件名xxxgit rm 至于这两者的区别看这里吧[GIT]代码在GIT ADD之后如何取消 ok 到现在为止，本地的版本已经达到我们想要的了，现在只需要改变远程仓库的版本了，对的，我们只需要在git commit 后，再使用 git push origin 分支名 就可以将新的代码覆盖掉远程仓库版本代码，这样子就达到了撤销远程仓库代码一样的效果，但是这里有点点问题，先接着看吧 提交失败，因为当前分支的版本低于远程分支的版本，所以要想覆盖掉它，必须使用force git push origin 分支 –forceok，大功告成 分支把分支推送到远端 https://blog.csdn.net/kakadiablo/article/details/79517985 创建分支删除分支 删除本地分支 1git branch -D &lt;BranchName&gt; 删除远程分支 1git push origin --delete &lt;BranchName&gt; 查看远程分支 使用如下git命令查看所有远程分支： git branch -r 查看远程和本地所有分支： git branch -a 其中远程分支是红色的 查看本地分支 git branch 在输出结果中，前面带* 的是当前分支。 拉取远程分支并创建本地分支方法一使用如下命令： git checkout -b 本地分支名x origin/远程分支名x 使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 方式二使用如下命令： git fetch origin 远程分支名x:本地分支名x 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。 采用此种方法建立的本地分支不会和远程分支建立映射关系。 本地分支和远程分支https://blog.csdn.net/carfge/article/details/79691360 建立映射关系的作用建立映射关系（或者为跟踪关系track）。这样使用git pull或者git push时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。git branch -vv输出： 上面的本地分支和远程分支都有映射关系，如果没有，就需要手动建立：git branch -u origin/分支名，或者git branch --set-upstream-to origin/分支名origin 为git地址的标志，可以建立当前分支与远程分支的映射关系。 撤销本映射关系git branch --unset-upstream之后可以再次用git branch -vv 查看本地分支和远程分支映射关系 本地分支只能跟踪远程的同名分支吗 答案是否定的，本地分支可以与远程不同名的分支建立映射关系 ​ 操作和之前的一样，只是可以指定和本地分支名不同的远程分支名，然后使用git branch -vv 查看映射关系，可以发现建立映射成功。 常见问题远程库‘origin’不存在 【 问题描述】 fatal: ‘origin’ does not appear to be a git repository ​ fatal: Could not read from remote repository. ​ Please make sure you have the correct access rights and the repository exists. 【 解决方案】 首先,检查你的起源是设定的运行 1git remote -v ​ ​ 显示 orgin git@github.com:chaorwin/chaorwin.git (fetch) orgin git@github.com:chaorwin/chaorwin.git (push) “origin” 不存在 ​ 2.重命名它,或改变URL,删除它,然后添加正确的一个。 ​ git remote remove orgin ​ 3. 增加一个 ​ git remot add origin git@github.com:chaorwin/chaorwin.git ​ 4. git push origin master 文件大小超过限制问题描述: github RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 出现此问题有可能是上传大小限制执行如下命令: 12git config http.postBuffer 524288000//524288000算法： 1024*1024*500(500M) 在更改了文件大小之后，可能会出现如下错误： curl 56 OpenSSL SSL_read:SSL_ERROR_sysCALL 因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。解决方案如下：第一步，克隆远程仓库时，用env命令设置GIT_SSL_NO_VERIFY环境变量为”ture”，并同时调用正常的git clone命令。完整的命令如下： 12env GIT_SSL_NO_VERIFY=true git clone https://&lt;host_name/git/project.git12 第二步，在克隆完毕的仓库中将http.sslVerify设置为”false”。完整的命令如下： 1git config http.sslVerify &quot;false&quot; 参考文章 git常见命令思维导图","content":"<h1 id=\"初始化本地仓库\"><a href=\"#初始化本地仓库\" class=\"headerlink\" title=\"初始化本地仓库\"></a>初始化本地仓库</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\">git remote add origin https://github.com/xx/xx.git</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在github上面创建远程仓库的时候，不要创建readme.md,即可用上述命令创建成功</p>\n</blockquote>\n<p>【问题】</p>\n<ul>\n<li>因为本地创建了readme.md，导致提交的时候造成了冲突</li>\n</ul>\n<h2 id=\"gitignore文件\"><a href=\"#gitignore文件\" class=\"headerlink\" title=\"gitignore文件\"></a>gitignore文件</h2><ul>\n<li><p>项目初始化的时候添加.gitignore</p>\n<p>因为是点开头，没有文件名，没办法直接在windows目录下直接创建，必须通过右键Git Bash，按照linux的方式来新建.gitignore文件。具体步骤如下：</p>\n<ol>\n<li>在需要创建 .gitignore 文件的文件夹, 右键选择Git Bash 进入命令行，进入项目所在目录。</li>\n<li>输入 touch .gitignore 在文件夹就生成了一个“.gitignore”文件。</li>\n<li>然后在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>在添加.gitignore文件的时候，参照 <a href=\"https://blog.csdn.net/qq_34581118/article/details/78437992?locationNum=4&amp;fps=1\" target=\"_blank\" rel=\"noopener\">gitignore 原则</a></p>\n</blockquote>\n<h1 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h1><h2 id=\"查看commits\"><a href=\"#查看commits\" class=\"headerlink\" title=\"查看commits\"></a>查看commits</h2><p><strong>commits</strong>，它在git中扮演了一个重要角色，我们平常用的一些操作git clone ,git commit 都会产生commits，通俗的讲这个就是版本号。使用如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n<h1 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h1><h2 id=\"push-成功后回退\"><a href=\"#push-成功后回退\" class=\"headerlink\" title=\"push 成功后回退\"></a>push 成功后回退</h2><p>我们在使用Git进行版本控制时，有可能会出现这种情况。git push后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。 </p>\n<h3 id=\"命令详解\"><a href=\"#命令详解\" class=\"headerlink\" title=\"命令详解\"></a>命令详解</h3><p>首先将本地的内容回退到自己想要的版本。回退版本我一般使用。在这里我们要明确的一点是git reset可以看成不产生commits，只是改变了当前HEAD指向的commits。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset</span><br></pre></td></tr></table></figure>\n<p>其中这条命令中又分为两种 </p>\n<ul>\n<li><p>git reset –sort</p>\n</li>\n<li><p>git reset –hard</p>\n</li>\n</ul>\n<p>  前者表示只是改变了HEAD的指向，本地代码不会变化，我们使用git status依然可以看到，同时也可以git commit提交。</p>\n<p>​    后者直接回改变本地源码，不仅仅指向变化了，代码也回到了那个版本时的代码，所以使用是一定要小心，想清楚。 </p>\n<p>  如果只是回退到上个版本可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset -–soft xx版本号xxxx </span><br><span class=\"line\">git reset –-hard xx版本号xxx</span><br></pre></td></tr></table></figure>\n<p>也可以使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset –soft HEAD~1 </span><br><span class=\"line\">git reset –hard HEAD~1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为前面说了HEAD就代表当前，所以上一个版本其实就是当前-1</p>\n</blockquote>\n<p>当我们使用下面的命令时，发现并没有发生什么变化，因为HEAD表示的就是当前版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><blockquote>\n<p>git reset –soft HEAD~1</p>\n</blockquote>\n<p>   我们可以知道其实HEAD已经指向上一个commits了，我们可以是用git reflog验证下</p>\n<p>   我们再使用git status看看，发现没，代码还在缓存区中 </p>\n<p>   这时候就好办了，我们选择很多，可以直接修改代码，再commit，也可以取消git add 命令，指令如下</p>\n<blockquote>\n<p>git rm –cached xxx文件名xxx<br>git rm</p>\n</blockquote>\n<p>   至于这两者的区别看这里吧<a href=\"https://broadeno.wordpress.com/2008/10/27/git%E4%BB%A3%E7%A0%81%E5%9C%A8git-add%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88/\" target=\"_blank\" rel=\"noopener\">[GIT]代码在GIT ADD之后如何取消</a><br>   ok 到现在为止，本地的版本已经达到我们想要的了，现在只需要改变远程仓库的版本了，对的，我们只需要在git commit 后，再使用 git push origin 分支名 就可以将新的代码覆盖掉远程仓库版本代码，这样子就达到了撤销远程仓库代码一样的效果，但是这里有点点问题，先接着看吧 </p>\n<p>提交失败，因为当前分支的版本低于远程分支的版本，所以要想覆盖掉它，必须使用force</p>\n<blockquote>\n<p>git push origin 分支 –force<br>ok，大功告成</p>\n</blockquote>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>把分支推送到远端</p>\n<p><a href=\"https://blog.csdn.net/kakadiablo/article/details/79517985\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kakadiablo/article/details/79517985</a></p>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><ul>\n<li>删除本地分支</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -D &lt;BranchName&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除远程分支</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete &lt;BranchName&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看远程分支\"><a href=\"#查看远程分支\" class=\"headerlink\" title=\"查看远程分支\"></a>查看远程分支</h3><ul>\n<li>使用如下git命令查看所有远程分支：</li>\n</ul>\n<p><code>git branch -r</code></p>\n<ul>\n<li>查看远程和本地所有分支：</li>\n</ul>\n<p><code>git branch -a</code></p>\n<blockquote>\n<p>其中远程分支是红色的</p>\n</blockquote>\n<ul>\n<li>查看本地分支 </li>\n</ul>\n<p><code>git branch</code> </p>\n<blockquote>\n<p>在输出结果中，前面带<code>*</code> 的是当前分支。</p>\n</blockquote>\n<h3 id=\"拉取远程分支并创建本地分支\"><a href=\"#拉取远程分支并创建本地分支\" class=\"headerlink\" title=\"拉取远程分支并创建本地分支\"></a>拉取远程分支并创建本地分支</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>使用如下命令：</p>\n<p><code>git checkout -b 本地分支名x origin/远程分支名x</code></p>\n<p>使用该方式会在本地新建分支x，并自动切换到该本地分支x。</p>\n<p>采用此种方法建立的本地分支会和远程分支建立映射关系。</p>\n<h4 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h4><p>使用如下命令：</p>\n<p><code>git fetch origin 远程分支名x:本地分支名x</code></p>\n<p>使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。</p>\n<p>采用此种方法建立的本地分支不会和远程分支建立映射关系。</p>\n<h3 id=\"本地分支和远程分支\"><a href=\"#本地分支和远程分支\" class=\"headerlink\" title=\"本地分支和远程分支\"></a>本地分支和远程分支</h3><p><a href=\"https://blog.csdn.net/carfge/article/details/79691360\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/carfge/article/details/79691360</a></p>\n<h4 id=\"建立映射关系的作用\"><a href=\"#建立映射关系的作用\" class=\"headerlink\" title=\"建立映射关系的作用\"></a>建立映射关系的作用</h4><h4 id=\"建立映射关系（或者为跟踪关系track）。\"><a href=\"#建立映射关系（或者为跟踪关系track）。\" class=\"headerlink\" title=\"建立映射关系（或者为跟踪关系track）。\"></a>建立映射关系（或者为跟踪关系track）。</h4><p>这样使用git pull或者git push时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。<br><code>git branch -vv</code><br>输出：<br><img src=\"https://img-blog.csdn.net/20180208101910427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd4aWFveWFuZzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>上面的本地分支和远程分支都有映射关系，如果没有，就需要手动建立：<br><code>git branch -u origin/分支名</code>，<br>或者<br><code>git branch --set-upstream-to origin/分支名</code><br><code>origin</code> 为git地址的标志，可以建立当前分支与远程分支的映射关系。</p>\n<h4 id=\"撤销本映射关系\"><a href=\"#撤销本映射关系\" class=\"headerlink\" title=\"撤销本映射关系\"></a>撤销本映射关系</h4><p><code>git branch --unset-upstream</code><br>之后可以再次用<code>git branch -vv</code> 查看本地分支和远程分支映射关系</p>\n<h4 id=\"本地分支只能跟踪远程的同名分支吗\"><a href=\"#本地分支只能跟踪远程的同名分支吗\" class=\"headerlink\" title=\"本地分支只能跟踪远程的同名分支吗\"></a>本地分支只能跟踪远程的同名分支吗</h4><ul>\n<li>答案是否定的，本地分支可以与远程不同名的分支建立映射关系</li>\n</ul>\n<p>​       操作和之前的一样，只是可以指定和本地分支名不同的远程分支名，然后使用<code>git branch -vv</code> 查看映射关系，可以发现建立映射成功。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h2 id=\"远程库‘origin’不存在\"><a href=\"#远程库‘origin’不存在\" class=\"headerlink\" title=\"远程库‘origin’不存在\"></a>远程库‘origin’不存在</h2><p> 【 问题描述】</p>\n<blockquote>\n<p>  fatal: ‘origin’ does not appear to be a git repository</p>\n<p>​    fatal: Could not read from remote repository.</p>\n<p>​    Please make sure you have the correct access rights and the repository exists.</p>\n</blockquote>\n<p>  【 解决方案】</p>\n<ul>\n<li><p>首先,检查你的起源是设定的运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p>​                         </p>\n</li>\n</ul>\n<p>​                           显示<br>                         orgin    <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:chaorwin/chaorwin.git (fetch)<br>                         orgin    <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:chaorwin/chaorwin.git (push)<br>                          “origin” 不存在</p>\n<p>​                       2.重命名它,或改变URL,删除它,然后添加正确的一个。</p>\n<p>​                            git remote remove orgin</p>\n<p>​                      3. 增加一个</p>\n<p>​                            git remot add origin <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:chaorwin/chaorwin.git</p>\n<p>​                      4. git push origin master</p>\n<h2 id=\"文件大小超过限制\"><a href=\"#文件大小超过限制\" class=\"headerlink\" title=\"文件大小超过限制\"></a>文件大小超过限制</h2><p>问题描述: </p>\n<blockquote>\n<p> github RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</p>\n</blockquote>\n<p>出现此问题有可能是上传大小限制<br>执行如下命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config http.postBuffer 524288000</span><br><span class=\"line\">//524288000算法： 1024*1024*500(500M)</span><br></pre></td></tr></table></figure>\n<p>在更改了文件大小之后，可能会出现如下错误：</p>\n<blockquote>\n<p> curl 56 OpenSSL SSL_read:SSL_ERROR_sysCALL</p>\n</blockquote>\n<p>因为服务器的SSL证书没有经过第三方机构的签署，所以才报错。解决方案如下：<br>第一步，克隆远程仓库时，用env命令设置GIT_SSL_NO_VERIFY环境变量为”ture”，并同时调用正常的git clone命令。完整的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env GIT_SSL_NO_VERIFY=true git clone https://&lt;host_name/git/project.git</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<p>第二步，在克隆完毕的仓库中将http.sslVerify设置为”false”。完整的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"http://img.blog.csdn.net/20160613140756568\" target=\"_blank\" rel=\"noopener\">git常见命令思维导图</a></li>\n</ul>\n"},{"title":"计算两个经纬度之间的距离","text":"计算两个经纬度之间的距离本文使用的是距离公式是有google地图提供的。 公式说明 对上面的公式解释如下：1.Lat1 Lng1 表示A点经纬度，Lat2 Lng2 表示B点经纬度；2.a=Lat1 – Lat2 为两点纬度之差 b=Lng1 -Lng2 为两点经度之差；3.6378.137为地球半径，单位为千米；计算出来的结果单位为千米，若将半径改为米为单位则计算的结果单位为米。计算精度与谷歌地图的距离精度差不多，相差范围在0.2米以下。 代码示例123456789101112131415161718192021222324252627private static final double EARTH_RADIUS = 6378.137;// 地球半径,单位千米//将角度换算成弧度private static double rad(double d) &#123; return d * Math.PI / 180.0;&#125;/*** 用来比较是否在规定考勤范围* @param lat1第一个纬度* @param lng1第一个经度* @param lat2第二个纬度* @param lng2第二个经度* @return 两个经纬度的距离（km）*/public static double getDistance(double lat1, double lng1, double lat2,double lng2) &#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2); double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; //此处加上double类型转换是因为对于在几百的距离差值之前计算为0，无法达到预期效果 s = (double)Math.round(s * 10000) / 10000; s = s * 10000/ 10000; return s;&#125; 顺带提一下百度地图提供的计算两地经纬度的方法，很简单的一句话调用，可以自行去看百度地图API试试，计算结果单位：米 123var map = new BMap.Map(&quot;allmap&quot;);var pointA = new BMap.Point(106.486654,29.490295); // 点坐标Avar pointB = new BMap.Point(106.581515,29.615467); // 点坐标B 参考文章 地理空间距离计算及优化 根据两点经纬度计算距离","content":"<h1 id=\"计算两个经纬度之间的距离\"><a href=\"#计算两个经纬度之间的距离\" class=\"headerlink\" title=\"计算两个经纬度之间的距离\"></a>计算两个经纬度之间的距离</h1><p>本文使用的是距离公式是有google地图提供的。</p>\n<h3 id=\"公式说明\"><a href=\"#公式说明\" class=\"headerlink\" title=\"公式说明\"></a>公式说明</h3><p> <img src=\"http://img849.ph.126.net/GNSrkddcKlz3MbknMDS1zA==/2693715527121896352.bmp\" alt=\"关于经纬度求距离 - cza55007 - NO.1.LY\"></p>\n<p>对上面的公式解释如下：<br>1.Lat1 Lng1 表示A点经纬度，Lat2 Lng2 表示B点经纬度；<br>2.a=Lat1 – Lat2 为两点纬度之差  b=Lng1 -Lng2 为两点经度之差；<br>3.6378.137为地球半径，单位为千米；<br>计算出来的结果单位为千米，若将半径改为米为单位则计算的结果单位为米。<br>计算精度与谷歌地图的距离精度差不多，相差范围在0.2米以下。</p>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final double EARTH_RADIUS = 6378.137;// 地球半径,单位千米</span><br><span class=\"line\">//将角度换算成弧度</span><br><span class=\"line\">private static double rad(double d) &#123;</span><br><span class=\"line\">\treturn d * Math.PI / 180.0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\">* 用来比较是否在规定考勤范围</span><br><span class=\"line\">* @param lat1第一个纬度</span><br><span class=\"line\">* @param lng1第一个经度</span><br><span class=\"line\">* @param lat2第二个纬度</span><br><span class=\"line\">* @param lng2第二个经度</span><br><span class=\"line\">* @return 两个经纬度的距离（km）</span><br><span class=\"line\">*/</span><br><span class=\"line\">public static double getDistance(double lat1, double lng1, double lat2,double lng2) &#123;</span><br><span class=\"line\">    double radLat1 = rad(lat1);</span><br><span class=\"line\">    double radLat2 = rad(lat2);</span><br><span class=\"line\">    double a = radLat1 - radLat2;</span><br><span class=\"line\">    double b = rad(lng1) - rad(lng2);</span><br><span class=\"line\">    double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2)</span><br><span class=\"line\">    + Math.cos(radLat1) * Math.cos(radLat2)</span><br><span class=\"line\">    * Math.pow(Math.sin(b / 2), 2)));</span><br><span class=\"line\">    s = s * EARTH_RADIUS;</span><br><span class=\"line\">    //此处加上double类型转换是因为对于在几百的距离差值之前计算为0，无法达到预期效果</span><br><span class=\"line\">    s = (double)Math.round(s * 10000) / 10000;</span><br><span class=\"line\">    s = s * 10000/ 10000;</span><br><span class=\"line\">    return s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顺带提一下百度地图提供的计算两地经纬度的方法，很简单的一句话调用，可以自行去看百度地图API试试，计算结果单位：米</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var map = new BMap.Map(&quot;allmap&quot;);</span><br><span class=\"line\">var pointA = new BMap.Point(106.486654,29.490295);  // 点坐标A</span><br><span class=\"line\">var pointB = new BMap.Point(106.581515,29.615467);  // 点坐标B</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011001084/article/details/52980834\" target=\"_blank\" rel=\"noopener\">地理空间距离计算及优化</a></li>\n<li><a href=\"https://blog.csdn.net/b_h_l/article/details/8657040\" target=\"_blank\" rel=\"noopener\">根据两点经纬度计算距离</a></li>\n</ul>\n"}]}